{
  "version": 3,
  "sources": ["../../@tiptap/html/src/generateHTML.ts", "../../@tiptap/html/src/getHTMLFromFragment.ts", "../../@tiptap/html/src/generateJSON.ts", "../../@puckeditor/core/dist/Render-CU35UAWV.mjs"],
  "sourcesContent": ["import type { Extensions, JSONContent } from '@tiptap/core'\nimport { getSchema } from '@tiptap/core'\nimport { Node } from '@tiptap/pm/model'\n\nimport { getHTMLFromFragment } from './getHTMLFromFragment.js'\n\n/**\n * Generates HTML from a ProseMirror JSON content object.\n * @param doc - The ProseMirror JSON content object.\n * @param extensions - The Tiptap extensions used to build the schema.\n * @returns The generated HTML string.\n * @example\n * const doc = {\n *   type: 'doc',\n *   content: [\n *     {\n *       type: 'paragraph',\n *       content: [\n *         {\n *           type: 'text',\n *           text: 'Hello world!'\n *         }\n *       ]\n *     }\n *   ]\n * }\n * const extensions = [...]\n * const html = generateHTML(doc, extensions)\n */\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'generateHTML can only be used in a browser environment\\nIf you want to use this in a Node environment, use the `@tiptap/html/server` import instead.',\n    )\n  }\n\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode, schema)\n}\n", "import type { Node, Schema } from '@tiptap/pm/model'\nimport { DOMSerializer } from '@tiptap/pm/model'\n\n/**\n * Returns the HTML string representation of a given document node.\n *\n * @param doc - The document node to serialize.\n * @param schema - The Prosemirror schema to use for serialization.\n * @returns The HTML string representation of the document fragment.\n *\n * @example\n * ```typescript\n * const html = getHTMLFromFragment(doc, schema)\n * ```\n */\nexport function getHTMLFromFragment(doc: Node, schema: Schema, options?: { document?: Document }): string {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'getHTMLFromFragment can only be used in a browser environment\\nIf you want to use this in a Node environment, use the `@tiptap/html/server` import instead.',\n    )\n  }\n\n  if (options?.document) {\n    const wrap = options.document.createElement('div')\n\n    DOMSerializer.fromSchema(schema).serializeFragment(doc.content, { document: options.document }, wrap)\n    return wrap.innerHTML\n  }\n\n  const fragment = DOMSerializer.fromSchema(schema).serializeFragment(doc.content, {\n    document: window.document as unknown as Document,\n  })\n\n  const serializer = new XMLSerializer()\n\n  return serializer.serializeToString(fragment as any)\n}\n", "import type { Extensions } from '@tiptap/core'\nimport { getSchema } from '@tiptap/core'\nimport type { ParseOptions } from '@tiptap/pm/model'\nimport { DOMParser } from '@tiptap/pm/model'\n\n/**\n * Generates a JSON object from the given HTML string and converts it into a Prosemirror node with content.\n * @param {string} html - The HTML string to be converted into a Prosemirror node.\n * @param {Extensions} extensions - The extensions to be used for generating the schema.\n * @param {ParseOptions} options - The options to be supplied to the parser.\n * @returns {Record<string, any>} - The generated JSON object.\n * @example\n * const html = '<p>Hello, world!</p>'\n * const extensions = [...]\n * const json = generateJSON(html, extensions)\n * console.log(json) // { type: 'doc', content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Hello, world!' }] }] }\n */\nexport function generateJSON(html: string, extensions: Extensions, options?: ParseOptions): Record<string, any> {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'generateJSON can only be used in a browser environment\\nIf you want to use this in a Node environment, use the `@tiptap/html/server` import instead.',\n    )\n  }\n\n  const schema = getSchema(extensions)\n  const doc: Document = new window.DOMParser().parseFromString(html, 'text/html')\n\n  if (!doc) {\n    throw new Error('Failed to parse HTML string')\n  }\n\n  return DOMParser.fromSchema(schema)\n    .parse(doc.body as Node, options)\n    .toJSON()\n}\n", "import {\n  PuckRichText\n} from \"./chunk-2CNEFIQP.mjs\";\nimport {\n  styles_module_default\n} from \"./chunk-AOEDIUVK.mjs\";\nimport {\n  get_class_name_factory_default\n} from \"./chunk-Y2EFNT5P.mjs\";\nimport {\n  init_react_import\n} from \"./chunk-M6W7YEVX.mjs\";\n\n// components/RichTextEditor/components/Render.tsx\ninit_react_import();\nimport { generateHTML, generateJSON } from \"@tiptap/html\";\nimport { useMemo } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar getClassName = get_class_name_factory_default(\"RichTextEditor\", styles_module_default);\nfunction RichTextRender({\n  content,\n  field\n}) {\n  const { tiptap = {}, options } = field;\n  const { extensions = [] } = tiptap;\n  const loadedExtensions = useMemo(\n    () => [PuckRichText.configure(options), ...extensions],\n    [field, extensions]\n  );\n  const normalized = useMemo(() => {\n    if (typeof content === \"object\" && (content == null ? void 0 : content.type) === \"doc\") {\n      return content;\n    }\n    if (typeof content === \"string\") {\n      const isHtml = /<\\/?[a-z][\\s\\S]*>/i.test(content);\n      if (isHtml) {\n        return generateJSON(content, loadedExtensions);\n      }\n      return {\n        type: \"doc\",\n        content: [\n          { type: \"paragraph\", content: [{ type: \"text\", text: content }] }\n        ]\n      };\n    }\n    return { type: \"doc\", content: [] };\n  }, [content, loadedExtensions]);\n  const html = useMemo(() => {\n    return generateHTML(normalized, loadedExtensions);\n  }, [normalized, loadedExtensions]);\n  return /* @__PURE__ */ jsx(\"div\", { className: getClassName(), children: /* @__PURE__ */ jsx(\"div\", { className: \"rich-text\", dangerouslySetInnerHTML: { __html: html } }) });\n}\nexport {\n  RichTextRender\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;ACeO,SAAS,oBAAoB,KAAW,QAAgB,SAA2C;AACxG,MAAI,OAAO,WAAW,aAAa;AACjC,UAAM,IAAI;MACR;IACF;EACF;AAEA,MAAI,WAAA,OAAA,SAAA,QAAS,UAAU;AACrB,UAAM,OAAO,QAAQ,SAAS,cAAc,KAAK;AAEjD,kBAAc,WAAW,MAAM,EAAE,kBAAkB,IAAI,SAAS,EAAE,UAAU,QAAQ,SAAS,GAAG,IAAI;AACpG,WAAO,KAAK;EACd;AAEA,QAAM,WAAW,cAAc,WAAW,MAAM,EAAE,kBAAkB,IAAI,SAAS;IAC/E,UAAU,OAAO;EACnB,CAAC;AAED,QAAM,aAAa,IAAI,cAAc;AAErC,SAAO,WAAW,kBAAkB,QAAe;AACrD;ADPO,SAAS,aAAa,KAAkB,YAAgC;AAC7E,MAAI,OAAO,WAAW,aAAa;AACjC,UAAM,IAAI;MACR;IACF;EACF;AAEA,QAAM,SAAS,UAAU,UAAU;AACnC,QAAM,cAAc,KAAK,SAAS,QAAQ,GAAG;AAE7C,SAAO,oBAAoB,aAAa,MAAM;AAChD;AEvBO,SAAS,aAAa,MAAc,YAAwB,SAA6C;AAC9G,MAAI,OAAO,WAAW,aAAa;AACjC,UAAM,IAAI;MACR;IACF;EACF;AAEA,QAAM,SAASA,UAAU,UAAU;AACnC,QAAM,MAAgB,IAAI,OAAO,UAAU,EAAE,gBAAgB,MAAM,WAAW;AAE9E,MAAI,CAAC,KAAK;AACR,UAAM,IAAI,MAAM,6BAA6B;EAC/C;AAEA,SAAO,UAAU,WAAW,MAAM,EAC/B,MAAM,IAAI,MAAc,OAAO,EAC/B,OAAO;AACZ;;;AClBA,mBAAwB;AACxB,yBAAoB;AAHpB,kBAAkB;AAIlB,IAAI,eAAe,+BAA+B,kBAAkB,qBAAqB;AACzF,SAAS,eAAe;AAAA,EACtB;AAAA,EACA;AACF,GAAG;AACD,QAAM,EAAE,SAAS,CAAC,GAAG,QAAQ,IAAI;AACjC,QAAM,EAAE,aAAa,CAAC,EAAE,IAAI;AAC5B,QAAM,uBAAmB;AAAA,IACvB,MAAM,CAAC,aAAa,UAAU,OAAO,GAAG,GAAG,UAAU;AAAA,IACrD,CAAC,OAAO,UAAU;AAAA,EACpB;AACA,QAAM,iBAAa,sBAAQ,MAAM;AAC/B,QAAI,OAAO,YAAY,aAAa,WAAW,OAAO,SAAS,QAAQ,UAAU,OAAO;AACtF,aAAO;AAAA,IACT;AACA,QAAI,OAAO,YAAY,UAAU;AAC/B,YAAM,SAAS,qBAAqB,KAAK,OAAO;AAChD,UAAI,QAAQ;AACV,eAAO,aAAa,SAAS,gBAAgB;AAAA,MAC/C;AACA,aAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS;AAAA,UACP,EAAE,MAAM,aAAa,SAAS,CAAC,EAAE,MAAM,QAAQ,MAAM,QAAQ,CAAC,EAAE;AAAA,QAClE;AAAA,MACF;AAAA,IACF;AACA,WAAO,EAAE,MAAM,OAAO,SAAS,CAAC,EAAE;AAAA,EACpC,GAAG,CAAC,SAAS,gBAAgB,CAAC;AAC9B,QAAM,WAAO,sBAAQ,MAAM;AACzB,WAAO,aAAa,YAAY,gBAAgB;AAAA,EAClD,GAAG,CAAC,YAAY,gBAAgB,CAAC;AACjC,aAAuB,wBAAI,OAAO,EAAE,WAAW,aAAa,GAAG,cAA0B,wBAAI,OAAO,EAAE,WAAW,aAAa,yBAAyB,EAAE,QAAQ,KAAK,EAAE,CAAC,EAAE,CAAC;AAC9K;",
  "names": ["getSchema"]
}
