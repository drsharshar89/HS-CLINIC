import {
  EditorInner,
  LoadedRichTextMenu,
  c
} from "./chunk-NEG5OASM.js";
import {
  Action,
  ActionBar,
  Group,
  IconButton,
  Label,
  LoadedRichTextMenuInner,
  Loader,
  RichTextMenu,
  Separator
} from "./chunk-BVQJQYZX.js";
import "./chunk-2R6OMXRI.js";
import "./chunk-NUUM2757.js";
import "./chunk-NMOWDVM2.js";
import {
  ChevronDown,
  ChevronRight,
  ChevronUp,
  CircleCheckBig,
  Copy,
  CornerLeftUp,
  EllipsisVertical,
  Expand,
  Globe,
  Hammer,
  Hash,
  Layers,
  LayoutGrid,
  Link,
  List,
  Lock,
  LockOpen,
  Maximize2,
  Minimize2,
  Monitor,
  PanelLeft,
  PanelRight,
  Plus,
  RectangleEllipsis,
  Redo2,
  Search,
  SlidersHorizontal,
  Smartphone,
  Tablet,
  ToyBrick,
  Trash,
  Type,
  Undo2,
  X,
  ZoomIn,
  ZoomOut,
  appStoreContext,
  createAppStore,
  createStore,
  deepEqual,
  defaultAppState,
  defaultSlots,
  defaultViewports,
  expandNode,
  generateId,
  getBox,
  getItem,
  getZoneId,
  insert,
  insertAction,
  makeStatePublic,
  mapFields,
  monitorHotkeys,
  populateIds,
  reorder,
  replace,
  resolveComponentData,
  rootAreaId,
  rootDroppableId,
  rootZone,
  setupZone,
  subscribeWithSelector,
  toComponent,
  useAppStore,
  useAppStoreApi,
  useHotkey,
  useMonitorHotkeys,
  useRegisterFieldsSlice,
  useRegisterHistorySlice,
  useRegisterPermissionsSlice,
  useResetAutoZoom,
  useStore,
  walkAppState,
  walkField,
  walkTree
} from "./chunk-BPEV6CY6.js";
import {
  styles_module_default
} from "./chunk-FVLWLOVM.js";
import {
  __async,
  __objRest,
  __spreadProps,
  __spreadValues,
  get_class_name_factory_default,
  init_react_import
} from "./chunk-7IAXJJJK.js";
import {
  require_jsx_runtime
} from "./chunk-VDCHTWZU.js";
import {
  require_react_dom
} from "./chunk-55OHZHPG.js";
import {
  __commonJS,
  __require,
  __toESM,
  require_react
} from "./chunk-77YYOHSB.js";

// node_modules/object-hash/dist/object_hash.js
var require_object_hash = __commonJS({
  "node_modules/object-hash/dist/object_hash.js"(exports, module) {
    !(function(e2) {
      var t2;
      "object" == typeof exports ? module.exports = e2() : "function" == typeof define && define.amd ? define(e2) : ("undefined" != typeof window ? t2 = window : "undefined" != typeof global ? t2 = global : "undefined" != typeof self && (t2 = self), t2.objectHash = e2());
    })(function() {
      return (function r2(o2, i2, u2) {
        function s2(n2, e3) {
          if (!i2[n2]) {
            if (!o2[n2]) {
              var t2 = "function" == typeof __require && __require;
              if (!e3 && t2) return t2(n2, true);
              if (a2) return a2(n2, true);
              throw new Error("Cannot find module '" + n2 + "'");
            }
            e3 = i2[n2] = { exports: {} };
            o2[n2][0].call(e3.exports, function(e4) {
              var t3 = o2[n2][1][e4];
              return s2(t3 || e4);
            }, e3, e3.exports, r2, o2, i2, u2);
          }
          return i2[n2].exports;
        }
        for (var a2 = "function" == typeof __require && __require, e2 = 0; e2 < u2.length; e2++) s2(u2[e2]);
        return s2;
      })({ 1: [function(w2, b2, m2) {
        !(function(e2, n2, s2, c3, d2, h2, p2, g2, y2) {
          "use strict";
          var r2 = w2("crypto");
          function t2(e3, t3) {
            t3 = u2(e3, t3);
            var n3;
            return void 0 === (n3 = "passthrough" !== t3.algorithm ? r2.createHash(t3.algorithm) : new l2()).write && (n3.write = n3.update, n3.end = n3.update), f2(t3, n3).dispatch(e3), n3.update || n3.end(""), n3.digest ? n3.digest("buffer" === t3.encoding ? void 0 : t3.encoding) : (e3 = n3.read(), "buffer" !== t3.encoding ? e3.toString(t3.encoding) : e3);
          }
          (m2 = b2.exports = t2).sha1 = function(e3) {
            return t2(e3);
          }, m2.keys = function(e3) {
            return t2(e3, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
          }, m2.MD5 = function(e3) {
            return t2(e3, { algorithm: "md5", encoding: "hex" });
          }, m2.keysMD5 = function(e3) {
            return t2(e3, { algorithm: "md5", encoding: "hex", excludeValues: true });
          };
          var o2 = r2.getHashes ? r2.getHashes().slice() : ["sha1", "md5"], i2 = (o2.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
          function u2(e3, t3) {
            var n3 = {};
            if (n3.algorithm = (t3 = t3 || {}).algorithm || "sha1", n3.encoding = t3.encoding || "hex", n3.excludeValues = !!t3.excludeValues, n3.algorithm = n3.algorithm.toLowerCase(), n3.encoding = n3.encoding.toLowerCase(), n3.ignoreUnknown = true === t3.ignoreUnknown, n3.respectType = false !== t3.respectType, n3.respectFunctionNames = false !== t3.respectFunctionNames, n3.respectFunctionProperties = false !== t3.respectFunctionProperties, n3.unorderedArrays = true === t3.unorderedArrays, n3.unorderedSets = false !== t3.unorderedSets, n3.unorderedObjects = false !== t3.unorderedObjects, n3.replacer = t3.replacer || void 0, n3.excludeKeys = t3.excludeKeys || void 0, void 0 === e3) throw new Error("Object argument required.");
            for (var r3 = 0; r3 < o2.length; ++r3) o2[r3].toLowerCase() === n3.algorithm.toLowerCase() && (n3.algorithm = o2[r3]);
            if (-1 === o2.indexOf(n3.algorithm)) throw new Error('Algorithm "' + n3.algorithm + '"  not supported. supported values: ' + o2.join(", "));
            if (-1 === i2.indexOf(n3.encoding) && "passthrough" !== n3.algorithm) throw new Error('Encoding "' + n3.encoding + '"  not supported. supported values: ' + i2.join(", "));
            return n3;
          }
          function a2(e3) {
            if ("function" == typeof e3) return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e3));
          }
          function f2(o3, t3, i3) {
            i3 = i3 || [];
            function u3(e3) {
              return t3.update ? t3.update(e3, "utf8") : t3.write(e3, "utf8");
            }
            return { dispatch: function(e3) {
              return this["_" + (null === (e3 = o3.replacer ? o3.replacer(e3) : e3) ? "null" : typeof e3)](e3);
            }, _object: function(t4) {
              var n3, e3 = Object.prototype.toString.call(t4), r3 = /\[object (.*)\]/i.exec(e3);
              r3 = (r3 = r3 ? r3[1] : "unknown:[" + e3 + "]").toLowerCase();
              if (0 <= (e3 = i3.indexOf(t4))) return this.dispatch("[CIRCULAR:" + e3 + "]");
              if (i3.push(t4), void 0 !== s2 && s2.isBuffer && s2.isBuffer(t4)) return u3("buffer:"), u3(t4);
              if ("object" === r3 || "function" === r3 || "asyncfunction" === r3) return e3 = Object.keys(t4), o3.unorderedObjects && (e3 = e3.sort()), false === o3.respectType || a2(t4) || e3.splice(0, 0, "prototype", "__proto__", "constructor"), o3.excludeKeys && (e3 = e3.filter(function(e4) {
                return !o3.excludeKeys(e4);
              })), u3("object:" + e3.length + ":"), n3 = this, e3.forEach(function(e4) {
                n3.dispatch(e4), u3(":"), o3.excludeValues || n3.dispatch(t4[e4]), u3(",");
              });
              if (!this["_" + r3]) {
                if (o3.ignoreUnknown) return u3("[" + r3 + "]");
                throw new Error('Unknown object type "' + r3 + '"');
              }
              this["_" + r3](t4);
            }, _array: function(e3, t4) {
              t4 = void 0 !== t4 ? t4 : false !== o3.unorderedArrays;
              var n3 = this;
              if (u3("array:" + e3.length + ":"), !t4 || e3.length <= 1) return e3.forEach(function(e4) {
                return n3.dispatch(e4);
              });
              var r3 = [], t4 = e3.map(function(e4) {
                var t5 = new l2(), n4 = i3.slice();
                return f2(o3, t5, n4).dispatch(e4), r3 = r3.concat(n4.slice(i3.length)), t5.read().toString();
              });
              return i3 = i3.concat(r3), t4.sort(), this._array(t4, false);
            }, _date: function(e3) {
              return u3("date:" + e3.toJSON());
            }, _symbol: function(e3) {
              return u3("symbol:" + e3.toString());
            }, _error: function(e3) {
              return u3("error:" + e3.toString());
            }, _boolean: function(e3) {
              return u3("bool:" + e3.toString());
            }, _string: function(e3) {
              u3("string:" + e3.length + ":"), u3(e3.toString());
            }, _function: function(e3) {
              u3("fn:"), a2(e3) ? this.dispatch("[native]") : this.dispatch(e3.toString()), false !== o3.respectFunctionNames && this.dispatch("function-name:" + String(e3.name)), o3.respectFunctionProperties && this._object(e3);
            }, _number: function(e3) {
              return u3("number:" + e3.toString());
            }, _xml: function(e3) {
              return u3("xml:" + e3.toString());
            }, _null: function() {
              return u3("Null");
            }, _undefined: function() {
              return u3("Undefined");
            }, _regexp: function(e3) {
              return u3("regex:" + e3.toString());
            }, _uint8array: function(e3) {
              return u3("uint8array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _uint8clampedarray: function(e3) {
              return u3("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _int8array: function(e3) {
              return u3("int8array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _uint16array: function(e3) {
              return u3("uint16array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _int16array: function(e3) {
              return u3("int16array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _uint32array: function(e3) {
              return u3("uint32array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _int32array: function(e3) {
              return u3("int32array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _float32array: function(e3) {
              return u3("float32array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _float64array: function(e3) {
              return u3("float64array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _arraybuffer: function(e3) {
              return u3("arraybuffer:"), this.dispatch(new Uint8Array(e3));
            }, _url: function(e3) {
              return u3("url:" + e3.toString());
            }, _map: function(e3) {
              u3("map:");
              e3 = Array.from(e3);
              return this._array(e3, false !== o3.unorderedSets);
            }, _set: function(e3) {
              u3("set:");
              e3 = Array.from(e3);
              return this._array(e3, false !== o3.unorderedSets);
            }, _file: function(e3) {
              return u3("file:"), this.dispatch([e3.name, e3.size, e3.type, e3.lastModfied]);
            }, _blob: function() {
              if (o3.ignoreUnknown) return u3("[blob]");
              throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
            }, _domwindow: function() {
              return u3("domwindow");
            }, _bigint: function(e3) {
              return u3("bigint:" + e3.toString());
            }, _process: function() {
              return u3("process");
            }, _timer: function() {
              return u3("timer");
            }, _pipe: function() {
              return u3("pipe");
            }, _tcp: function() {
              return u3("tcp");
            }, _udp: function() {
              return u3("udp");
            }, _tty: function() {
              return u3("tty");
            }, _statwatcher: function() {
              return u3("statwatcher");
            }, _securecontext: function() {
              return u3("securecontext");
            }, _connection: function() {
              return u3("connection");
            }, _zlib: function() {
              return u3("zlib");
            }, _context: function() {
              return u3("context");
            }, _nodescript: function() {
              return u3("nodescript");
            }, _httpparser: function() {
              return u3("httpparser");
            }, _dataview: function() {
              return u3("dataview");
            }, _signal: function() {
              return u3("signal");
            }, _fsevent: function() {
              return u3("fsevent");
            }, _tlswrap: function() {
              return u3("tlswrap");
            } };
          }
          function l2() {
            return { buf: "", write: function(e3) {
              this.buf += e3;
            }, end: function(e3) {
              this.buf += e3;
            }, read: function() {
              return this.buf;
            } };
          }
          m2.writeToStream = function(e3, t3, n3) {
            return void 0 === n3 && (n3 = t3, t3 = {}), f2(t3 = u2(e3, t3), n3).dispatch(e3);
          };
        }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
      }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e2, t2, f2) {
        !(function(e3, t3, n2, r2, o2, i2, u2, s2, a2) {
          !(function(e4) {
            "use strict";
            var a3 = "undefined" != typeof Uint8Array ? Uint8Array : Array, t4 = "+".charCodeAt(0), n3 = "/".charCodeAt(0), r3 = "0".charCodeAt(0), o3 = "a".charCodeAt(0), i3 = "A".charCodeAt(0), u3 = "-".charCodeAt(0), s3 = "_".charCodeAt(0);
            function f3(e5) {
              e5 = e5.charCodeAt(0);
              return e5 === t4 || e5 === u3 ? 62 : e5 === n3 || e5 === s3 ? 63 : e5 < r3 ? -1 : e5 < r3 + 10 ? e5 - r3 + 26 + 26 : e5 < i3 + 26 ? e5 - i3 : e5 < o3 + 26 ? e5 - o3 + 26 : void 0;
            }
            e4.toByteArray = function(e5) {
              var t5, n4;
              if (0 < e5.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
              var r4 = e5.length, r4 = "=" === e5.charAt(r4 - 2) ? 2 : "=" === e5.charAt(r4 - 1) ? 1 : 0, o4 = new a3(3 * e5.length / 4 - r4), i4 = 0 < r4 ? e5.length - 4 : e5.length, u4 = 0;
              function s4(e6) {
                o4[u4++] = e6;
              }
              for (t5 = 0; t5 < i4; t5 += 4, 0) s4((16711680 & (n4 = f3(e5.charAt(t5)) << 18 | f3(e5.charAt(t5 + 1)) << 12 | f3(e5.charAt(t5 + 2)) << 6 | f3(e5.charAt(t5 + 3)))) >> 16), s4((65280 & n4) >> 8), s4(255 & n4);
              return 2 == r4 ? s4(255 & (n4 = f3(e5.charAt(t5)) << 2 | f3(e5.charAt(t5 + 1)) >> 4)) : 1 == r4 && (s4((n4 = f3(e5.charAt(t5)) << 10 | f3(e5.charAt(t5 + 1)) << 4 | f3(e5.charAt(t5 + 2)) >> 2) >> 8 & 255), s4(255 & n4)), o4;
            }, e4.fromByteArray = function(e5) {
              var t5, n4, r4, o4, i4 = e5.length % 3, u4 = "";
              function s4(e6) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e6);
              }
              for (t5 = 0, r4 = e5.length - i4; t5 < r4; t5 += 3) n4 = (e5[t5] << 16) + (e5[t5 + 1] << 8) + e5[t5 + 2], u4 += s4((o4 = n4) >> 18 & 63) + s4(o4 >> 12 & 63) + s4(o4 >> 6 & 63) + s4(63 & o4);
              switch (i4) {
                case 1:
                  u4 = (u4 += s4((n4 = e5[e5.length - 1]) >> 2)) + s4(n4 << 4 & 63) + "==";
                  break;
                case 2:
                  u4 = (u4 = (u4 += s4((n4 = (e5[e5.length - 2] << 8) + e5[e5.length - 1]) >> 10)) + s4(n4 >> 4 & 63)) + s4(n4 << 2 & 63) + "=";
              }
              return u4;
            };
          })(void 0 === f2 ? this.base64js = {} : f2);
        }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, { buffer: 3, lYpoI2: 11 }], 3: [function(O, e2, H) {
        !(function(e3, n2, f2, r2, h2, p2, g2, y2, w2) {
          var a2 = O("base64-js"), i2 = O("ieee754");
          function f2(e4, t3, n3) {
            if (!(this instanceof f2)) return new f2(e4, t3, n3);
            var r3, o3, i3, u3, s3 = typeof e4;
            if ("base64" === t3 && "string" == s3) for (e4 = (u3 = e4).trim ? u3.trim() : u3.replace(/^\s+|\s+$/g, ""); e4.length % 4 != 0; ) e4 += "=";
            if ("number" == s3) r3 = j(e4);
            else if ("string" == s3) r3 = f2.byteLength(e4, t3);
            else {
              if ("object" != s3) throw new Error("First argument needs to be a number, array or string.");
              r3 = j(e4.length);
            }
            if (f2._useTypedArrays ? o3 = f2._augment(new Uint8Array(r3)) : ((o3 = this).length = r3, o3._isBuffer = true), f2._useTypedArrays && "number" == typeof e4.byteLength) o3._set(e4);
            else if (C(u3 = e4) || f2.isBuffer(u3) || u3 && "object" == typeof u3 && "number" == typeof u3.length) for (i3 = 0; i3 < r3; i3++) f2.isBuffer(e4) ? o3[i3] = e4.readUInt8(i3) : o3[i3] = e4[i3];
            else if ("string" == s3) o3.write(e4, 0, t3);
            else if ("number" == s3 && !f2._useTypedArrays && !n3) for (i3 = 0; i3 < r3; i3++) o3[i3] = 0;
            return o3;
          }
          function b2(e4, t3, n3, r3) {
            return f2._charsWritten = c3((function(e5) {
              for (var t4 = [], n4 = 0; n4 < e5.length; n4++) t4.push(255 & e5.charCodeAt(n4));
              return t4;
            })(t3), e4, n3, r3);
          }
          function m2(e4, t3, n3, r3) {
            return f2._charsWritten = c3((function(e5) {
              for (var t4, n4, r4 = [], o3 = 0; o3 < e5.length; o3++) n4 = e5.charCodeAt(o3), t4 = n4 >> 8, n4 = n4 % 256, r4.push(n4), r4.push(t4);
              return r4;
            })(t3), e4, n3, r3);
          }
          function v2(e4, t3, n3) {
            var r3 = "";
            n3 = Math.min(e4.length, n3);
            for (var o3 = t3; o3 < n3; o3++) r3 += String.fromCharCode(e4[o3]);
            return r3;
          }
          function o2(e4, t3, n3, r3) {
            r3 || (d2("boolean" == typeof n3, "missing or invalid endian"), d2(null != t3, "missing offset"), d2(t3 + 1 < e4.length, "Trying to read beyond buffer length"));
            var o3, r3 = e4.length;
            if (!(r3 <= t3)) return n3 ? (o3 = e4[t3], t3 + 1 < r3 && (o3 |= e4[t3 + 1] << 8)) : (o3 = e4[t3] << 8, t3 + 1 < r3 && (o3 |= e4[t3 + 1])), o3;
          }
          function u2(e4, t3, n3, r3) {
            r3 || (d2("boolean" == typeof n3, "missing or invalid endian"), d2(null != t3, "missing offset"), d2(t3 + 3 < e4.length, "Trying to read beyond buffer length"));
            var o3, r3 = e4.length;
            if (!(r3 <= t3)) return n3 ? (t3 + 2 < r3 && (o3 = e4[t3 + 2] << 16), t3 + 1 < r3 && (o3 |= e4[t3 + 1] << 8), o3 |= e4[t3], t3 + 3 < r3 && (o3 += e4[t3 + 3] << 24 >>> 0)) : (t3 + 1 < r3 && (o3 = e4[t3 + 1] << 16), t3 + 2 < r3 && (o3 |= e4[t3 + 2] << 8), t3 + 3 < r3 && (o3 |= e4[t3 + 3]), o3 += e4[t3] << 24 >>> 0), o3;
          }
          function _2(e4, t3, n3, r3) {
            if (r3 || (d2("boolean" == typeof n3, "missing or invalid endian"), d2(null != t3, "missing offset"), d2(t3 + 1 < e4.length, "Trying to read beyond buffer length")), !(e4.length <= t3)) return r3 = o2(e4, t3, n3, true), 32768 & r3 ? -1 * (65535 - r3 + 1) : r3;
          }
          function E(e4, t3, n3, r3) {
            if (r3 || (d2("boolean" == typeof n3, "missing or invalid endian"), d2(null != t3, "missing offset"), d2(t3 + 3 < e4.length, "Trying to read beyond buffer length")), !(e4.length <= t3)) return r3 = u2(e4, t3, n3, true), 2147483648 & r3 ? -1 * (4294967295 - r3 + 1) : r3;
          }
          function I(e4, t3, n3, r3) {
            return r3 || (d2("boolean" == typeof n3, "missing or invalid endian"), d2(t3 + 3 < e4.length, "Trying to read beyond buffer length")), i2.read(e4, t3, n3, 23, 4);
          }
          function A(e4, t3, n3, r3) {
            return r3 || (d2("boolean" == typeof n3, "missing or invalid endian"), d2(t3 + 7 < e4.length, "Trying to read beyond buffer length")), i2.read(e4, t3, n3, 52, 8);
          }
          function s2(e4, t3, n3, r3, o3) {
            o3 || (d2(null != t3, "missing value"), d2("boolean" == typeof r3, "missing or invalid endian"), d2(null != n3, "missing offset"), d2(n3 + 1 < e4.length, "trying to write beyond buffer length"), Y(t3, 65535));
            o3 = e4.length;
            if (!(o3 <= n3)) for (var i3 = 0, u3 = Math.min(o3 - n3, 2); i3 < u3; i3++) e4[n3 + i3] = (t3 & 255 << 8 * (r3 ? i3 : 1 - i3)) >>> 8 * (r3 ? i3 : 1 - i3);
          }
          function l2(e4, t3, n3, r3, o3) {
            o3 || (d2(null != t3, "missing value"), d2("boolean" == typeof r3, "missing or invalid endian"), d2(null != n3, "missing offset"), d2(n3 + 3 < e4.length, "trying to write beyond buffer length"), Y(t3, 4294967295));
            o3 = e4.length;
            if (!(o3 <= n3)) for (var i3 = 0, u3 = Math.min(o3 - n3, 4); i3 < u3; i3++) e4[n3 + i3] = t3 >>> 8 * (r3 ? i3 : 3 - i3) & 255;
          }
          function B(e4, t3, n3, r3, o3) {
            o3 || (d2(null != t3, "missing value"), d2("boolean" == typeof r3, "missing or invalid endian"), d2(null != n3, "missing offset"), d2(n3 + 1 < e4.length, "Trying to write beyond buffer length"), F(t3, 32767, -32768)), e4.length <= n3 || s2(e4, 0 <= t3 ? t3 : 65535 + t3 + 1, n3, r3, o3);
          }
          function L(e4, t3, n3, r3, o3) {
            o3 || (d2(null != t3, "missing value"), d2("boolean" == typeof r3, "missing or invalid endian"), d2(null != n3, "missing offset"), d2(n3 + 3 < e4.length, "Trying to write beyond buffer length"), F(t3, 2147483647, -2147483648)), e4.length <= n3 || l2(e4, 0 <= t3 ? t3 : 4294967295 + t3 + 1, n3, r3, o3);
          }
          function U(e4, t3, n3, r3, o3) {
            o3 || (d2(null != t3, "missing value"), d2("boolean" == typeof r3, "missing or invalid endian"), d2(null != n3, "missing offset"), d2(n3 + 3 < e4.length, "Trying to write beyond buffer length"), D(t3, 34028234663852886e22, -34028234663852886e22)), e4.length <= n3 || i2.write(e4, t3, n3, r3, 23, 4);
          }
          function x(e4, t3, n3, r3, o3) {
            o3 || (d2(null != t3, "missing value"), d2("boolean" == typeof r3, "missing or invalid endian"), d2(null != n3, "missing offset"), d2(n3 + 7 < e4.length, "Trying to write beyond buffer length"), D(t3, 17976931348623157e292, -17976931348623157e292)), e4.length <= n3 || i2.write(e4, t3, n3, r3, 52, 8);
          }
          H.Buffer = f2, H.SlowBuffer = f2, H.INSPECT_MAX_BYTES = 50, f2.poolSize = 8192, f2._useTypedArrays = (function() {
            try {
              var e4 = new ArrayBuffer(0), t3 = new Uint8Array(e4);
              return t3.foo = function() {
                return 42;
              }, 42 === t3.foo() && "function" == typeof t3.subarray;
            } catch (e5) {
              return false;
            }
          })(), f2.isEncoding = function(e4) {
            switch (String(e4).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, f2.isBuffer = function(e4) {
            return !(null == e4 || !e4._isBuffer);
          }, f2.byteLength = function(e4, t3) {
            var n3;
            switch (e4 += "", t3 || "utf8") {
              case "hex":
                n3 = e4.length / 2;
                break;
              case "utf8":
              case "utf-8":
                n3 = T(e4).length;
                break;
              case "ascii":
              case "binary":
              case "raw":
                n3 = e4.length;
                break;
              case "base64":
                n3 = M(e4).length;
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                n3 = 2 * e4.length;
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return n3;
          }, f2.concat = function(e4, t3) {
            if (d2(C(e4), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e4.length) return new f2(0);
            if (1 === e4.length) return e4[0];
            if ("number" != typeof t3) for (o3 = t3 = 0; o3 < e4.length; o3++) t3 += e4[o3].length;
            for (var n3 = new f2(t3), r3 = 0, o3 = 0; o3 < e4.length; o3++) {
              var i3 = e4[o3];
              i3.copy(n3, r3), r3 += i3.length;
            }
            return n3;
          }, f2.prototype.write = function(e4, t3, n3, r3) {
            isFinite(t3) ? isFinite(n3) || (r3 = n3, n3 = void 0) : (a3 = r3, r3 = t3, t3 = n3, n3 = a3), t3 = Number(t3) || 0;
            var o3, i3, u3, s3, a3 = this.length - t3;
            switch ((!n3 || a3 < (n3 = Number(n3))) && (n3 = a3), r3 = String(r3 || "utf8").toLowerCase()) {
              case "hex":
                o3 = (function(e5, t4, n4, r4) {
                  n4 = Number(n4) || 0;
                  var o4 = e5.length - n4;
                  (!r4 || o4 < (r4 = Number(r4))) && (r4 = o4), d2((o4 = t4.length) % 2 == 0, "Invalid hex string"), o4 / 2 < r4 && (r4 = o4 / 2);
                  for (var i4 = 0; i4 < r4; i4++) {
                    var u4 = parseInt(t4.substr(2 * i4, 2), 16);
                    d2(!isNaN(u4), "Invalid hex string"), e5[n4 + i4] = u4;
                  }
                  return f2._charsWritten = 2 * i4, i4;
                })(this, e4, t3, n3);
                break;
              case "utf8":
              case "utf-8":
                i3 = this, u3 = t3, s3 = n3, o3 = f2._charsWritten = c3(T(e4), i3, u3, s3);
                break;
              case "ascii":
              case "binary":
                o3 = b2(this, e4, t3, n3);
                break;
              case "base64":
                i3 = this, u3 = t3, s3 = n3, o3 = f2._charsWritten = c3(M(e4), i3, u3, s3);
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                o3 = m2(this, e4, t3, n3);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return o3;
          }, f2.prototype.toString = function(e4, t3, n3) {
            var r3, o3, i3, u3, s3 = this;
            if (e4 = String(e4 || "utf8").toLowerCase(), t3 = Number(t3) || 0, (n3 = void 0 !== n3 ? Number(n3) : s3.length) === t3) return "";
            switch (e4) {
              case "hex":
                r3 = (function(e5, t4, n4) {
                  var r4 = e5.length;
                  (!t4 || t4 < 0) && (t4 = 0);
                  (!n4 || n4 < 0 || r4 < n4) && (n4 = r4);
                  for (var o4 = "", i4 = t4; i4 < n4; i4++) o4 += k(e5[i4]);
                  return o4;
                })(s3, t3, n3);
                break;
              case "utf8":
              case "utf-8":
                r3 = (function(e5, t4, n4) {
                  var r4 = "", o4 = "";
                  n4 = Math.min(e5.length, n4);
                  for (var i4 = t4; i4 < n4; i4++) e5[i4] <= 127 ? (r4 += N(o4) + String.fromCharCode(e5[i4]), o4 = "") : o4 += "%" + e5[i4].toString(16);
                  return r4 + N(o4);
                })(s3, t3, n3);
                break;
              case "ascii":
              case "binary":
                r3 = v2(s3, t3, n3);
                break;
              case "base64":
                o3 = s3, u3 = n3, r3 = 0 === (i3 = t3) && u3 === o3.length ? a2.fromByteArray(o3) : a2.fromByteArray(o3.slice(i3, u3));
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                r3 = (function(e5, t4, n4) {
                  for (var r4 = e5.slice(t4, n4), o4 = "", i4 = 0; i4 < r4.length; i4 += 2) o4 += String.fromCharCode(r4[i4] + 256 * r4[i4 + 1]);
                  return o4;
                })(s3, t3, n3);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return r3;
          }, f2.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          }, f2.prototype.copy = function(e4, t3, n3, r3) {
            if (t3 = t3 || 0, (r3 = r3 || 0 === r3 ? r3 : this.length) !== (n3 = n3 || 0) && 0 !== e4.length && 0 !== this.length) {
              d2(n3 <= r3, "sourceEnd < sourceStart"), d2(0 <= t3 && t3 < e4.length, "targetStart out of bounds"), d2(0 <= n3 && n3 < this.length, "sourceStart out of bounds"), d2(0 <= r3 && r3 <= this.length, "sourceEnd out of bounds"), r3 > this.length && (r3 = this.length);
              var o3 = (r3 = e4.length - t3 < r3 - n3 ? e4.length - t3 + n3 : r3) - n3;
              if (o3 < 100 || !f2._useTypedArrays) for (var i3 = 0; i3 < o3; i3++) e4[i3 + t3] = this[i3 + n3];
              else e4._set(this.subarray(n3, n3 + o3), t3);
            }
          }, f2.prototype.slice = function(e4, t3) {
            var n3 = this.length;
            if (e4 = S2(e4, n3, 0), t3 = S2(t3, n3, n3), f2._useTypedArrays) return f2._augment(this.subarray(e4, t3));
            for (var r3 = t3 - e4, o3 = new f2(r3, void 0, true), i3 = 0; i3 < r3; i3++) o3[i3] = this[i3 + e4];
            return o3;
          }, f2.prototype.get = function(e4) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e4);
          }, f2.prototype.set = function(e4, t3) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e4, t3);
          }, f2.prototype.readUInt8 = function(e4, t3) {
            if (t3 || (d2(null != e4, "missing offset"), d2(e4 < this.length, "Trying to read beyond buffer length")), !(e4 >= this.length)) return this[e4];
          }, f2.prototype.readUInt16LE = function(e4, t3) {
            return o2(this, e4, true, t3);
          }, f2.prototype.readUInt16BE = function(e4, t3) {
            return o2(this, e4, false, t3);
          }, f2.prototype.readUInt32LE = function(e4, t3) {
            return u2(this, e4, true, t3);
          }, f2.prototype.readUInt32BE = function(e4, t3) {
            return u2(this, e4, false, t3);
          }, f2.prototype.readInt8 = function(e4, t3) {
            if (t3 || (d2(null != e4, "missing offset"), d2(e4 < this.length, "Trying to read beyond buffer length")), !(e4 >= this.length)) return 128 & this[e4] ? -1 * (255 - this[e4] + 1) : this[e4];
          }, f2.prototype.readInt16LE = function(e4, t3) {
            return _2(this, e4, true, t3);
          }, f2.prototype.readInt16BE = function(e4, t3) {
            return _2(this, e4, false, t3);
          }, f2.prototype.readInt32LE = function(e4, t3) {
            return E(this, e4, true, t3);
          }, f2.prototype.readInt32BE = function(e4, t3) {
            return E(this, e4, false, t3);
          }, f2.prototype.readFloatLE = function(e4, t3) {
            return I(this, e4, true, t3);
          }, f2.prototype.readFloatBE = function(e4, t3) {
            return I(this, e4, false, t3);
          }, f2.prototype.readDoubleLE = function(e4, t3) {
            return A(this, e4, true, t3);
          }, f2.prototype.readDoubleBE = function(e4, t3) {
            return A(this, e4, false, t3);
          }, f2.prototype.writeUInt8 = function(e4, t3, n3) {
            n3 || (d2(null != e4, "missing value"), d2(null != t3, "missing offset"), d2(t3 < this.length, "trying to write beyond buffer length"), Y(e4, 255)), t3 >= this.length || (this[t3] = e4);
          }, f2.prototype.writeUInt16LE = function(e4, t3, n3) {
            s2(this, e4, t3, true, n3);
          }, f2.prototype.writeUInt16BE = function(e4, t3, n3) {
            s2(this, e4, t3, false, n3);
          }, f2.prototype.writeUInt32LE = function(e4, t3, n3) {
            l2(this, e4, t3, true, n3);
          }, f2.prototype.writeUInt32BE = function(e4, t3, n3) {
            l2(this, e4, t3, false, n3);
          }, f2.prototype.writeInt8 = function(e4, t3, n3) {
            n3 || (d2(null != e4, "missing value"), d2(null != t3, "missing offset"), d2(t3 < this.length, "Trying to write beyond buffer length"), F(e4, 127, -128)), t3 >= this.length || (0 <= e4 ? this.writeUInt8(e4, t3, n3) : this.writeUInt8(255 + e4 + 1, t3, n3));
          }, f2.prototype.writeInt16LE = function(e4, t3, n3) {
            B(this, e4, t3, true, n3);
          }, f2.prototype.writeInt16BE = function(e4, t3, n3) {
            B(this, e4, t3, false, n3);
          }, f2.prototype.writeInt32LE = function(e4, t3, n3) {
            L(this, e4, t3, true, n3);
          }, f2.prototype.writeInt32BE = function(e4, t3, n3) {
            L(this, e4, t3, false, n3);
          }, f2.prototype.writeFloatLE = function(e4, t3, n3) {
            U(this, e4, t3, true, n3);
          }, f2.prototype.writeFloatBE = function(e4, t3, n3) {
            U(this, e4, t3, false, n3);
          }, f2.prototype.writeDoubleLE = function(e4, t3, n3) {
            x(this, e4, t3, true, n3);
          }, f2.prototype.writeDoubleBE = function(e4, t3, n3) {
            x(this, e4, t3, false, n3);
          }, f2.prototype.fill = function(e4, t3, n3) {
            if (t3 = t3 || 0, n3 = n3 || this.length, d2("number" == typeof (e4 = "string" == typeof (e4 = e4 || 0) ? e4.charCodeAt(0) : e4) && !isNaN(e4), "value is not a number"), d2(t3 <= n3, "end < start"), n3 !== t3 && 0 !== this.length) {
              d2(0 <= t3 && t3 < this.length, "start out of bounds"), d2(0 <= n3 && n3 <= this.length, "end out of bounds");
              for (var r3 = t3; r3 < n3; r3++) this[r3] = e4;
            }
          }, f2.prototype.inspect = function() {
            for (var e4 = [], t3 = this.length, n3 = 0; n3 < t3; n3++) if (e4[n3] = k(this[n3]), n3 === H.INSPECT_MAX_BYTES) {
              e4[n3 + 1] = "...";
              break;
            }
            return "<Buffer " + e4.join(" ") + ">";
          }, f2.prototype.toArrayBuffer = function() {
            if ("undefined" == typeof Uint8Array) throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (f2._useTypedArrays) return new f2(this).buffer;
            for (var e4 = new Uint8Array(this.length), t3 = 0, n3 = e4.length; t3 < n3; t3 += 1) e4[t3] = this[t3];
            return e4.buffer;
          };
          var t2 = f2.prototype;
          function S2(e4, t3, n3) {
            return "number" != typeof e4 ? n3 : t3 <= (e4 = ~~e4) ? t3 : 0 <= e4 || 0 <= (e4 += t3) ? e4 : 0;
          }
          function j(e4) {
            return (e4 = ~~Math.ceil(+e4)) < 0 ? 0 : e4;
          }
          function C(e4) {
            return (Array.isArray || function(e5) {
              return "[object Array]" === Object.prototype.toString.call(e5);
            })(e4);
          }
          function k(e4) {
            return e4 < 16 ? "0" + e4.toString(16) : e4.toString(16);
          }
          function T(e4) {
            for (var t3 = [], n3 = 0; n3 < e4.length; n3++) {
              var r3 = e4.charCodeAt(n3);
              if (r3 <= 127) t3.push(e4.charCodeAt(n3));
              else for (var o3 = n3, i3 = (55296 <= r3 && r3 <= 57343 && n3++, encodeURIComponent(e4.slice(o3, n3 + 1)).substr(1).split("%")), u3 = 0; u3 < i3.length; u3++) t3.push(parseInt(i3[u3], 16));
            }
            return t3;
          }
          function M(e4) {
            return a2.toByteArray(e4);
          }
          function c3(e4, t3, n3, r3) {
            for (var o3 = 0; o3 < r3 && !(o3 + n3 >= t3.length || o3 >= e4.length); o3++) t3[o3 + n3] = e4[o3];
            return o3;
          }
          function N(e4) {
            try {
              return decodeURIComponent(e4);
            } catch (e5) {
              return String.fromCharCode(65533);
            }
          }
          function Y(e4, t3) {
            d2("number" == typeof e4, "cannot write a non-number as a number"), d2(0 <= e4, "specified a negative value for writing an unsigned value"), d2(e4 <= t3, "value is larger than maximum value for type"), d2(Math.floor(e4) === e4, "value has a fractional component");
          }
          function F(e4, t3, n3) {
            d2("number" == typeof e4, "cannot write a non-number as a number"), d2(e4 <= t3, "value larger than maximum allowed value"), d2(n3 <= e4, "value smaller than minimum allowed value"), d2(Math.floor(e4) === e4, "value has a fractional component");
          }
          function D(e4, t3, n3) {
            d2("number" == typeof e4, "cannot write a non-number as a number"), d2(e4 <= t3, "value larger than maximum allowed value"), d2(n3 <= e4, "value smaller than minimum allowed value");
          }
          function d2(e4, t3) {
            if (!e4) throw new Error(t3 || "Failed assertion");
          }
          f2._augment = function(e4) {
            return e4._isBuffer = true, e4._get = e4.get, e4._set = e4.set, e4.get = t2.get, e4.set = t2.set, e4.write = t2.write, e4.toString = t2.toString, e4.toLocaleString = t2.toString, e4.toJSON = t2.toJSON, e4.copy = t2.copy, e4.slice = t2.slice, e4.readUInt8 = t2.readUInt8, e4.readUInt16LE = t2.readUInt16LE, e4.readUInt16BE = t2.readUInt16BE, e4.readUInt32LE = t2.readUInt32LE, e4.readUInt32BE = t2.readUInt32BE, e4.readInt8 = t2.readInt8, e4.readInt16LE = t2.readInt16LE, e4.readInt16BE = t2.readInt16BE, e4.readInt32LE = t2.readInt32LE, e4.readInt32BE = t2.readInt32BE, e4.readFloatLE = t2.readFloatLE, e4.readFloatBE = t2.readFloatBE, e4.readDoubleLE = t2.readDoubleLE, e4.readDoubleBE = t2.readDoubleBE, e4.writeUInt8 = t2.writeUInt8, e4.writeUInt16LE = t2.writeUInt16LE, e4.writeUInt16BE = t2.writeUInt16BE, e4.writeUInt32LE = t2.writeUInt32LE, e4.writeUInt32BE = t2.writeUInt32BE, e4.writeInt8 = t2.writeInt8, e4.writeInt16LE = t2.writeInt16LE, e4.writeInt16BE = t2.writeInt16BE, e4.writeInt32LE = t2.writeInt32LE, e4.writeInt32BE = t2.writeInt32BE, e4.writeFloatLE = t2.writeFloatLE, e4.writeFloatBE = t2.writeFloatBE, e4.writeDoubleLE = t2.writeDoubleLE, e4.writeDoubleBE = t2.writeDoubleBE, e4.fill = t2.fill, e4.inspect = t2.inspect, e4.toArrayBuffer = t2.toArrayBuffer, e4;
          };
        }).call(this, O("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(c3, d2, e2) {
        !(function(e3, t2, a2, n2, r2, o2, i2, u2, s2) {
          var a2 = c3("buffer").Buffer, f2 = 4, l2 = new a2(f2);
          l2.fill(0);
          d2.exports = { hash: function(e4, t3, n3, r3) {
            for (var o3 = t3((function(e5, t4) {
              e5.length % f2 != 0 && (n4 = e5.length + (f2 - e5.length % f2), e5 = a2.concat([e5, l2], n4));
              for (var n4, r4 = [], o4 = t4 ? e5.readInt32BE : e5.readInt32LE, i4 = 0; i4 < e5.length; i4 += f2) r4.push(o4.call(e5, i4));
              return r4;
            })(e4 = a2.isBuffer(e4) ? e4 : new a2(e4), r3), 8 * e4.length), t3 = r3, i3 = new a2(n3), u3 = t3 ? i3.writeInt32BE : i3.writeInt32LE, s3 = 0; s3 < o3.length; s3++) u3.call(i3, o3[s3], 4 * s3, true);
            return i3;
          } };
        }).call(this, c3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 5: [function(v2, e2, _2) {
        !(function(l2, c3, u2, d2, h2, p2, g2, y2, w2) {
          var u2 = v2("buffer").Buffer, e3 = v2("./sha"), t2 = v2("./sha256"), n2 = v2("./rng"), b2 = { sha1: e3, sha256: t2, md5: v2("./md5") }, s2 = 64, a2 = new u2(s2);
          function r2(e4, n3) {
            var r3 = b2[e4 = e4 || "sha1"], o3 = [];
            return r3 || i2("algorithm:", e4, "is not yet supported"), { update: function(e5) {
              return u2.isBuffer(e5) || (e5 = new u2(e5)), o3.push(e5), e5.length, this;
            }, digest: function(e5) {
              var t3 = u2.concat(o3), t3 = n3 ? (function(e6, t4, n4) {
                u2.isBuffer(t4) || (t4 = new u2(t4)), u2.isBuffer(n4) || (n4 = new u2(n4)), t4.length > s2 ? t4 = e6(t4) : t4.length < s2 && (t4 = u2.concat([t4, a2], s2));
                for (var r4 = new u2(s2), o4 = new u2(s2), i3 = 0; i3 < s2; i3++) r4[i3] = 54 ^ t4[i3], o4[i3] = 92 ^ t4[i3];
                return n4 = e6(u2.concat([r4, n4])), e6(u2.concat([o4, n4]));
              })(r3, n3, t3) : r3(t3);
              return o3 = null, e5 ? t3.toString(e5) : t3;
            } };
          }
          function i2() {
            var e4 = [].slice.call(arguments).join(" ");
            throw new Error([e4, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
          }
          a2.fill(0), _2.createHash = function(e4) {
            return r2(e4);
          }, _2.createHmac = r2, _2.randomBytes = function(e4, t3) {
            if (!t3 || !t3.call) return new u2(n2(e4));
            try {
              t3.call(this, void 0, new u2(n2(e4)));
            } catch (e5) {
              t3(e5);
            }
          };
          var o2, f2 = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], m2 = function(e4) {
            _2[e4] = function() {
              i2("sorry,", e4, "is not implemented yet");
            };
          };
          for (o2 in f2) m2(f2[o2], o2);
        }).call(this, v2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, v2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(w2, b2, e2) {
        !(function(e3, r2, o2, i2, u2, a2, f2, l2, y2) {
          var t2 = w2("./helpers");
          function n2(e4, t3) {
            e4[t3 >> 5] |= 128 << t3 % 32, e4[14 + (t3 + 64 >>> 9 << 4)] = t3;
            for (var n3 = 1732584193, r3 = -271733879, o3 = -1732584194, i3 = 271733878, u3 = 0; u3 < e4.length; u3 += 16) {
              var s3 = n3, a3 = r3, f3 = o3, l3 = i3, n3 = c3(n3, r3, o3, i3, e4[u3 + 0], 7, -680876936), i3 = c3(i3, n3, r3, o3, e4[u3 + 1], 12, -389564586), o3 = c3(o3, i3, n3, r3, e4[u3 + 2], 17, 606105819), r3 = c3(r3, o3, i3, n3, e4[u3 + 3], 22, -1044525330);
              n3 = c3(n3, r3, o3, i3, e4[u3 + 4], 7, -176418897), i3 = c3(i3, n3, r3, o3, e4[u3 + 5], 12, 1200080426), o3 = c3(o3, i3, n3, r3, e4[u3 + 6], 17, -1473231341), r3 = c3(r3, o3, i3, n3, e4[u3 + 7], 22, -45705983), n3 = c3(n3, r3, o3, i3, e4[u3 + 8], 7, 1770035416), i3 = c3(i3, n3, r3, o3, e4[u3 + 9], 12, -1958414417), o3 = c3(o3, i3, n3, r3, e4[u3 + 10], 17, -42063), r3 = c3(r3, o3, i3, n3, e4[u3 + 11], 22, -1990404162), n3 = c3(n3, r3, o3, i3, e4[u3 + 12], 7, 1804603682), i3 = c3(i3, n3, r3, o3, e4[u3 + 13], 12, -40341101), o3 = c3(o3, i3, n3, r3, e4[u3 + 14], 17, -1502002290), n3 = d2(n3, r3 = c3(r3, o3, i3, n3, e4[u3 + 15], 22, 1236535329), o3, i3, e4[u3 + 1], 5, -165796510), i3 = d2(i3, n3, r3, o3, e4[u3 + 6], 9, -1069501632), o3 = d2(o3, i3, n3, r3, e4[u3 + 11], 14, 643717713), r3 = d2(r3, o3, i3, n3, e4[u3 + 0], 20, -373897302), n3 = d2(n3, r3, o3, i3, e4[u3 + 5], 5, -701558691), i3 = d2(i3, n3, r3, o3, e4[u3 + 10], 9, 38016083), o3 = d2(o3, i3, n3, r3, e4[u3 + 15], 14, -660478335), r3 = d2(r3, o3, i3, n3, e4[u3 + 4], 20, -405537848), n3 = d2(n3, r3, o3, i3, e4[u3 + 9], 5, 568446438), i3 = d2(i3, n3, r3, o3, e4[u3 + 14], 9, -1019803690), o3 = d2(o3, i3, n3, r3, e4[u3 + 3], 14, -187363961), r3 = d2(r3, o3, i3, n3, e4[u3 + 8], 20, 1163531501), n3 = d2(n3, r3, o3, i3, e4[u3 + 13], 5, -1444681467), i3 = d2(i3, n3, r3, o3, e4[u3 + 2], 9, -51403784), o3 = d2(o3, i3, n3, r3, e4[u3 + 7], 14, 1735328473), n3 = h2(n3, r3 = d2(r3, o3, i3, n3, e4[u3 + 12], 20, -1926607734), o3, i3, e4[u3 + 5], 4, -378558), i3 = h2(i3, n3, r3, o3, e4[u3 + 8], 11, -2022574463), o3 = h2(o3, i3, n3, r3, e4[u3 + 11], 16, 1839030562), r3 = h2(r3, o3, i3, n3, e4[u3 + 14], 23, -35309556), n3 = h2(n3, r3, o3, i3, e4[u3 + 1], 4, -1530992060), i3 = h2(i3, n3, r3, o3, e4[u3 + 4], 11, 1272893353), o3 = h2(o3, i3, n3, r3, e4[u3 + 7], 16, -155497632), r3 = h2(r3, o3, i3, n3, e4[u3 + 10], 23, -1094730640), n3 = h2(n3, r3, o3, i3, e4[u3 + 13], 4, 681279174), i3 = h2(i3, n3, r3, o3, e4[u3 + 0], 11, -358537222), o3 = h2(o3, i3, n3, r3, e4[u3 + 3], 16, -722521979), r3 = h2(r3, o3, i3, n3, e4[u3 + 6], 23, 76029189), n3 = h2(n3, r3, o3, i3, e4[u3 + 9], 4, -640364487), i3 = h2(i3, n3, r3, o3, e4[u3 + 12], 11, -421815835), o3 = h2(o3, i3, n3, r3, e4[u3 + 15], 16, 530742520), n3 = p2(n3, r3 = h2(r3, o3, i3, n3, e4[u3 + 2], 23, -995338651), o3, i3, e4[u3 + 0], 6, -198630844), i3 = p2(i3, n3, r3, o3, e4[u3 + 7], 10, 1126891415), o3 = p2(o3, i3, n3, r3, e4[u3 + 14], 15, -1416354905), r3 = p2(r3, o3, i3, n3, e4[u3 + 5], 21, -57434055), n3 = p2(n3, r3, o3, i3, e4[u3 + 12], 6, 1700485571), i3 = p2(i3, n3, r3, o3, e4[u3 + 3], 10, -1894986606), o3 = p2(o3, i3, n3, r3, e4[u3 + 10], 15, -1051523), r3 = p2(r3, o3, i3, n3, e4[u3 + 1], 21, -2054922799), n3 = p2(n3, r3, o3, i3, e4[u3 + 8], 6, 1873313359), i3 = p2(i3, n3, r3, o3, e4[u3 + 15], 10, -30611744), o3 = p2(o3, i3, n3, r3, e4[u3 + 6], 15, -1560198380), r3 = p2(r3, o3, i3, n3, e4[u3 + 13], 21, 1309151649), n3 = p2(n3, r3, o3, i3, e4[u3 + 4], 6, -145523070), i3 = p2(i3, n3, r3, o3, e4[u3 + 11], 10, -1120210379), o3 = p2(o3, i3, n3, r3, e4[u3 + 2], 15, 718787259), r3 = p2(r3, o3, i3, n3, e4[u3 + 9], 21, -343485551), n3 = g2(n3, s3), r3 = g2(r3, a3), o3 = g2(o3, f3), i3 = g2(i3, l3);
            }
            return Array(n3, r3, o3, i3);
          }
          function s2(e4, t3, n3, r3, o3, i3) {
            return g2((t3 = g2(g2(t3, e4), g2(r3, i3))) << o3 | t3 >>> 32 - o3, n3);
          }
          function c3(e4, t3, n3, r3, o3, i3, u3) {
            return s2(t3 & n3 | ~t3 & r3, e4, t3, o3, i3, u3);
          }
          function d2(e4, t3, n3, r3, o3, i3, u3) {
            return s2(t3 & r3 | n3 & ~r3, e4, t3, o3, i3, u3);
          }
          function h2(e4, t3, n3, r3, o3, i3, u3) {
            return s2(t3 ^ n3 ^ r3, e4, t3, o3, i3, u3);
          }
          function p2(e4, t3, n3, r3, o3, i3, u3) {
            return s2(n3 ^ (t3 | ~r3), e4, t3, o3, i3, u3);
          }
          function g2(e4, t3) {
            var n3 = (65535 & e4) + (65535 & t3);
            return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
          }
          b2.exports = function(e4) {
            return t2.hash(e4, n2, 16);
          };
        }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e2, l2, t2) {
        !(function(e3, t3, n2, r2, o2, i2, u2, s2, f2) {
          var a2;
          l2.exports = a2 || function(e4) {
            for (var t4, n3 = new Array(e4), r3 = 0; r3 < e4; r3++) 0 == (3 & r3) && (t4 = 4294967296 * Math.random()), n3[r3] = t4 >>> ((3 & r3) << 3) & 255;
            return n3;
          };
        }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 8: [function(c3, d2, e2) {
        !(function(e3, t2, n2, r2, o2, s2, a2, f2, l2) {
          var i2 = c3("./helpers");
          function u2(l3, c4) {
            l3[c4 >> 5] |= 128 << 24 - c4 % 32, l3[15 + (c4 + 64 >> 9 << 4)] = c4;
            for (var e4, t3, n3, r3 = Array(80), o3 = 1732584193, i3 = -271733879, u3 = -1732584194, s3 = 271733878, d3 = -1009589776, h2 = 0; h2 < l3.length; h2 += 16) {
              for (var p2 = o3, g2 = i3, y2 = u3, w2 = s3, b2 = d3, a3 = 0; a3 < 80; a3++) {
                r3[a3] = a3 < 16 ? l3[h2 + a3] : v2(r3[a3 - 3] ^ r3[a3 - 8] ^ r3[a3 - 14] ^ r3[a3 - 16], 1);
                var f3 = m2(m2(v2(o3, 5), (f3 = i3, t3 = u3, n3 = s3, (e4 = a3) < 20 ? f3 & t3 | ~f3 & n3 : !(e4 < 40) && e4 < 60 ? f3 & t3 | f3 & n3 | t3 & n3 : f3 ^ t3 ^ n3)), m2(m2(d3, r3[a3]), (e4 = a3) < 20 ? 1518500249 : e4 < 40 ? 1859775393 : e4 < 60 ? -1894007588 : -899497514)), d3 = s3, s3 = u3, u3 = v2(i3, 30), i3 = o3, o3 = f3;
              }
              o3 = m2(o3, p2), i3 = m2(i3, g2), u3 = m2(u3, y2), s3 = m2(s3, w2), d3 = m2(d3, b2);
            }
            return Array(o3, i3, u3, s3, d3);
          }
          function m2(e4, t3) {
            var n3 = (65535 & e4) + (65535 & t3);
            return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
          }
          function v2(e4, t3) {
            return e4 << t3 | e4 >>> 32 - t3;
          }
          d2.exports = function(e4) {
            return i2.hash(e4, u2, 20, true);
          };
        }).call(this, c3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(c3, d2, e2) {
        !(function(e3, t2, n2, r2, u2, s2, a2, f2, l2) {
          function b2(e4, t3) {
            var n3 = (65535 & e4) + (65535 & t3);
            return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
          }
          function o2(e4, l3) {
            var c4, d3 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), t3 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), n3 = new Array(64);
            e4[l3 >> 5] |= 128 << 24 - l3 % 32, e4[15 + (l3 + 64 >> 9 << 4)] = l3;
            for (var r3, o3, h2 = 0; h2 < e4.length; h2 += 16) {
              for (var i3 = t3[0], u3 = t3[1], s3 = t3[2], p2 = t3[3], a3 = t3[4], g2 = t3[5], y2 = t3[6], w2 = t3[7], f3 = 0; f3 < 64; f3++) n3[f3] = f3 < 16 ? e4[f3 + h2] : b2(b2(b2((o3 = n3[f3 - 2], m2(o3, 17) ^ m2(o3, 19) ^ v2(o3, 10)), n3[f3 - 7]), (o3 = n3[f3 - 15], m2(o3, 7) ^ m2(o3, 18) ^ v2(o3, 3))), n3[f3 - 16]), c4 = b2(b2(b2(b2(w2, m2(o3 = a3, 6) ^ m2(o3, 11) ^ m2(o3, 25)), a3 & g2 ^ ~a3 & y2), d3[f3]), n3[f3]), r3 = b2(m2(r3 = i3, 2) ^ m2(r3, 13) ^ m2(r3, 22), i3 & u3 ^ i3 & s3 ^ u3 & s3), w2 = y2, y2 = g2, g2 = a3, a3 = b2(p2, c4), p2 = s3, s3 = u3, u3 = i3, i3 = b2(c4, r3);
              t3[0] = b2(i3, t3[0]), t3[1] = b2(u3, t3[1]), t3[2] = b2(s3, t3[2]), t3[3] = b2(p2, t3[3]), t3[4] = b2(a3, t3[4]), t3[5] = b2(g2, t3[5]), t3[6] = b2(y2, t3[6]), t3[7] = b2(w2, t3[7]);
            }
            return t3;
          }
          var i2 = c3("./helpers"), m2 = function(e4, t3) {
            return e4 >>> t3 | e4 << 32 - t3;
          }, v2 = function(e4, t3) {
            return e4 >>> t3;
          };
          d2.exports = function(e4) {
            return i2.hash(e4, o2, 32, true);
          };
        }).call(this, c3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e2, t2, f2) {
        !(function(e3, t3, n2, r2, o2, i2, u2, s2, a2) {
          f2.read = function(e4, t4, n3, r3, o3) {
            var i3, u3, l2 = 8 * o3 - r3 - 1, c3 = (1 << l2) - 1, d2 = c3 >> 1, s3 = -7, a3 = n3 ? o3 - 1 : 0, f3 = n3 ? -1 : 1, o3 = e4[t4 + a3];
            for (a3 += f3, i3 = o3 & (1 << -s3) - 1, o3 >>= -s3, s3 += l2; 0 < s3; i3 = 256 * i3 + e4[t4 + a3], a3 += f3, s3 -= 8) ;
            for (u3 = i3 & (1 << -s3) - 1, i3 >>= -s3, s3 += r3; 0 < s3; u3 = 256 * u3 + e4[t4 + a3], a3 += f3, s3 -= 8) ;
            if (0 === i3) i3 = 1 - d2;
            else {
              if (i3 === c3) return u3 ? NaN : 1 / 0 * (o3 ? -1 : 1);
              u3 += Math.pow(2, r3), i3 -= d2;
            }
            return (o3 ? -1 : 1) * u3 * Math.pow(2, i3 - r3);
          }, f2.write = function(e4, t4, l2, n3, r3, c3) {
            var o3, i3, u3 = 8 * c3 - r3 - 1, s3 = (1 << u3) - 1, a3 = s3 >> 1, d2 = 23 === r3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f3 = n3 ? 0 : c3 - 1, h2 = n3 ? 1 : -1, c3 = t4 < 0 || 0 === t4 && 1 / t4 < 0 ? 1 : 0;
            for (t4 = Math.abs(t4), isNaN(t4) || t4 === 1 / 0 ? (i3 = isNaN(t4) ? 1 : 0, o3 = s3) : (o3 = Math.floor(Math.log(t4) / Math.LN2), t4 * (n3 = Math.pow(2, -o3)) < 1 && (o3--, n3 *= 2), 2 <= (t4 += 1 <= o3 + a3 ? d2 / n3 : d2 * Math.pow(2, 1 - a3)) * n3 && (o3++, n3 /= 2), s3 <= o3 + a3 ? (i3 = 0, o3 = s3) : 1 <= o3 + a3 ? (i3 = (t4 * n3 - 1) * Math.pow(2, r3), o3 += a3) : (i3 = t4 * Math.pow(2, a3 - 1) * Math.pow(2, r3), o3 = 0)); 8 <= r3; e4[l2 + f3] = 255 & i3, f3 += h2, i3 /= 256, r3 -= 8) ;
            for (o3 = o3 << r3 | i3, u3 += r3; 0 < u3; e4[l2 + f3] = 255 & o3, f3 += h2, o3 /= 256, u3 -= 8) ;
            e4[l2 + f3 - h2] |= 128 * c3;
          };
        }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
      }, { buffer: 3, lYpoI2: 11 }], 11: [function(e2, h2, t2) {
        !(function(e3, t3, n2, r2, o2, f2, l2, c3, d2) {
          var i2, u2, s2;
          function a2() {
          }
          (e3 = h2.exports = {}).nextTick = (u2 = "undefined" != typeof window && window.setImmediate, s2 = "undefined" != typeof window && window.postMessage && window.addEventListener, u2 ? function(e4) {
            return window.setImmediate(e4);
          } : s2 ? (i2 = [], window.addEventListener("message", function(e4) {
            var t4 = e4.source;
            t4 !== window && null !== t4 || "process-tick" !== e4.data || (e4.stopPropagation(), 0 < i2.length && i2.shift()());
          }, true), function(e4) {
            i2.push(e4), window.postMessage("process-tick", "*");
          }) : function(e4) {
            setTimeout(e4, 0);
          }), e3.title = "browser", e3.browser = true, e3.env = {}, e3.argv = [], e3.on = a2, e3.addListener = a2, e3.once = a2, e3.off = a2, e3.removeListener = a2, e3.removeAllListeners = a2, e3.emit = a2, e3.binding = function(e4) {
            throw new Error("process.binding is not supported");
          }, e3.cwd = function() {
            return "/";
          }, e3.chdir = function(e4) {
            throw new Error("process.chdir is not supported");
          };
        }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
    });
  }
});

// node_modules/@puckeditor/core/dist/chunk-TNORMHZU.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
init_react_import();
var migrations = [
  // Migrate root to root.props
  (data) => {
    const rootProps = data.root.props || data.root;
    if (Object.keys(data.root).length > 0 && !data.root.props) {
      console.warn(
        "Migration applied: Root props moved from `root` to `root.props`."
      );
      return __spreadProps(__spreadValues({}, data), {
        root: {
          props: __spreadValues({}, rootProps)
        }
      });
    }
    return data;
  },
  // Migrate zones to slots
  (data, config, migrationOptions) => {
    var _a5, _b3;
    if (!config) return data;
    console.log("Migrating DropZones to slots...");
    const updatedItems = {};
    const appState = __spreadProps(__spreadValues({}, defaultAppState), { data });
    const { indexes } = walkAppState(appState, config);
    const deletedCompounds = [];
    walkAppState(appState, config, (content, zoneCompound, zoneType) => {
      var _a23, _b22, _c4;
      if (zoneType === "dropzone") {
        const [id, slotName] = zoneCompound.split(":");
        const nodeData = indexes.nodes[id].data;
        const componentType = nodeData.type;
        const configForComponent = id === "root" ? config.root : config.components[componentType];
        if (((_b22 = (_a23 = configForComponent == null ? void 0 : configForComponent.fields) == null ? void 0 : _a23[slotName]) == null ? void 0 : _b22.type) === "slot") {
          updatedItems[id] = __spreadProps(__spreadValues({}, nodeData), {
            props: __spreadProps(__spreadValues(__spreadValues({}, nodeData.props), (_c4 = updatedItems[id]) == null ? void 0 : _c4.props), {
              [slotName]: content
            })
          });
          deletedCompounds.push(zoneCompound);
        }
        return content;
      }
      return content;
    });
    const updated = walkAppState(
      appState,
      config,
      (content) => content,
      (item) => {
        var _a23;
        return (_a23 = updatedItems[item.props.id]) != null ? _a23 : item;
      }
    );
    deletedCompounds.forEach((zoneCompound) => {
      var _a23;
      const [_2, propName] = zoneCompound.split(":");
      console.log(
        ` Success: Migrated "${zoneCompound}" from DropZone to slot field "${propName}"`
      );
      (_a23 = updated.data.zones) == null ? true : delete _a23[zoneCompound];
    });
    if (migrationOptions == null ? void 0 : migrationOptions.migrateDynamicZonesForComponent) {
      const unmigratedZonesGrouped = {};
      Object.keys((_a5 = updated.data.zones) != null ? _a5 : {}).forEach((zoneCompound) => {
        var _a23;
        const [componentId, propName] = zoneCompound.split(":");
        const content = (_a23 = updated.data.zones) == null ? void 0 : _a23[zoneCompound];
        if (!content) {
          return;
        }
        if (!unmigratedZonesGrouped[componentId]) {
          unmigratedZonesGrouped[componentId] = {};
        }
        if (!unmigratedZonesGrouped[componentId][propName]) {
          unmigratedZonesGrouped[componentId][propName] = content;
        }
      });
      Object.keys(unmigratedZonesGrouped).forEach((componentId) => {
        updated.data = walkTree(updated.data, config, (content) => {
          return content.map((child) => {
            var _a23;
            if (child.props.id !== componentId) {
              return child;
            }
            const migrateFn = (_a23 = migrationOptions == null ? void 0 : migrationOptions.migrateDynamicZonesForComponent) == null ? void 0 : _a23[child.type];
            if (!migrateFn) {
              return child;
            }
            const zones = unmigratedZonesGrouped[componentId];
            const migratedProps = migrateFn(child.props, zones);
            Object.keys(zones).forEach((propName) => {
              var _a33;
              const zoneCompound = `${componentId}:${propName}`;
              console.log(` Success: Migrated "${zoneCompound}" DropZone`);
              (_a33 = updated.data.zones) == null ? true : delete _a33[zoneCompound];
            });
            return __spreadProps(__spreadValues({}, child), {
              props: migratedProps
            });
          });
        });
      });
    }
    Object.keys((_b3 = updated.data.zones) != null ? _b3 : {}).forEach((zoneCompound) => {
      const [_2, propName] = zoneCompound.split(":");
      throw new Error(
        `Could not migrate DropZone "${zoneCompound}" to slot field. No slot exists with the name "${propName}".`
      );
    });
    delete updated.data.zones;
    return updated.data;
  }
];
function migrate(data, config, migrationOptions) {
  return migrations == null ? void 0 : migrations.reduce(
    (acc, migration) => migration(acc, config, migrationOptions),
    data
  );
}
init_react_import();
init_react_import();
var defaultData = (data) => __spreadProps(__spreadValues({}, data), {
  root: data.root || {},
  content: data.content || []
});
function transformProps(data, propTransforms, config = { components: {} }) {
  const mapItem = (item) => {
    if (propTransforms[item.type]) {
      return __spreadProps(__spreadValues({}, item), {
        props: __spreadValues({
          id: item.props.id
        }, propTransforms[item.type](item.props))
      });
    }
    return item;
  };
  const defaultedData = defaultData(data);
  const rootProps = defaultedData.root.props || defaultedData.root;
  let newRoot = __spreadValues({}, defaultedData.root);
  if (propTransforms["root"]) {
    newRoot.props = propTransforms["root"](rootProps);
  }
  const dataWithUpdatedRoot = __spreadProps(__spreadValues({}, defaultedData), { root: newRoot });
  const updatedData = walkTree(
    dataWithUpdatedRoot,
    config,
    (content) => content.map(mapItem)
  );
  if (!defaultedData.root.props) {
    updatedData.root = updatedData.root.props;
  }
  return updatedData;
}
init_react_import();
init_react_import();
var groupZonesByComponent = (data) => {
  var _a5;
  const zoneEntries = Object.entries((_a5 = data.zones) != null ? _a5 : {});
  return zoneEntries.reduce((acc, [zoneCompound, zoneContent]) => {
    const [componentId, zoneName] = getZoneId(zoneCompound);
    if (!componentId.length || !zoneName.length) return acc;
    if (!acc[componentId]) {
      acc[componentId] = [];
    }
    acc[componentId].push({ zoneCompound, content: zoneContent });
    return acc;
  }, {});
};
function resolveAllData(_0, _1) {
  return __async(this, arguments, function* (data, config, metadata = {}, onResolveStart, onResolveEnd) {
    const defaultedData = defaultData(data);
    const zonesByComponent = groupZonesByComponent(defaultedData);
    let resolvedZones = {};
    const resolveNode = (_node, parent) => __async(null, null, function* () {
      const node = toComponent(_node);
      onResolveStart == null ? void 0 : onResolveStart(node);
      const resolved = (yield resolveComponentData(
        node,
        config,
        metadata,
        () => {
        },
        () => {
        },
        "force",
        parent
      )).node;
      const resolvedAsComponent = toComponent(resolved);
      const resolvedDeepPromise = mapFields(
        resolved,
        {
          slot: ({ value }) => processContent(value, resolvedAsComponent)
        },
        config
      );
      let resolveZonePromises = [];
      if (zonesByComponent[resolvedAsComponent.props.id]) {
        resolveZonePromises = zonesByComponent[resolvedAsComponent.props.id].map(
          (_02) => __async(null, [_02], function* ({ zoneCompound, content }) {
            resolvedZones[zoneCompound] = yield processContent(
              content,
              resolvedAsComponent
            );
          })
        );
      }
      const resolvedDeep = yield resolvedDeepPromise;
      yield Promise.all(resolveZonePromises);
      onResolveEnd == null ? void 0 : onResolveEnd(toComponent(resolvedDeep));
      return resolvedDeep;
    });
    const processContent = (content, parent) => __async(null, null, function* () {
      return Promise.all(content.map((item) => resolveNode(item, parent)));
    });
    const result = defaultData({});
    result.root = yield resolveNode(defaultedData.root, null);
    result.content = yield processContent(
      defaultedData.content,
      toComponent(result.root)
    );
    result.zones = resolvedZones;
    return result;
  });
}
init_react_import();
var getSlotTransform = (renderSlotEdit, renderSlotRender = renderSlotEdit) => ({
  slot: ({ value: content, propName, field, isReadOnly }) => {
    const render = isReadOnly ? renderSlotRender : renderSlotEdit;
    const Slot = (dzProps) => render(__spreadProps(__spreadValues({
      allow: (field == null ? void 0 : field.type) === "slot" ? field.allow : [],
      disallow: (field == null ? void 0 : field.type) === "slot" ? field.disallow : []
    }, dzProps), {
      zone: propName,
      content
    }));
    return Slot;
  }
});
init_react_import();
init_react_import();
init_react_import();
function buildMappers(transforms, readOnly, forceReadOnly) {
  return Object.keys(transforms).reduce((acc, _fieldType) => {
    const fieldType = _fieldType;
    return __spreadProps(__spreadValues({}, acc), {
      [fieldType]: (_a5) => {
        var _b3 = _a5, {
          parentId
        } = _b3, params = __objRest(_b3, [
          "parentId"
        ]);
        const wildcardPath = params.propPath.replace(/\[\d+\]/g, "[*]");
        const isReadOnly = (readOnly == null ? void 0 : readOnly[params.propPath]) || (readOnly == null ? void 0 : readOnly[wildcardPath]) || forceReadOnly || false;
        const fn = transforms[fieldType];
        return fn == null ? void 0 : fn(__spreadProps(__spreadValues({}, params), {
          isReadOnly,
          componentId: parentId
        }));
      }
    });
  }, {});
}
function useFieldTransforms(config, item, transforms, readOnly, forceReadOnly) {
  const mappers = (0, import_react.useMemo)(
    () => buildMappers(transforms, readOnly, forceReadOnly),
    [transforms, readOnly, forceReadOnly]
  );
  const transformedProps = (0, import_react.useMemo)(() => {
    return mapFields(item, mappers, config).props;
  }, [config, item, mappers]);
  const mergedProps = (0, import_react.useMemo)(
    () => __spreadValues(__spreadValues({}, item.props), transformedProps),
    [item.props, transformedProps]
  );
  return mergedProps;
}
function useSlots(config, item, renderSlotEdit, renderSlotRender = renderSlotEdit, readOnly, forceReadOnly) {
  return useFieldTransforms(
    config,
    item,
    getSlotTransform(renderSlotEdit, renderSlotRender),
    readOnly,
    forceReadOnly
  );
}
init_react_import();
init_react_import();
var getClassName = get_class_name_factory_default("RichTextEditor", styles_module_default);
function RichTextRenderFallback({ content }) {
  return (0, import_jsx_runtime.jsx)("div", { className: getClassName(), children: (0, import_jsx_runtime.jsx)(
    "div",
    {
      className: "rich-text",
      dangerouslySetInnerHTML: { __html: content }
    }
  ) });
}
init_react_import();
var mapDeep = (source, path, render) => {
  if (!source) {
    return null;
  }
  if (path.length === 0) {
    return render(source);
  }
  const [key, ...rest] = path;
  if (Array.isArray(source)) {
    return source.map((item) => mapDeep(item, path, render));
  }
  return __spreadProps(__spreadValues({}, source), {
    [key]: mapDeep(source[key], rest, render)
  });
};
function useRichtextProps(fields, props) {
  const findAllRichtextKeys = (fields2, path = []) => {
    if (!fields2) return [];
    const result = [];
    for (const [key, field] of Object.entries(fields2)) {
      const currentPath = [...path, key];
      if (field.type === "richtext") {
        result.push({
          path: currentPath,
          field
        });
      }
      if (field.type === "array" && "arrayFields" in field) {
        result.push(...findAllRichtextKeys(field.arrayFields, currentPath));
      }
      if (field.type === "object" && "objectFields" in field) {
        result.push(...findAllRichtextKeys(field.objectFields, currentPath));
      }
    }
    return result;
  };
  const richtextKeys = (0, import_react2.useMemo)(() => findAllRichtextKeys(fields), [fields]);
  const richtextProps = (0, import_react2.useMemo)(() => {
    if (!(richtextKeys == null ? void 0 : richtextKeys.length)) return {};
    const RichTextRender2 = (0, import_react2.lazy)(
      () => import("./Render-CU35UAWV-NF7YNHHV.js").then((m2) => ({
        default: m2.RichTextRender
      }))
    );
    let result = __spreadValues({}, props);
    for (const { path, field } of richtextKeys) {
      result = mapDeep(result, path, (content) => (0, import_jsx_runtime2.jsx)(
        import_react2.Suspense,
        {
          fallback: (0, import_jsx_runtime2.jsx)(RichTextRenderFallback, { content }),
          children: (0, import_jsx_runtime2.jsx)(RichTextRender2, { content, field })
        },
        generateId()
      ));
    }
    return result;
  }, [richtextKeys, props, fields]);
  return richtextProps;
}
init_react_import();
var SlotRenderPure = (props) => (0, import_jsx_runtime3.jsx)(SlotRender, __spreadValues({}, props));
var Item = ({
  config,
  item,
  metadata
}) => {
  const Component = config.components[item.type];
  const props = useSlots(config, item, (slotProps) => (0, import_jsx_runtime3.jsx)(SlotRenderPure, __spreadProps(__spreadValues({}, slotProps), { config, metadata })));
  const richtextProps = useRichtextProps(Component.fields, props);
  return (0, import_jsx_runtime3.jsx)(
    Component.render,
    __spreadProps(__spreadValues(__spreadValues({}, props), richtextProps), {
      puck: __spreadProps(__spreadValues({}, props.puck), {
        metadata: metadata || {}
      })
    })
  );
};
var SlotRender = (0, import_react3.forwardRef)(
  function SlotRenderInternal({ className, style, content, config, metadata, as }, ref) {
    const El = as != null ? as : "div";
    return (0, import_jsx_runtime3.jsx)(El, { className, style, ref, children: content.map((item) => {
      if (!config.components[item.type]) {
        return null;
      }
      return (0, import_jsx_runtime3.jsx)(
        Item,
        {
          config,
          item,
          metadata
        },
        item.props.id
      );
    }) });
  }
);

// node_modules/@puckeditor/core/dist/chunk-EBISZQTK.mjs
var import_react9 = __toESM(require_react(), 1);
var import_react10 = __toESM(require_react(), 1);

// node_modules/zustand/esm/react/shallow.mjs
var import_react4 = __toESM(require_react(), 1);

// node_modules/zustand/esm/vanilla/shallow.mjs
var isIterable = (obj) => Symbol.iterator in obj;
var hasIterableEntries = (value) => (
  // HACK: avoid checking entries type
  "entries" in value
);
var compareEntries = (valueA, valueB) => {
  const mapA = valueA instanceof Map ? valueA : new Map(valueA.entries());
  const mapB = valueB instanceof Map ? valueB : new Map(valueB.entries());
  if (mapA.size !== mapB.size) {
    return false;
  }
  for (const [key, value] of mapA) {
    if (!mapB.has(key) || !Object.is(value, mapB.get(key))) {
      return false;
    }
  }
  return true;
};
var compareIterables = (valueA, valueB) => {
  const iteratorA = valueA[Symbol.iterator]();
  const iteratorB = valueB[Symbol.iterator]();
  let nextA = iteratorA.next();
  let nextB = iteratorB.next();
  while (!nextA.done && !nextB.done) {
    if (!Object.is(nextA.value, nextB.value)) {
      return false;
    }
    nextA = iteratorA.next();
    nextB = iteratorB.next();
  }
  return !!nextA.done && !!nextB.done;
};
function shallow(valueA, valueB) {
  if (Object.is(valueA, valueB)) {
    return true;
  }
  if (typeof valueA !== "object" || valueA === null || typeof valueB !== "object" || valueB === null) {
    return false;
  }
  if (Object.getPrototypeOf(valueA) !== Object.getPrototypeOf(valueB)) {
    return false;
  }
  if (isIterable(valueA) && isIterable(valueB)) {
    if (hasIterableEntries(valueA) && hasIterableEntries(valueB)) {
      return compareEntries(valueA, valueB);
    }
    return compareIterables(valueA, valueB);
  }
  return compareEntries(
    { entries: () => Object.entries(valueA) },
    { entries: () => Object.entries(valueB) }
  );
}

// node_modules/zustand/esm/react/shallow.mjs
function useShallow(selector) {
  const prev = import_react4.default.useRef(void 0);
  return (state) => {
    const next = selector(state);
    return shallow(prev.current, next) ? prev.current : prev.current = next;
  };
}

// node_modules/@puckeditor/core/dist/chunk-EBISZQTK.mjs
var import_react11 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);

// node_modules/@puckeditor/core/node_modules/@dnd-kit/react/index.js
var import_react6 = __toESM(require_react());

// node_modules/@preact/signals-core/dist/signals-core.module.js
var i = Symbol.for("preact-signals");
function t() {
  if (!(s > 1)) {
    var i2, t2 = false;
    while (void 0 !== h) {
      var n2 = h;
      h = void 0;
      v++;
      while (void 0 !== n2) {
        var r2 = n2.o;
        n2.o = void 0;
        n2.f &= -3;
        if (!(8 & n2.f) && a(n2)) try {
          n2.c();
        } catch (n3) {
          if (!t2) {
            i2 = n3;
            t2 = true;
          }
        }
        n2 = r2;
      }
    }
    v = 0;
    s--;
    if (t2) throw i2;
  } else s--;
}
function n(i2) {
  if (s > 0) return i2();
  s++;
  try {
    return i2();
  } finally {
    t();
  }
}
var r = void 0;
function o(i2) {
  var t2 = r;
  r = void 0;
  try {
    return i2();
  } finally {
    r = t2;
  }
}
var f;
var h = void 0;
var s = 0;
var v = 0;
var u = 0;
function e(i2) {
  if (void 0 !== r) {
    var t2 = i2.n;
    if (void 0 === t2 || t2.t !== r) {
      t2 = { i: 0, S: i2, p: r.s, n: void 0, t: r, e: void 0, x: void 0, r: t2 };
      if (void 0 !== r.s) r.s.n = t2;
      r.s = t2;
      i2.n = t2;
      if (32 & r.f) i2.S(t2);
      return t2;
    } else if (-1 === t2.i) {
      t2.i = 0;
      if (void 0 !== t2.n) {
        t2.n.p = t2.p;
        if (void 0 !== t2.p) t2.p.n = t2.n;
        t2.p = r.s;
        t2.n = void 0;
        r.s.n = t2;
        r.s = t2;
      }
      return t2;
    }
  }
}
function d(i2, t2) {
  this.v = i2;
  this.i = 0;
  this.n = void 0;
  this.t = void 0;
  this.W = null == t2 ? void 0 : t2.watched;
  this.Z = null == t2 ? void 0 : t2.unwatched;
  this.name = null == t2 ? void 0 : t2.name;
}
d.prototype.brand = i;
d.prototype.h = function() {
  return true;
};
d.prototype.S = function(i2) {
  var t2 = this, n2 = this.t;
  if (n2 !== i2 && void 0 === i2.e) {
    i2.x = n2;
    this.t = i2;
    if (void 0 !== n2) n2.e = i2;
    else o(function() {
      var i3;
      null == (i3 = t2.W) || i3.call(t2);
    });
  }
};
d.prototype.U = function(i2) {
  var t2 = this;
  if (void 0 !== this.t) {
    var n2 = i2.e, r2 = i2.x;
    if (void 0 !== n2) {
      n2.x = r2;
      i2.e = void 0;
    }
    if (void 0 !== r2) {
      r2.e = n2;
      i2.x = void 0;
    }
    if (i2 === this.t) {
      this.t = r2;
      if (void 0 === r2) o(function() {
        var i3;
        null == (i3 = t2.Z) || i3.call(t2);
      });
    }
  }
};
d.prototype.subscribe = function(i2) {
  var t2 = this;
  return m(function() {
    var n2 = t2.value, o2 = r;
    r = void 0;
    try {
      i2(n2);
    } finally {
      r = o2;
    }
  }, { name: "sub" });
};
d.prototype.valueOf = function() {
  return this.value;
};
d.prototype.toString = function() {
  return this.value + "";
};
d.prototype.toJSON = function() {
  return this.value;
};
d.prototype.peek = function() {
  var i2 = r;
  r = void 0;
  try {
    return this.value;
  } finally {
    r = i2;
  }
};
Object.defineProperty(d.prototype, "value", { get: function() {
  var i2 = e(this);
  if (void 0 !== i2) i2.i = this.i;
  return this.v;
}, set: function(i2) {
  if (i2 !== this.v) {
    if (v > 100) throw new Error("Cycle detected");
    this.v = i2;
    this.i++;
    u++;
    s++;
    try {
      for (var n2 = this.t; void 0 !== n2; n2 = n2.x) n2.t.N();
    } finally {
      t();
    }
  }
} });
function c2(i2, t2) {
  return new d(i2, t2);
}
function a(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) if (t2.S.i !== t2.i || !t2.S.h() || t2.S.i !== t2.i) return true;
  return false;
}
function l(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) {
    var n2 = t2.S.n;
    if (void 0 !== n2) t2.r = n2;
    t2.S.n = t2;
    t2.i = -1;
    if (void 0 === t2.n) {
      i2.s = t2;
      break;
    }
  }
}
function y(i2) {
  var t2 = i2.s, n2 = void 0;
  while (void 0 !== t2) {
    var r2 = t2.p;
    if (-1 === t2.i) {
      t2.S.U(t2);
      if (void 0 !== r2) r2.n = t2.n;
      if (void 0 !== t2.n) t2.n.p = r2;
    } else n2 = t2;
    t2.S.n = t2.r;
    if (void 0 !== t2.r) t2.r = void 0;
    t2 = r2;
  }
  i2.s = n2;
}
function w(i2, t2) {
  d.call(this, void 0);
  this.x = i2;
  this.s = void 0;
  this.g = u - 1;
  this.f = 4;
  this.W = null == t2 ? void 0 : t2.watched;
  this.Z = null == t2 ? void 0 : t2.unwatched;
  this.name = null == t2 ? void 0 : t2.name;
}
w.prototype = new d();
w.prototype.h = function() {
  this.f &= -3;
  if (1 & this.f) return false;
  if (32 == (36 & this.f)) return true;
  this.f &= -5;
  if (this.g === u) return true;
  this.g = u;
  this.f |= 1;
  if (this.i > 0 && !a(this)) {
    this.f &= -2;
    return true;
  }
  var i2 = r;
  try {
    l(this);
    r = this;
    var t2 = this.x();
    if (16 & this.f || this.v !== t2 || 0 === this.i) {
      this.v = t2;
      this.f &= -17;
      this.i++;
    }
  } catch (i3) {
    this.v = i3;
    this.f |= 16;
    this.i++;
  }
  r = i2;
  y(this);
  this.f &= -2;
  return true;
};
w.prototype.S = function(i2) {
  if (void 0 === this.t) {
    this.f |= 36;
    for (var t2 = this.s; void 0 !== t2; t2 = t2.n) t2.S.S(t2);
  }
  d.prototype.S.call(this, i2);
};
w.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    d.prototype.U.call(this, i2);
    if (void 0 === this.t) {
      this.f &= -33;
      for (var t2 = this.s; void 0 !== t2; t2 = t2.n) t2.S.U(t2);
    }
  }
};
w.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var i2 = this.t; void 0 !== i2; i2 = i2.x) i2.t.N();
  }
};
Object.defineProperty(w.prototype, "value", { get: function() {
  if (1 & this.f) throw new Error("Cycle detected");
  var i2 = e(this);
  this.h();
  if (void 0 !== i2) i2.i = this.i;
  if (16 & this.f) throw this.v;
  return this.v;
} });
function b(i2, t2) {
  return new w(i2, t2);
}
function _(i2) {
  var n2 = i2.u;
  i2.u = void 0;
  if ("function" == typeof n2) {
    s++;
    var o2 = r;
    r = void 0;
    try {
      n2();
    } catch (t2) {
      i2.f &= -2;
      i2.f |= 8;
      p(i2);
      throw t2;
    } finally {
      r = o2;
      t();
    }
  }
}
function p(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) t2.S.U(t2);
  i2.x = void 0;
  i2.s = void 0;
  _(i2);
}
function g(i2) {
  if (r !== this) throw new Error("Out-of-order effect");
  y(this);
  r = i2;
  this.f &= -2;
  if (8 & this.f) p(this);
  t();
}
function S(i2, t2) {
  this.x = i2;
  this.u = void 0;
  this.s = void 0;
  this.o = void 0;
  this.f = 32;
  this.name = null == t2 ? void 0 : t2.name;
  if (f) f.push(this);
}
S.prototype.c = function() {
  var i2 = this.S();
  try {
    if (8 & this.f) return;
    if (void 0 === this.x) return;
    var t2 = this.x();
    if ("function" == typeof t2) this.u = t2;
  } finally {
    i2();
  }
};
S.prototype.S = function() {
  if (1 & this.f) throw new Error("Cycle detected");
  this.f |= 1;
  this.f &= -9;
  _(this);
  l(this);
  s++;
  var i2 = r;
  r = this;
  return g.bind(this, i2);
};
S.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 2;
    this.o = h;
    h = this;
  }
};
S.prototype.d = function() {
  this.f |= 8;
  if (!(1 & this.f)) p(this);
};
S.prototype.dispose = function() {
  this.d();
};
function m(i2, t2) {
  var n2 = new S(i2, t2);
  try {
    n2.c();
  } catch (i3) {
    n2.d();
    throw i3;
  }
  var r2 = n2.d.bind(n2);
  r2[Symbol.dispose] = r2;
  return r2;
}

// node_modules/@dnd-kit/state/dist/index.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps2 = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => {
  var _a23;
  return [, , , __create((_a23 = base == null ? void 0 : base[__knownSymbol("metadata")]) != null ? _a23 : null)];
};
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n2 = fns && fns.length; i2 < n2; i2++) flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p2 = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s2 ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p2 && !s2 && (target = target.prototype), k < 5 && (k > 3 || !p2) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p2 && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: p2 ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p2 ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p2 ? (x, y2) => __privateSet(x, target, y2, k ^ 4 ? extra : desc.set) : (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p2 ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p2 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p2 ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
function computed(compute, comparator) {
  if (comparator) {
    let previousValue;
    return b(() => {
      const value = compute();
      if (value && previousValue && comparator(previousValue, value)) {
        return previousValue;
      }
      previousValue = value;
      return value;
    });
  }
  return b(compute);
}
function deepEqual2(a2, b2) {
  if (Object.is(a2, b2)) {
    return true;
  }
  if (a2 === null || b2 === null) return false;
  if (typeof a2 === "function" && typeof b2 === "function") {
    return a2 === b2;
  }
  if (a2 instanceof Set && b2 instanceof Set) {
    if (a2.size !== b2.size) {
      return false;
    }
    for (const value of a2) {
      if (!b2.has(value)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(a2)) {
    if (!Array.isArray(b2) || a2.length !== b2.length) {
      return false;
    }
    const hasDifferentValues = a2.some(
      (value, index) => !deepEqual2(value, b2[index])
    );
    return !hasDifferentValues;
  }
  if (typeof a2 === "object" && typeof b2 === "object") {
    const aKeys = Object.keys(a2);
    const bKeys = Object.keys(b2);
    if (aKeys.length !== bKeys.length) return false;
    const hasDifferentValues = aKeys.some(
      (key) => !deepEqual2(a2[key], b2[key])
    );
    return !hasDifferentValues;
  }
  return false;
}
function reactive({ get }, _2) {
  return {
    init(value) {
      return c2(value);
    },
    get() {
      const current = get.call(this);
      return current.value;
    },
    set(newValue) {
      const current = get.call(this);
      if (current.peek() === newValue) {
        return;
      }
      current.value = newValue;
    }
  };
}
function derived(target, _2) {
  const map = /* @__PURE__ */ new WeakMap();
  return function() {
    let result = map.get(this);
    if (!result) {
      result = computed(target.bind(this));
      map.set(this, result);
    }
    return result.value;
  };
}
function enumerable(enumerable2 = true) {
  return function(_value2, context) {
    context.addInitializer(function() {
      const host = context.kind === "field" ? this : context.static ? this : Object.getPrototypeOf(this);
      const descriptor2 = Object.getOwnPropertyDescriptor(host, context.name);
      if (descriptor2) {
        Object.defineProperty(host, context.name, __spreadProps2(__spreadValues2({}, descriptor2), { enumerable: enumerable2 }));
      }
    });
  };
}
function effects(...entries) {
  const effects2 = entries.map(m);
  return () => effects2.forEach((cleanup) => cleanup());
}
var _previous_dec;
var _initial_dec;
var _current_dec;
var _current_dec2;
var _previous_dec2;
var _initial_dec2;
var _init;
var _initial;
var _a;
var initial_get;
var initial_set;
var _ValueHistory_instances;
var _previous;
var _b;
var previous_get;
var previous_set;
var _current;
var _c;
var current_get;
var current_set;
_initial_dec2 = [reactive], _previous_dec2 = [reactive], _current_dec2 = [reactive], _current_dec = [enumerable()], _initial_dec = [enumerable()], _previous_dec = [enumerable()];
var ValueHistory = class {
  constructor(defaultValue, equals = Object.is) {
    this.defaultValue = defaultValue;
    this.equals = equals;
    __runInitializers(_init, 5, this);
    __privateAdd(this, _ValueHistory_instances);
    __privateAdd(this, _initial, __runInitializers(_init, 8, this)), __runInitializers(_init, 11, this);
    __privateAdd(this, _previous, __runInitializers(_init, 12, this)), __runInitializers(_init, 15, this);
    __privateAdd(this, _current, __runInitializers(_init, 16, this)), __runInitializers(_init, 19, this);
    this.reset = this.reset.bind(this);
    this.reset();
  }
  get current() {
    return __privateGet(this, _ValueHistory_instances, current_get);
  }
  get initial() {
    return __privateGet(this, _ValueHistory_instances, initial_get);
  }
  get previous() {
    return __privateGet(this, _ValueHistory_instances, previous_get);
  }
  /** Set the current value */
  set current(value) {
    const current = o(() => __privateGet(this, _ValueHistory_instances, current_get));
    if (value && current && this.equals(current, value)) {
      return;
    }
    n(() => {
      if (!__privateGet(this, _ValueHistory_instances, initial_get)) {
        __privateSet(this, _ValueHistory_instances, value, initial_set);
      }
      __privateSet(this, _ValueHistory_instances, current, previous_set);
      __privateSet(this, _ValueHistory_instances, value, current_set);
    });
  }
  /** Reset the state to the initial value */
  reset(value = this.defaultValue) {
    n(() => {
      __privateSet(this, _ValueHistory_instances, void 0, previous_set);
      __privateSet(this, _ValueHistory_instances, value, initial_set);
      __privateSet(this, _ValueHistory_instances, value, current_set);
    });
  }
};
_init = __decoratorStart(null);
_initial = /* @__PURE__ */ new WeakMap();
_ValueHistory_instances = /* @__PURE__ */ new WeakSet();
_previous = /* @__PURE__ */ new WeakMap();
_current = /* @__PURE__ */ new WeakMap();
_a = __decorateElement(_init, 20, "#initial", _initial_dec2, _ValueHistory_instances, _initial), initial_get = _a.get, initial_set = _a.set;
_b = __decorateElement(_init, 20, "#previous", _previous_dec2, _ValueHistory_instances, _previous), previous_get = _b.get, previous_set = _b.set;
_c = __decorateElement(_init, 20, "#current", _current_dec2, _ValueHistory_instances, _current), current_get = _c.get, current_set = _c.set;
__decorateElement(_init, 2, "current", _current_dec, ValueHistory);
__decorateElement(_init, 2, "initial", _initial_dec, ValueHistory);
__decorateElement(_init, 2, "previous", _previous_dec, ValueHistory);
__decoratorMetadata(_init, ValueHistory);
function snapshot(value) {
  return o(() => {
    const output = {};
    for (const key in value) {
      output[key] = value[key];
    }
    return output;
  });
}
var _store;
var WeakStore = class {
  constructor() {
    __privateAdd(this, _store, /* @__PURE__ */ new WeakMap());
  }
  get(key, id) {
    var _a23;
    return key ? (_a23 = __privateGet(this, _store).get(key)) == null ? void 0 : _a23.get(id) : void 0;
  }
  set(key, id, value) {
    var _a23;
    if (!key) return;
    if (!__privateGet(this, _store).has(key)) __privateGet(this, _store).set(key, /* @__PURE__ */ new Map());
    return (_a23 = __privateGet(this, _store).get(key)) == null ? void 0 : _a23.set(id, value);
  }
  clear(key) {
    var _a23;
    return key ? (_a23 = __privateGet(this, _store).get(key)) == null ? void 0 : _a23.clear() : void 0;
  }
};
_store = /* @__PURE__ */ new WeakMap();

// node_modules/@dnd-kit/geometry/dist/index.mjs
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __knownSymbol2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __pow = Math.pow;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __name2 = (target, value) => __defProp2(target, "name", { value, configurable: true });
var __decoratorStart2 = (base) => {
  var _a23;
  return [, , , __create2((_a23 = base == null ? void 0 : base[__knownSymbol2("metadata")]) != null ? _a23 : null)];
};
var __decoratorStrings2 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn2 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError2("Function expected") : fn;
var __decoratorContext2 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings2[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError2("Already initialized") : fns.push(__expectFn2(fn || null)) });
var __decoratorMetadata2 = (array, target) => __defNormalProp2(target, __knownSymbol2("metadata"), array[3]);
var __runInitializers2 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n2 = fns && fns.length; i2 < n2; i2++) flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement2 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p2 = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s2 ? 1 : 2 : 0, key = __decoratorStrings2[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p2 && !s2 && (target = target.prototype), k < 5 && (k > 3 || !p2) && __getOwnPropDesc2(k < 4 ? target : { get [name]() {
    return __privateGet2(this, extra);
  }, set [name](x) {
    return __privateSet2(this, extra, x);
  } }, name));
  k ? p2 && k < 4 && __name2(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name2(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext2(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: p2 ? (x) => __privateIn2(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p2 ? (x) => (k ^ 1 ? __privateGet2 : __privateMethod2)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p2 ? (x, y2) => __privateSet2(x, target, y2, k ^ 4 ? extra : desc.set) : (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p2 ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn2(it) && (k > 4 ? initializers.unshift(it) : k ? p2 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError2("Object expected");
    else __expectFn2(fn = it.get) && (desc.get = fn), __expectFn2(fn = it.set) && (desc.set = fn), __expectFn2(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata2(array, target), desc && __defProp2(target, name, desc), p2 ? k ^ 4 ? extra : desc : target;
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateIn2 = (member, obj) => Object(obj) !== obj ? __typeError2('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var Point = class _Point {
  /**
   * @param {number} Coordinate of the point on the horizontal axis
   * @param {number} Coordinate of the point on the vertical axis
   */
  constructor(x, y2) {
    this.x = x;
    this.y = y2;
  }
  /**
   * Returns the delta between this point and another point.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static delta(a2, b2) {
    return new _Point(a2.x - b2.x, a2.y - b2.y);
  }
  /**
   * Returns the distance (hypotenuse) between this point and another point.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static distance(a2, b2) {
    return Math.hypot(a2.x - b2.x, a2.y - b2.y);
  }
  /**
   * Returns true if both points are equal.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static equals(a2, b2) {
    return a2.x === b2.x && a2.y === b2.y;
  }
  static from({ x, y: y2 }) {
    return new _Point(x, y2);
  }
};
var Rectangle = class _Rectangle {
  constructor(left, top, width, height) {
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
    this.scale = {
      x: 1,
      y: 1
    };
  }
  get inverseScale() {
    return {
      x: 1 / this.scale.x,
      y: 1 / this.scale.y
    };
  }
  translate(x, y2) {
    const { top, left, width, height, scale } = this;
    const newShape = new _Rectangle(left + x, top + y2, width, height);
    newShape.scale = __spreadValues3({}, scale);
    return newShape;
  }
  get boundingRectangle() {
    const { width, height, left, top, right, bottom } = this;
    return { width, height, left, top, right, bottom };
  }
  get center() {
    const { left, top, right, bottom } = this;
    return new Point((left + right) / 2, (top + bottom) / 2);
  }
  get area() {
    const { width, height } = this;
    return width * height;
  }
  equals(shape) {
    if (!(shape instanceof _Rectangle)) {
      return false;
    }
    const { left, top, width, height } = this;
    return left === shape.left && top === shape.top && width === shape.width && height === shape.height;
  }
  containsPoint(point) {
    const { top, left, bottom, right } = this;
    return top <= point.y && point.y <= bottom && left <= point.x && point.x <= right;
  }
  intersectionArea(shape) {
    if (shape instanceof _Rectangle) {
      return rectangleRectangleIntersection(this, shape);
    }
    return 0;
  }
  intersectionRatio(shape) {
    const { area } = this;
    const intersectionArea = this.intersectionArea(shape);
    const intersectionRatio = intersectionArea / (shape.area + area - intersectionArea);
    return intersectionRatio;
  }
  get bottom() {
    const { top, height } = this;
    return top + height;
  }
  get right() {
    const { left, width } = this;
    return left + width;
  }
  get aspectRatio() {
    const { width, height } = this;
    return width / height;
  }
  get corners() {
    return [
      { x: this.left, y: this.top },
      { x: this.right, y: this.top },
      { x: this.left, y: this.bottom },
      { x: this.right, y: this.bottom }
    ];
  }
  static from({ top, left, width, height }) {
    return new _Rectangle(left, top, width, height);
  }
  static delta(a2, b2, alignment = { x: "center", y: "center" }) {
    const getCoordinate = (rect, axis) => {
      const align = alignment[axis];
      const start = axis === "x" ? rect.left : rect.top;
      const size = axis === "x" ? rect.width : rect.height;
      if (align == "start") return start;
      if (align == "end") return start + size;
      return start + size / 2;
    };
    return Point.delta(
      { x: getCoordinate(a2, "x"), y: getCoordinate(a2, "y") },
      { x: getCoordinate(b2, "x"), y: getCoordinate(b2, "y") }
    );
  }
  static intersectionRatio(a2, b2) {
    return _Rectangle.from(a2).intersectionRatio(_Rectangle.from(b2));
  }
};
function rectangleRectangleIntersection(a2, b2) {
  const top = Math.max(b2.top, a2.top);
  const left = Math.max(b2.left, a2.left);
  const right = Math.min(b2.left + b2.width, a2.left + a2.width);
  const bottom = Math.min(b2.top + b2.height, a2.top + a2.height);
  const width = right - left;
  const height = bottom - top;
  if (left < right && top < bottom) {
    const intersectionArea = width * height;
    return intersectionArea;
  }
  return 0;
}
var _direction_dec;
var _delta_dec;
var _a2;
var _timestamp;
var _init2;
var Position = class extends (_a2 = ValueHistory, _delta_dec = [derived], _direction_dec = [derived], _a2) {
  constructor(initialValue) {
    const point = Point.from(initialValue);
    super(point, (a2, b2) => Point.equals(a2, b2));
    __runInitializers2(_init2, 5, this);
    __privateAdd2(this, _timestamp, 0);
    this.velocity = { x: 0, y: 0 };
  }
  get delta() {
    return Point.delta(this.current, this.initial);
  }
  get direction() {
    const { current, previous } = this;
    if (!previous) return null;
    const delta = {
      x: current.x - previous.x,
      y: current.y - previous.y
    };
    if (!delta.x && !delta.y) {
      return null;
    }
    if (Math.abs(delta.x) > Math.abs(delta.y)) {
      return delta.x > 0 ? "right" : "left";
    }
    return delta.y > 0 ? "down" : "up";
  }
  get current() {
    return super.current;
  }
  set current(coordinates) {
    const { current } = this;
    const point = Point.from(coordinates);
    const delta = {
      x: point.x - current.x,
      y: point.y - current.y
    };
    const timestamp = Date.now();
    const timeDelta = timestamp - __privateGet2(this, _timestamp);
    const velocity = (delta2) => Math.round(delta2 / timeDelta * 100);
    n(() => {
      __privateSet2(this, _timestamp, timestamp);
      this.velocity = {
        x: velocity(delta.x),
        y: velocity(delta.y)
      };
      super.current = point;
    });
  }
  reset(coordinates = this.defaultValue) {
    super.reset(Point.from(coordinates));
    this.velocity = { x: 0, y: 0 };
  }
};
_init2 = __decoratorStart2(_a2);
_timestamp = /* @__PURE__ */ new WeakMap();
__decorateElement2(_init2, 2, "delta", _delta_dec, Position);
__decorateElement2(_init2, 2, "direction", _direction_dec, Position);
__decoratorMetadata2(_init2, Position);
function exceedsDistance({ x, y: y2 }, distance) {
  const dx = Math.abs(x);
  const dy = Math.abs(y2);
  if (typeof distance === "number") {
    return Math.sqrt(__pow(dx, 2) + __pow(dy, 2)) > distance;
  }
  if ("x" in distance && "y" in distance) {
    return dx > distance.x && dy > distance.y;
  }
  if ("x" in distance) {
    return dx > distance.x;
  }
  if ("y" in distance) {
    return dy > distance.y;
  }
  return false;
}
var Axis = ((Axis22) => {
  Axis22["Horizontal"] = "x";
  Axis22["Vertical"] = "y";
  return Axis22;
})(Axis || {});
var Axes = Object.values(Axis);

// node_modules/@dnd-kit/abstract/index.js
var __create3 = Object.create;
var __defProp3 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __knownSymbol3 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp3.call(b2, prop))
      __defNormalProp3(a2, prop, b2[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b2)) {
      if (__propIsEnum3.call(b2, prop))
        __defNormalProp3(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps3 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
var __name3 = (target, value) => __defProp3(target, "name", { value, configurable: true });
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decoratorStart3 = (base) => {
  var _a5;
  return [, , , __create3((_a5 = base == null ? void 0 : base[__knownSymbol3("metadata")]) != null ? _a5 : null)];
};
var __decoratorStrings3 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn3 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError3("Function expected") : fn;
var __decoratorContext3 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings3[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError3("Already initialized") : fns.push(__expectFn3(fn || null)) });
var __decoratorMetadata3 = (array, target) => __defNormalProp3(target, __knownSymbol3("metadata"), array[3]);
var __runInitializers3 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n2 = fns && fns.length; i2 < n2; i2++) flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement3 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p2 = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s2 ? 1 : 2 : 0, key = __decoratorStrings3[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p2 && !s2 && (target = target.prototype), k < 5 && (k > 3 || !p2) && __getOwnPropDesc3(k < 4 ? target : { get [name]() {
    return __privateGet3(this, extra);
  }, set [name](x) {
    return __privateSet3(this, extra, x);
  } }, name));
  k ? p2 && k < 4 && __name3(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name3(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext3(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: p2 ? (x) => __privateIn3(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p2 ? (x) => (k ^ 1 ? __privateGet3 : __privateMethod3)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p2 ? (x, y2) => __privateSet3(x, target, y2, k ^ 4 ? extra : desc.set) : (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p2 ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn3(it) && (k > 4 ? initializers.unshift(it) : k ? p2 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError3("Object expected");
    else __expectFn3(fn = it.get) && (desc.get = fn), __expectFn3(fn = it.set) && (desc.set = fn), __expectFn3(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata3(array, target), desc && __defProp3(target, name, desc), p2 ? k ^ 4 ? extra : desc : target;
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateIn3 = (member, obj) => Object(obj) !== obj ? __typeError3('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet3 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet3 = (obj, member, value, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod3 = (obj, member, method) => (__accessCheck3(obj, member, "access private method"), method);
function configure(plugin, options2) {
  return {
    plugin,
    options: options2
  };
}
function configurator(plugin) {
  return (options2) => {
    return configure(plugin, options2);
  };
}
function descriptor(plugin) {
  if (typeof plugin === "function") {
    return {
      plugin,
      options: void 0
    };
  }
  return plugin;
}
var _disabled_dec;
var _init3;
var _disabled;
var _cleanupFunctions;
_disabled_dec = [reactive];
var Plugin = class {
  /**
   * Creates a new plugin instance.
   *
   * @param manager - The drag and drop manager that owns this plugin
   * @param options - Optional configuration for the plugin
   */
  constructor(manager, options2) {
    this.manager = manager;
    this.options = options2;
    __privateAdd3(this, _disabled, __runInitializers3(_init3, 8, this, false)), __runInitializers3(_init3, 11, this);
    __privateAdd3(this, _cleanupFunctions, /* @__PURE__ */ new Set());
  }
  /**
   * Enables a disabled plugin instance.
   *
   * @remarks
   * This method triggers effects when called.
   */
  enable() {
    this.disabled = false;
  }
  /**
   * Disables an enabled plugin instance.
   *
   * @remarks
   * This method triggers effects when called.
   */
  disable() {
    this.disabled = true;
  }
  /**
   * Checks if the plugin instance is disabled.
   *
   * @returns true if the plugin is disabled
   * @remarks
   * This method does not trigger effects when accessed.
   */
  isDisabled() {
    return o(() => {
      return this.disabled;
    });
  }
  /**
   * Configures a plugin instance with new options.
   *
   * @param options - The new options to apply
   */
  configure(options2) {
    this.options = options2;
  }
  /**
   * Registers an effect that will be cleaned up when the plugin is destroyed.
   *
   * @param callback - The effect callback to register
   * @returns A function to dispose of the effect
   */
  registerEffect(callback) {
    const dispose = m(callback.bind(this));
    __privateGet3(this, _cleanupFunctions).add(dispose);
    return dispose;
  }
  /**
   * Destroys a plugin instance and cleans up its resources.
   *
   * @remarks
   * This method:
   * - Calls all registered cleanup functions
   * - Should be overridden by subclasses to clean up additional resources
   */
  destroy() {
    __privateGet3(this, _cleanupFunctions).forEach((cleanup) => cleanup());
  }
  /**
   * Configures a plugin constructor with options.
   *
   * @param options - The options to configure the constructor with
   * @returns The configured plugin constructor
   *
   * @remarks
   * This method is used to configure the options that the
   * plugin constructor will use to create plugin instances.
   */
  static configure(options2) {
    return configure(this, options2);
  }
};
_init3 = __decoratorStart3(null);
_disabled = /* @__PURE__ */ new WeakMap();
_cleanupFunctions = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init3, 4, "disabled", _disabled_dec, Plugin, _disabled);
__decoratorMetadata3(_init3, Plugin);
var CorePlugin = class extends Plugin {
};
var _previousValues;
var PluginRegistry = class {
  /**
   * Creates a new plugin registry.
   *
   * @param manager - The drag and drop manager that owns this registry
   */
  constructor(manager) {
    this.manager = manager;
    this.instances = /* @__PURE__ */ new Map();
    __privateAdd3(this, _previousValues, []);
  }
  /**
   * Gets all registered plugin instances.
   *
   * @returns An array of all active plugin instances
   */
  get values() {
    return Array.from(this.instances.values());
  }
  /**
   * Sets the list of plugins to be used by the registry.
   *
   * @param entries - Array of plugin constructors or descriptors
   * @remarks
   * This method:
   * - Filters out duplicate plugins
   * - Unregisters plugins that are no longer in use
   * - Registers new plugins with their options
   */
  set values(entries) {
    const descriptors = entries.map(descriptor).reduceRight((acc, descriptor2) => {
      if (acc.some(({ plugin }) => plugin === descriptor2.plugin)) {
        return acc;
      }
      return [descriptor2, ...acc];
    }, []);
    const constructors = descriptors.map(({ plugin }) => plugin);
    for (const plugin of __privateGet3(this, _previousValues)) {
      if (!constructors.includes(plugin)) {
        if (plugin.prototype instanceof CorePlugin) {
          continue;
        }
        this.unregister(plugin);
      }
    }
    for (const { plugin, options: options2 } of descriptors) {
      this.register(plugin, options2);
    }
    __privateSet3(this, _previousValues, constructors);
  }
  /**
   * Gets a plugin instance by its constructor.
   *
   * @param plugin - The plugin constructor to look up
   * @returns The plugin instance or undefined if not found
   */
  get(plugin) {
    const instance = this.instances.get(plugin);
    return instance;
  }
  /**
   * Registers a new plugin instance.
   *
   * @param plugin - The plugin constructor to register
   * @param options - Optional configuration for the plugin
   * @returns The registered plugin instance
   * @remarks
   * If the plugin is already registered, its options will be updated
   * and the existing instance will be returned.
   */
  register(plugin, options2) {
    const existingInstance = this.instances.get(plugin);
    if (existingInstance) {
      if (existingInstance.options !== options2) {
        existingInstance.options = options2;
      }
      return existingInstance;
    }
    const instance = new plugin(this.manager, options2);
    this.instances.set(plugin, instance);
    return instance;
  }
  /**
   * Unregisters a plugin instance.
   *
   * @param plugin - The plugin constructor to unregister
   * @remarks
   * This method:
   * - Destroys the plugin instance
   * - Removes it from the registry
   */
  unregister(plugin) {
    const instance = this.instances.get(plugin);
    if (instance) {
      instance.destroy();
      this.instances.delete(plugin);
    }
  }
  /**
   * Destroys all registered plugin instances.
   *
   * @remarks
   * This method:
   * - Calls destroy() on all plugin instances
   * - Clears the registry
   */
  destroy() {
    for (const plugin of this.instances.values()) {
      plugin.destroy();
    }
    this.instances.clear();
  }
};
_previousValues = /* @__PURE__ */ new WeakMap();
function sortCollisions(a2, b2) {
  if (a2.priority === b2.priority) {
    if (a2.type === b2.type) {
      return b2.value - a2.value;
    }
    return b2.type - a2.type;
  }
  return b2.priority - a2.priority;
}
var DEFAULT_VALUE = [];
var _previousCoordinates;
var _collisions;
var CollisionObserver = class extends Plugin {
  /**
   * Creates a new CollisionObserver instance.
   *
   * @param manager - The drag drop manager instance
   */
  constructor(manager) {
    super(manager);
    __privateAdd3(this, _previousCoordinates);
    __privateAdd3(this, _collisions);
    this.computeCollisions = this.computeCollisions.bind(this);
    __privateSet3(this, _collisions, c2(DEFAULT_VALUE));
    this.destroy = effects(
      () => {
        const collisions = this.computeCollisions();
        const coordinates = o(
          () => this.manager.dragOperation.position.current
        );
        if (collisions !== DEFAULT_VALUE) {
          const previousCoordinates = __privateGet3(this, _previousCoordinates);
          __privateSet3(this, _previousCoordinates, coordinates);
          if (previousCoordinates && coordinates.x == previousCoordinates.x && coordinates.y == previousCoordinates.y) {
            return;
          }
        } else {
          __privateSet3(this, _previousCoordinates, void 0);
        }
        __privateGet3(this, _collisions).value = collisions;
      },
      () => {
        const { dragOperation } = this.manager;
        if (dragOperation.status.initialized) {
          this.forceUpdate();
        }
      }
    );
  }
  /**
   * Forces an immediate update of collision detection.
   *
   * @param immediate - If true, updates collisions immediately. If false, resets previous coordinates.
   */
  forceUpdate(immediate = true) {
    o(() => {
      if (immediate) {
        __privateGet3(this, _collisions).value = this.computeCollisions();
      } else {
        __privateSet3(this, _previousCoordinates, void 0);
      }
    });
  }
  /**
   * Computes collisions between draggable and droppable elements.
   *
   * @param entries - Optional array of droppable elements to check. If not provided, uses all registered droppables.
   * @param collisionDetector - Optional custom collision detector function
   * @returns Array of detected collisions, sorted by priority
   */
  computeCollisions(entries, collisionDetector) {
    const { registry, dragOperation } = this.manager;
    const { source, shape, status } = dragOperation;
    if (!status.initialized || !shape) {
      return DEFAULT_VALUE;
    }
    const collisions = [];
    const potentialTargets = [];
    for (const entry of entries != null ? entries : registry.droppables) {
      if (entry.disabled) {
        continue;
      }
      if (source && !entry.accepts(source)) {
        continue;
      }
      const detectCollision = collisionDetector != null ? collisionDetector : entry.collisionDetector;
      if (!detectCollision) {
        continue;
      }
      potentialTargets.push(entry);
      void entry.shape;
      const collision = o(
        () => detectCollision({
          droppable: entry,
          dragOperation
        })
      );
      if (collision) {
        if (entry.collisionPriority != null) {
          collision.priority = entry.collisionPriority;
        }
        collisions.push(collision);
      }
    }
    if (potentialTargets.length === 0) {
      return DEFAULT_VALUE;
    }
    collisions.sort(sortCollisions);
    return collisions;
  }
  /**
   * Gets the current collisions signal value.
   */
  get collisions() {
    return __privateGet3(this, _collisions).value;
  }
};
_previousCoordinates = /* @__PURE__ */ new WeakMap();
_collisions = /* @__PURE__ */ new WeakMap();
var Monitor2 = class {
  constructor() {
    this.registry = /* @__PURE__ */ new Map();
  }
  /**
   * Adds an event listener for the specified event type.
   *
   * @param name - The name of the event to listen for
   * @param handler - The function to call when the event occurs
   * @returns A function to remove the event listener
   */
  addEventListener(name, handler) {
    const { registry } = this;
    const listeners = new Set(registry.get(name));
    listeners.add(handler);
    registry.set(name, listeners);
    return () => this.removeEventListener(name, handler);
  }
  /**
   * Removes an event listener for the specified event type.
   *
   * @param name - The name of the event
   * @param handler - The function to remove
   */
  removeEventListener(name, handler) {
    const { registry } = this;
    const listeners = new Set(registry.get(name));
    listeners.delete(handler);
    registry.set(name, listeners);
  }
  /**
   * Dispatches an event to all registered listeners.
   *
   * @param name - The name of the event to dispatch
   * @param args - Arguments to pass to the event handlers
   */
  dispatch(name, ...args) {
    const { registry } = this;
    const listeners = registry.get(name);
    if (!listeners) {
      return;
    }
    for (const listener of listeners) {
      listener(...args);
    }
  }
};
var DragDropMonitor = class extends Monitor2 {
  /**
   * Creates a new drag and drop monitor.
   *
   * @param manager - The drag and drop manager to monitor
   */
  constructor(manager) {
    super();
    this.manager = manager;
  }
  /**
   * Dispatches a drag and drop event.
   *
   * @param type - The type of event to dispatch
   * @param event - The event data to dispatch
   */
  dispatch(type, event) {
    const args = [event, this.manager];
    super.dispatch(type, ...args);
  }
};
function defaultPreventable(event, cancelable = true) {
  let defaultPrevented = false;
  return __spreadProps3(__spreadValues4({}, event), {
    cancelable,
    get defaultPrevented() {
      return defaultPrevented;
    },
    preventDefault() {
      if (!cancelable) {
        return;
      }
      defaultPrevented = true;
    }
  });
}
var CollisionNotifier = class extends CorePlugin {
  constructor(manager) {
    super(manager);
    const isEqual = (a2, b2) => a2.map(({ id }) => id).join("") === b2.map(({ id }) => id).join("");
    let previousCollisions = [];
    this.destroy = effects(
      () => {
        const { dragOperation, collisionObserver } = manager;
        if (dragOperation.status.initializing) {
          previousCollisions = [];
          collisionObserver.enable();
        }
      },
      () => {
        const { collisionObserver, monitor } = manager;
        const { collisions } = collisionObserver;
        if (collisionObserver.isDisabled()) {
          return;
        }
        const event = defaultPreventable({
          collisions
        });
        monitor.dispatch("collision", event);
        if (event.defaultPrevented) {
          return;
        }
        if (isEqual(collisions, previousCollisions)) {
          return;
        } else {
          previousCollisions = collisions;
        }
        const [firstCollision] = collisions;
        o(() => {
          var _a5;
          if ((firstCollision == null ? void 0 : firstCollision.id) !== ((_a5 = manager.dragOperation.target) == null ? void 0 : _a5.id)) {
            collisionObserver.disable();
            manager.actions.setDropTarget(firstCollision == null ? void 0 : firstCollision.id).then(() => {
              collisionObserver.enable();
            });
          }
        });
      }
    );
  }
};
var CollisionPriority = ((CollisionPriority2) => {
  CollisionPriority2[CollisionPriority2["Lowest"] = 0] = "Lowest";
  CollisionPriority2[CollisionPriority2["Low"] = 1] = "Low";
  CollisionPriority2[CollisionPriority2["Normal"] = 2] = "Normal";
  CollisionPriority2[CollisionPriority2["High"] = 3] = "High";
  CollisionPriority2[CollisionPriority2["Highest"] = 4] = "Highest";
  return CollisionPriority2;
})(CollisionPriority || {});
var CollisionType = ((CollisionType2) => {
  CollisionType2[CollisionType2["Collision"] = 0] = "Collision";
  CollisionType2[CollisionType2["ShapeIntersection"] = 1] = "ShapeIntersection";
  CollisionType2[CollisionType2["PointerIntersection"] = 2] = "PointerIntersection";
  return CollisionType2;
})(CollisionType || {});
var _dropped_dec;
var _dragging_dec;
var _initialized_dec;
var _initializing_dec;
var _idle_dec;
var _current_dec3;
var _value_dec;
var _init22;
var _value;
_value_dec = [reactive], _current_dec3 = [derived], _idle_dec = [derived], _initializing_dec = [derived], _initialized_dec = [derived], _dragging_dec = [derived], _dropped_dec = [derived];
var Status = class {
  constructor() {
    __runInitializers3(_init22, 5, this);
    __privateAdd3(this, _value, __runInitializers3(
      _init22,
      8,
      this,
      "idle"
      /* Idle */
    )), __runInitializers3(_init22, 11, this);
  }
  get current() {
    return this.value;
  }
  get idle() {
    return this.value === "idle";
  }
  get initializing() {
    return this.value === "initializing";
  }
  get initialized() {
    const { value } = this;
    return value !== "idle" && value !== "initialization-pending";
  }
  get dragging() {
    return this.value === "dragging";
  }
  get dropped() {
    return this.value === "dropped";
  }
  /**
   * Sets the current status value.
   *
   * @param value - The new status value
   */
  set(value) {
    this.value = value;
  }
};
_init22 = __decoratorStart3(null);
_value = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init22, 4, "value", _value_dec, Status, _value);
__decorateElement3(_init22, 2, "current", _current_dec3, Status);
__decorateElement3(_init22, 2, "idle", _idle_dec, Status);
__decorateElement3(_init22, 2, "initializing", _initializing_dec, Status);
__decorateElement3(_init22, 2, "initialized", _initialized_dec, Status);
__decorateElement3(_init22, 2, "dragging", _dragging_dec, Status);
__decorateElement3(_init22, 2, "dropped", _dropped_dec, Status);
__decoratorMetadata3(_init22, Status);
var DragActions = class {
  /**
   * Creates a new instance of drag actions.
   *
   * @param manager - The drag and drop manager instance
   */
  constructor(manager) {
    this.manager = manager;
  }
  /**
   * Sets the source of the drag operation.
   *
   * @param source - The draggable entity or its unique identifier
   */
  setDragSource(source) {
    const { dragOperation } = this.manager;
    dragOperation.sourceIdentifier = typeof source === "string" || typeof source === "number" ? source : source.id;
  }
  /**
   * Sets the target of the drop operation.
   *
   * @param identifier - The unique identifier of the droppable entity or null/undefined
   * @returns A promise that resolves to true if the drop was prevented
   */
  setDropTarget(identifier) {
    return o(() => {
      const { dragOperation } = this.manager;
      const id = identifier != null ? identifier : null;
      if (dragOperation.targetIdentifier === id) {
        return Promise.resolve(false);
      }
      dragOperation.targetIdentifier = id;
      const event = defaultPreventable({
        operation: dragOperation.snapshot()
      });
      if (dragOperation.status.dragging) {
        this.manager.monitor.dispatch("dragover", event);
      }
      return this.manager.renderer.rendering.then(() => event.defaultPrevented);
    });
  }
  /**
   * Starts a new drag operation.
   *
   * @param args - Configuration for the drag operation
   * @param args.event - The event that initiated the drag
   * @param args.source - The source draggable entity or its identifier
   * @param args.coordinates - The initial coordinates of the drag
   * @returns true if the drag operation started successfully
   * @throws {Error} If there is no drag source or another operation is active
   */
  start(args) {
    return o(() => {
      const { dragOperation } = this.manager;
      if (args.source != null) {
        this.setDragSource(args.source);
      }
      const sourceInstance = dragOperation.source;
      if (!sourceInstance) {
        throw new Error("Cannot start a drag operation without a drag source");
      }
      if (!dragOperation.status.idle) {
        throw new Error(
          "Cannot start a drag operation while another is active"
        );
      }
      const controller = new AbortController();
      const { event: nativeEvent, coordinates } = args;
      n(() => {
        dragOperation.status.set(
          "initialization-pending"
          /* InitializationPending */
        );
        dragOperation.shape = null;
        dragOperation.canceled = false;
        dragOperation.activatorEvent = nativeEvent != null ? nativeEvent : null;
        dragOperation.position.reset(coordinates);
      });
      const beforeStartEvent = defaultPreventable({
        operation: dragOperation.snapshot()
      });
      this.manager.monitor.dispatch("beforedragstart", beforeStartEvent);
      if (beforeStartEvent.defaultPrevented) {
        dragOperation.reset();
        controller.abort();
        return controller;
      }
      dragOperation.status.set(
        "initializing"
        /* Initializing */
      );
      dragOperation.controller = controller;
      this.manager.renderer.rendering.then(() => {
        if (controller.signal.aborted) return;
        const { status } = dragOperation;
        if (status.current !== "initializing") return;
        dragOperation.status.set(
          "dragging"
          /* Dragging */
        );
        this.manager.monitor.dispatch("dragstart", {
          nativeEvent,
          operation: dragOperation.snapshot(),
          cancelable: false
        });
      });
      return controller;
    });
  }
  /**
   * Moves the dragged entity to a new position.
   *
   * @param args - Configuration for the move operation
   * @param args.by - Relative coordinates to move by
   * @param args.to - Absolute coordinates to move to
   * @param args.event - The event that triggered the move
   * @param args.cancelable - Whether the move can be canceled
   * @param args.propagate - Whether to dispatch dragmove events
   */
  move(args) {
    return o(() => {
      var _a5, _b3;
      const { dragOperation } = this.manager;
      const { status, controller } = dragOperation;
      if (!status.dragging || !controller || controller.signal.aborted) {
        return;
      }
      const event = defaultPreventable(
        {
          nativeEvent: args.event,
          operation: dragOperation.snapshot(),
          by: args.by,
          to: args.to
        },
        (_a5 = args.cancelable) != null ? _a5 : true
      );
      if ((_b3 = args.propagate) != null ? _b3 : true) {
        this.manager.monitor.dispatch("dragmove", event);
      }
      queueMicrotask(() => {
        var _a23, _b22, _c32, _d2, _e;
        if (event.defaultPrevented) {
          return;
        }
        const coordinates = (_e = args.to) != null ? _e : {
          x: dragOperation.position.current.x + ((_b22 = (_a23 = args.by) == null ? void 0 : _a23.x) != null ? _b22 : 0),
          y: dragOperation.position.current.y + ((_d2 = (_c32 = args.by) == null ? void 0 : _c32.y) != null ? _d2 : 0)
        };
        dragOperation.position.current = coordinates;
      });
    });
  }
  /**
   * Stops the current drag operation.
   *
   * @param args - Configuration for stopping the operation
   * @param args.event - The event that triggered the stop
   * @param args.canceled - Whether the operation was canceled
   * @remarks
   * This method:
   * - Dispatches a dragend event
   * - Allows suspension of the operation
   * - Handles cleanup of the operation state
   */
  stop(args = {}) {
    return o(() => {
      var _a5, _b3;
      const { dragOperation } = this.manager;
      const { controller } = dragOperation;
      if (!controller || controller.signal.aborted) return;
      let promise;
      const suspend = () => {
        const output = {
          resume: () => {
          },
          abort: () => {
          }
        };
        promise = new Promise((resolve, reject) => {
          output.resume = resolve;
          output.abort = reject;
        });
        return output;
      };
      controller.abort();
      const end = () => {
        this.manager.renderer.rendering.then(() => {
          dragOperation.status.set(
            "dropped"
            /* Dropped */
          );
          const dropping = o(
            () => {
              var _a23;
              return ((_a23 = dragOperation.source) == null ? void 0 : _a23.status) === "dropping";
            }
          );
          const cleanup = () => {
            if (dragOperation.controller === controller) {
              dragOperation.controller = void 0;
            }
            dragOperation.reset();
          };
          if (dropping) {
            const { source } = dragOperation;
            const dispose = m(() => {
              if ((source == null ? void 0 : source.status) === "idle") {
                dispose();
                cleanup();
              }
            });
          } else {
            this.manager.renderer.rendering.then(cleanup);
          }
        });
      };
      dragOperation.canceled = (_a5 = args.canceled) != null ? _a5 : false;
      this.manager.monitor.dispatch("dragend", {
        nativeEvent: args.event,
        operation: dragOperation.snapshot(),
        canceled: (_b3 = args.canceled) != null ? _b3 : false,
        suspend
      });
      if (promise) {
        promise.then(end).catch(() => dragOperation.reset());
      } else {
        end();
      }
    });
  }
};
var _disabled_dec2;
var _data_dec;
var _id_dec;
var _manager_dec;
var _init32;
var _manager;
var _id;
var _data;
var _disabled2;
_manager_dec = [reactive], _id_dec = [reactive], _data_dec = [reactive], _disabled_dec2 = [reactive];
var Entity = class {
  /**
   * Creates a new instance of the `Entity` class.
   *
   * @param input - An object containing the initial properties of the entity.
   * @param manager - The manager that controls the drag and drop operations.
   */
  constructor(input, manager) {
    __privateAdd3(this, _manager, __runInitializers3(_init32, 8, this)), __runInitializers3(_init32, 11, this);
    __privateAdd3(this, _id, __runInitializers3(_init32, 12, this)), __runInitializers3(_init32, 15, this);
    __privateAdd3(this, _data, __runInitializers3(_init32, 16, this)), __runInitializers3(_init32, 19, this);
    __privateAdd3(this, _disabled2, __runInitializers3(_init32, 20, this)), __runInitializers3(_init32, 23, this);
    const { effects: effects6, id, data = {}, disabled = false, register = true } = input;
    let previousId = id;
    this.manager = manager;
    this.id = id;
    this.data = data;
    this.disabled = disabled;
    this.effects = () => {
      var _a5;
      return [
        () => {
          const { id: id2, manager: manager2 } = this;
          if (id2 === previousId) {
            return;
          }
          manager2 == null ? void 0 : manager2.registry.register(this);
          return () => manager2 == null ? void 0 : manager2.registry.unregister(this);
        },
        ...(_a5 = effects6 == null ? void 0 : effects6()) != null ? _a5 : []
      ];
    };
    this.register = this.register.bind(this);
    this.unregister = this.unregister.bind(this);
    this.destroy = this.destroy.bind(this);
    if (manager && register) {
      queueMicrotask(this.register);
    }
  }
  /**
   * A method that registers the entity with the manager.
   * @returns CleanupFunction | void
   */
  register() {
    var _a5;
    return (_a5 = this.manager) == null ? void 0 : _a5.registry.register(this);
  }
  /**
   * A method that unregisters the entity from the manager.
   * @returns void
   */
  unregister() {
    var _a5;
    (_a5 = this.manager) == null ? void 0 : _a5.registry.unregister(this);
  }
  /**
   * A method that cleans up the entity when it is no longer needed.
   * @returns void
   */
  destroy() {
    var _a5;
    (_a5 = this.manager) == null ? void 0 : _a5.registry.unregister(this);
  }
};
_init32 = __decoratorStart3(null);
_manager = /* @__PURE__ */ new WeakMap();
_id = /* @__PURE__ */ new WeakMap();
_data = /* @__PURE__ */ new WeakMap();
_disabled2 = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init32, 4, "manager", _manager_dec, Entity, _manager);
__decorateElement3(_init32, 4, "id", _id_dec, Entity, _id);
__decorateElement3(_init32, 4, "data", _data_dec, Entity, _data);
__decorateElement3(_init32, 4, "disabled", _disabled_dec2, Entity, _disabled2);
__decoratorMetadata3(_init32, Entity);
var EntityRegistry = class {
  constructor() {
    this.map = c2(/* @__PURE__ */ new Map());
    this.cleanupFunctions = /* @__PURE__ */ new WeakMap();
    this.register = (key, value) => {
      const current = this.map.peek();
      const currentValue2 = current.get(key);
      const unregister = () => this.unregister(key, value);
      if (currentValue2 === value) return unregister;
      if (currentValue2) {
        const cleanup2 = this.cleanupFunctions.get(currentValue2);
        cleanup2 == null ? void 0 : cleanup2();
        this.cleanupFunctions.delete(currentValue2);
      }
      const updatedMap = new Map(current);
      updatedMap.set(key, value);
      this.map.value = updatedMap;
      const cleanup = effects(...value.effects());
      this.cleanupFunctions.set(value, cleanup);
      return unregister;
    };
    this.unregister = (key, value) => {
      const current = this.map.peek();
      if (current.get(key) !== value) {
        return;
      }
      const cleanup = this.cleanupFunctions.get(value);
      cleanup == null ? void 0 : cleanup();
      this.cleanupFunctions.delete(value);
      const updatedMap = new Map(current);
      updatedMap.delete(key);
      this.map.value = updatedMap;
    };
  }
  /**
   * Iterator for the EntityRegistry class.
   * @returns An iterator for the values in the map.
   */
  [Symbol.iterator]() {
    return this.map.peek().values();
  }
  get value() {
    return this.map.value.values();
  }
  /**
   * Checks if a entity with the given identifier exists in the registry.
   * @param identifier - The unique identifier of the entity.
   * @returns True if the entity exists, false otherwise.
   */
  has(identifier) {
    return this.map.value.has(identifier);
  }
  /**
   * Retrieves a entity from the registry using its identifier.
   * @param identifier - The unique identifier of the entity.
   * @returns The entity if it exists, undefined otherwise.
   */
  get(identifier) {
    return this.map.value.get(identifier);
  }
  /**
   * Destroys all entries in the registry and clears the registry.
   */
  destroy() {
    for (const entry of this) {
      const cleanup = this.cleanupFunctions.get(entry);
      cleanup == null ? void 0 : cleanup();
      entry.destroy();
    }
    this.map.value = /* @__PURE__ */ new Map();
  }
};
var _isDragSource_dec;
var _isDragging_dec;
var _isDropping_dec;
var _status_dec;
var _modifiers_dec;
var _type_dec;
var _c2;
var _init4;
var _type;
var _modifiers;
var _status;
var Draggable = class extends (_c2 = Entity, _type_dec = [reactive], _modifiers_dec = [reactive], _status_dec = [reactive], _isDropping_dec = [derived], _isDragging_dec = [derived], _isDragSource_dec = [derived], _c2) {
  constructor(_a5, manager) {
    var _b3 = _a5, { modifiers, type, sensors } = _b3, input = __objRest2(_b3, ["modifiers", "type", "sensors"]);
    super(input, manager);
    __runInitializers3(_init4, 5, this);
    __privateAdd3(this, _type, __runInitializers3(_init4, 8, this)), __runInitializers3(_init4, 11, this);
    __privateAdd3(this, _modifiers, __runInitializers3(_init4, 12, this)), __runInitializers3(_init4, 15, this);
    __privateAdd3(this, _status, __runInitializers3(_init4, 16, this, this.isDragSource ? "dragging" : "idle")), __runInitializers3(_init4, 19, this);
    this.type = type;
    this.sensors = sensors;
    this.modifiers = modifiers;
    this.alignment = input.alignment;
  }
  get isDropping() {
    return this.status === "dropping" && this.isDragSource;
  }
  get isDragging() {
    return this.status === "dragging" && this.isDragSource;
  }
  get isDragSource() {
    var _a5, _b3;
    return ((_b3 = (_a5 = this.manager) == null ? void 0 : _a5.dragOperation.source) == null ? void 0 : _b3.id) === this.id;
  }
};
_init4 = __decoratorStart3(_c2);
_type = /* @__PURE__ */ new WeakMap();
_modifiers = /* @__PURE__ */ new WeakMap();
_status = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init4, 4, "type", _type_dec, Draggable, _type);
__decorateElement3(_init4, 4, "modifiers", _modifiers_dec, Draggable, _modifiers);
__decorateElement3(_init4, 4, "status", _status_dec, Draggable, _status);
__decorateElement3(_init4, 2, "isDropping", _isDropping_dec, Draggable);
__decorateElement3(_init4, 2, "isDragging", _isDragging_dec, Draggable);
__decorateElement3(_init4, 2, "isDragSource", _isDragSource_dec, Draggable);
__decoratorMetadata3(_init4, Draggable);
var _isDropTarget_dec;
var _shape_dec;
var _collisionPriority_dec;
var _collisionDetector_dec;
var _type_dec2;
var _accept_dec;
var _c22;
var _init5;
var _accept;
var _type2;
var _collisionDetector;
var _collisionPriority;
var _shape;
var Droppable = class extends (_c22 = Entity, _accept_dec = [reactive], _type_dec2 = [reactive], _collisionDetector_dec = [reactive], _collisionPriority_dec = [reactive], _shape_dec = [reactive], _isDropTarget_dec = [derived], _c22) {
  constructor(_a5, manager) {
    var _b3 = _a5, { accept, collisionDetector, collisionPriority, type } = _b3, input = __objRest2(_b3, ["accept", "collisionDetector", "collisionPriority", "type"]);
    super(input, manager);
    __runInitializers3(_init5, 5, this);
    __privateAdd3(this, _accept, __runInitializers3(_init5, 8, this)), __runInitializers3(_init5, 11, this);
    __privateAdd3(this, _type2, __runInitializers3(_init5, 12, this)), __runInitializers3(_init5, 15, this);
    __privateAdd3(this, _collisionDetector, __runInitializers3(_init5, 16, this)), __runInitializers3(_init5, 19, this);
    __privateAdd3(this, _collisionPriority, __runInitializers3(_init5, 20, this)), __runInitializers3(_init5, 23, this);
    __privateAdd3(this, _shape, __runInitializers3(_init5, 24, this)), __runInitializers3(_init5, 27, this);
    this.accept = accept;
    this.collisionDetector = collisionDetector;
    this.collisionPriority = collisionPriority;
    this.type = type;
  }
  /**
   * Checks whether or not the droppable accepts a given draggable.
   *
   * @param draggable - The draggable to check
   * @returns true if the draggable can be dropped here
   */
  accepts(draggable) {
    const { accept } = this;
    if (!accept) {
      return true;
    }
    if (typeof accept === "function") {
      return accept(draggable);
    }
    if (!draggable.type) {
      return false;
    }
    if (Array.isArray(accept)) {
      return accept.includes(draggable.type);
    }
    return draggable.type === accept;
  }
  get isDropTarget() {
    var _a5, _b3;
    return ((_b3 = (_a5 = this.manager) == null ? void 0 : _a5.dragOperation.target) == null ? void 0 : _b3.id) === this.id;
  }
};
_init5 = __decoratorStart3(_c22);
_accept = /* @__PURE__ */ new WeakMap();
_type2 = /* @__PURE__ */ new WeakMap();
_collisionDetector = /* @__PURE__ */ new WeakMap();
_collisionPriority = /* @__PURE__ */ new WeakMap();
_shape = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init5, 4, "accept", _accept_dec, Droppable, _accept);
__decorateElement3(_init5, 4, "type", _type_dec2, Droppable, _type2);
__decorateElement3(_init5, 4, "collisionDetector", _collisionDetector_dec, Droppable, _collisionDetector);
__decorateElement3(_init5, 4, "collisionPriority", _collisionPriority_dec, Droppable, _collisionPriority);
__decorateElement3(_init5, 4, "shape", _shape_dec, Droppable, _shape);
__decorateElement3(_init5, 2, "isDropTarget", _isDropTarget_dec, Droppable);
__decoratorMetadata3(_init5, Droppable);
var Sensor = class extends Plugin {
  /**
   * Creates a new sensor instance.
   *
   * @param manager - The drag drop manager instance
   * @param options - Optional sensor configuration
   */
  constructor(manager, options2) {
    super(manager, options2);
    this.manager = manager;
    this.options = options2;
  }
};
var Modifier = class extends Plugin {
  /**
   * Creates a new modifier instance.
   *
   * @param manager - The drag and drop manager that owns this modifier
   * @param options - Optional configuration for the modifier
   */
  constructor(manager, options2) {
    super(manager, options2);
    this.manager = manager;
    this.options = options2;
  }
  /**
   * Applies the modifier to the current drag operation.
   *
   * @param operation - The current state of the drag operation
   * @returns The transformed coordinates
   *
   * @remarks
   * Override this method to implement custom transformation logic.
   * The default implementation returns the original transform unchanged.
   */
  apply(operation) {
    return operation.transform;
  }
};
var DragDropRegistry = class {
  /**
   * Creates a new registry instance.
   *
   * @param manager - The drag and drop manager that owns this registry
   */
  constructor(manager) {
    this.draggables = new EntityRegistry();
    this.droppables = new EntityRegistry();
    this.plugins = new PluginRegistry(manager);
    this.sensors = new PluginRegistry(manager);
    this.modifiers = new PluginRegistry(manager);
  }
  register(input, options2) {
    if (input instanceof Draggable) {
      return this.draggables.register(input.id, input);
    }
    if (input instanceof Droppable) {
      return this.droppables.register(input.id, input);
    }
    if (input.prototype instanceof Modifier) {
      return this.modifiers.register(input, options2);
    }
    if (input.prototype instanceof Sensor) {
      return this.sensors.register(input, options2);
    }
    if (input.prototype instanceof Plugin) {
      return this.plugins.register(input, options2);
    }
    throw new Error("Invalid instance type");
  }
  unregister(input) {
    if (input instanceof Entity) {
      if (input instanceof Draggable) {
        return this.draggables.unregister(input.id, input);
      }
      if (input instanceof Droppable) {
        return this.droppables.unregister(input.id, input);
      }
      return () => {
      };
    }
    if (input.prototype instanceof Modifier) {
      return this.modifiers.unregister(input);
    }
    if (input.prototype instanceof Sensor) {
      return this.sensors.unregister(input);
    }
    if (input.prototype instanceof Plugin) {
      return this.plugins.unregister(input);
    }
    throw new Error("Invalid instance type");
  }
  /**
   * Destroys all registered entities and cleans up resources.
   *
   * @remarks
   * This method:
   * - Destroys all draggable and droppable entities
   * - Destroys all plugins, sensors, and modifiers
   * - Cleans up any associated resources
   */
  destroy() {
    this.draggables.destroy();
    this.droppables.destroy();
    this.plugins.destroy();
    this.sensors.destroy();
    this.modifiers.destroy();
  }
};
var _transform_dec;
var _target_dec;
var _source_dec;
var _modifiers_dec2;
var _targetIdentifier_dec;
var _sourceIdentifier_dec;
var _activatorEvent_dec;
var _canceled_dec;
var _shape_dec2;
var _manager2;
var _previousSource;
var _shape2;
var _init6;
var _canceled;
var _activatorEvent;
var _sourceIdentifier;
var _targetIdentifier;
var _modifiers2;
var _transform;
_shape_dec2 = [derived], _canceled_dec = [reactive], _activatorEvent_dec = [reactive], _sourceIdentifier_dec = [reactive], _targetIdentifier_dec = [reactive], _modifiers_dec2 = [reactive], _source_dec = [derived], _target_dec = [derived], _transform_dec = [derived];
var DragOperation = class {
  /**
   * Creates a new drag operation instance.
   *
   * @param manager - The drag and drop manager that owns this operation
   */
  constructor(manager) {
    __runInitializers3(_init6, 5, this);
    __privateAdd3(this, _manager2);
    __privateAdd3(this, _previousSource);
    __privateAdd3(this, _shape2, new ValueHistory(
      void 0,
      (a2, b2) => a2 && b2 ? a2.equals(b2) : a2 === b2
    ));
    this.status = new Status();
    __privateAdd3(this, _canceled, __runInitializers3(_init6, 8, this, false)), __runInitializers3(_init6, 11, this);
    __privateAdd3(this, _activatorEvent, __runInitializers3(_init6, 12, this, null)), __runInitializers3(_init6, 15, this);
    __privateAdd3(this, _sourceIdentifier, __runInitializers3(_init6, 16, this, null)), __runInitializers3(_init6, 19, this);
    __privateAdd3(this, _targetIdentifier, __runInitializers3(_init6, 20, this, null)), __runInitializers3(_init6, 23, this);
    __privateAdd3(this, _modifiers2, __runInitializers3(_init6, 24, this, [])), __runInitializers3(_init6, 27, this);
    this.position = new Position({ x: 0, y: 0 });
    __privateAdd3(this, _transform, { x: 0, y: 0 });
    __privateSet3(this, _manager2, manager);
  }
  get shape() {
    const { current, initial, previous } = __privateGet3(this, _shape2);
    if (!current || !initial) {
      return null;
    }
    return { current, initial, previous };
  }
  /**
   * Sets the shape of the dragged entity.
   *
   * @param value - The new shape or null to reset
   */
  set shape(value) {
    if (!value) {
      __privateGet3(this, _shape2).reset();
    } else {
      __privateGet3(this, _shape2).current = value;
    }
  }
  get source() {
    var _a5;
    const identifier = this.sourceIdentifier;
    if (identifier == null) return null;
    const value = __privateGet3(this, _manager2).registry.draggables.get(identifier);
    if (value) {
      __privateSet3(this, _previousSource, value);
    }
    return (_a5 = value != null ? value : __privateGet3(this, _previousSource)) != null ? _a5 : null;
  }
  get target() {
    var _a5;
    const identifier = this.targetIdentifier;
    return identifier != null ? (_a5 = __privateGet3(this, _manager2).registry.droppables.get(identifier)) != null ? _a5 : null : null;
  }
  get transform() {
    const { x, y: y2 } = this.position.delta;
    let transform = { x, y: y2 };
    for (const modifier of this.modifiers) {
      transform = modifier.apply(__spreadProps3(__spreadValues4({}, this.snapshot()), {
        transform
      }));
    }
    __privateSet3(this, _transform, transform);
    return transform;
  }
  /**
   * Creates a snapshot of the current drag operation state.
   *
   * @returns An immutable snapshot of the current operation state
   */
  snapshot() {
    return o(() => ({
      source: this.source,
      target: this.target,
      activatorEvent: this.activatorEvent,
      transform: __privateGet3(this, _transform),
      shape: this.shape ? snapshot(this.shape) : null,
      position: snapshot(this.position),
      status: snapshot(this.status),
      canceled: this.canceled
    }));
  }
  /**
   * Resets the drag operation to its initial state.
   *
   * @remarks
   * This method:
   * - Sets status to idle
   * - Clears source and target identifiers
   * - Resets shape history
   * - Resets position and transform
   * - Clears modifiers
   */
  reset() {
    n(() => {
      this.status.set(
        "idle"
        /* Idle */
      );
      this.sourceIdentifier = null;
      this.targetIdentifier = null;
      __privateGet3(this, _shape2).reset();
      this.position.reset({ x: 0, y: 0 });
      __privateSet3(this, _transform, { x: 0, y: 0 });
      this.modifiers = [];
    });
  }
};
_init6 = __decoratorStart3(null);
_manager2 = /* @__PURE__ */ new WeakMap();
_previousSource = /* @__PURE__ */ new WeakMap();
_shape2 = /* @__PURE__ */ new WeakMap();
_canceled = /* @__PURE__ */ new WeakMap();
_activatorEvent = /* @__PURE__ */ new WeakMap();
_sourceIdentifier = /* @__PURE__ */ new WeakMap();
_targetIdentifier = /* @__PURE__ */ new WeakMap();
_modifiers2 = /* @__PURE__ */ new WeakMap();
_transform = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init6, 2, "shape", _shape_dec2, DragOperation);
__decorateElement3(_init6, 4, "canceled", _canceled_dec, DragOperation, _canceled);
__decorateElement3(_init6, 4, "activatorEvent", _activatorEvent_dec, DragOperation, _activatorEvent);
__decorateElement3(_init6, 4, "sourceIdentifier", _sourceIdentifier_dec, DragOperation, _sourceIdentifier);
__decorateElement3(_init6, 4, "targetIdentifier", _targetIdentifier_dec, DragOperation, _targetIdentifier);
__decorateElement3(_init6, 4, "modifiers", _modifiers_dec2, DragOperation, _modifiers2);
__decorateElement3(_init6, 2, "source", _source_dec, DragOperation);
__decorateElement3(_init6, 2, "target", _target_dec, DragOperation);
__decorateElement3(_init6, 2, "transform", _transform_dec, DragOperation);
__decoratorMetadata3(_init6, DragOperation);
var defaultRenderer = {
  get rendering() {
    return Promise.resolve();
  }
};
var DragDropManager = class {
  /**
   * Creates a new drag and drop manager instance.
   *
   * @param config - Optional configuration for plugins, sensors, modifiers, and renderer
   */
  constructor(config) {
    this.destroy = () => {
      if (!this.dragOperation.status.idle) {
        this.actions.stop({ canceled: true });
      }
      this.dragOperation.modifiers.forEach((modifier) => modifier.destroy());
      this.registry.destroy();
      this.collisionObserver.destroy();
    };
    const {
      plugins = [],
      sensors = [],
      modifiers = [],
      renderer = defaultRenderer
    } = config != null ? config : {};
    const monitor = new DragDropMonitor(this);
    const registry = new DragDropRegistry(this);
    this.registry = registry;
    this.monitor = monitor;
    this.renderer = renderer;
    this.actions = new DragActions(this);
    this.dragOperation = new DragOperation(this);
    this.collisionObserver = new CollisionObserver(this);
    this.plugins = [CollisionNotifier, ...plugins];
    this.modifiers = modifiers;
    this.sensors = sensors;
    const { destroy } = this;
    const cleanup = effects(() => {
      var _a5, _b3, _c32;
      const currentModifiers = o(() => this.dragOperation.modifiers);
      const managerModifiers = this.modifiers;
      if (currentModifiers !== managerModifiers) {
        currentModifiers.forEach((modifier) => modifier.destroy());
      }
      this.dragOperation.modifiers = (_c32 = (_b3 = (_a5 = this.dragOperation.source) == null ? void 0 : _a5.modifiers) == null ? void 0 : _b3.map((modifier) => {
        const { plugin, options: options2 } = descriptor(modifier);
        return new plugin(this, options2);
      })) != null ? _c32 : managerModifiers;
    });
    this.destroy = () => {
      cleanup();
      destroy();
    };
  }
  /**
   * Gets the list of active plugins.
   *
   * @returns Array of active plugin instances
   */
  get plugins() {
    return this.registry.plugins.values;
  }
  /**
   * Sets the list of plugins to be used by the manager.
   *
   * @param plugins - Array of plugin constructors or instances
   */
  set plugins(plugins) {
    this.registry.plugins.values = plugins;
  }
  /**
   * Gets the list of active modifiers.
   *
   * @returns Array of active modifier instances
   */
  get modifiers() {
    return this.registry.modifiers.values;
  }
  /**
   * Sets the list of modifiers to be used by the manager.
   *
   * @param modifiers - Array of modifier constructors or instances
   */
  set modifiers(modifiers) {
    this.registry.modifiers.values = modifiers;
  }
  /**
   * Gets the list of active sensors.
   *
   * @returns Array of active sensor instances
   */
  get sensors() {
    return this.registry.sensors.values;
  }
  /**
   * Sets the list of sensors to be used by the manager.
   *
   * @param sensors - Array of sensor constructors or instances
   */
  set sensors(sensors) {
    this.registry.sensors.values = sensors;
  }
};

// node_modules/@dnd-kit/dom/utilities.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet4 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), member.get(obj));
var __privateAdd4 = (obj, member, value) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet4 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), member.set(obj, value), value);
var __privateMethod4 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
function isKeyframeEffect(effect) {
  if (!effect) return false;
  if (effect instanceof KeyframeEffect) return true;
  return "getKeyframes" in effect && typeof effect.getKeyframes === "function";
}
function getFinalKeyframe(element, match) {
  const animations2 = element.getAnimations();
  if (animations2.length > 0) {
    for (const animation of animations2) {
      if (animation.playState !== "running") continue;
      const { effect } = animation;
      const keyframes = isKeyframeEffect(effect) ? effect.getKeyframes() : [];
      const matchedKeyframes = keyframes.filter(match);
      if (matchedKeyframes.length > 0) {
        return [matchedKeyframes[matchedKeyframes.length - 1], animation];
      }
    }
  }
  return null;
}
function getBoundingRectangle(element) {
  const { width, height, top, left, bottom, right } = element.getBoundingClientRect();
  return { width, height, top, left, bottom, right };
}
var canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
function isWindow(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === "[object Window]" || // In Electron context the Window object serializes to [object global]
  elementString === "[object global]";
}
function isNode(node) {
  return "nodeType" in node;
}
function getWindow(target) {
  var _a5, _b3, _c4;
  if (!target) {
    return window;
  }
  if (isWindow(target)) {
    return target;
  }
  if (!isNode(target)) {
    return window;
  }
  if ("defaultView" in target) {
    return (_a5 = target.defaultView) != null ? _a5 : window;
  }
  return (_c4 = (_b3 = target.ownerDocument) == null ? void 0 : _b3.defaultView) != null ? _c4 : window;
}
function isDocument(node) {
  const { Document } = getWindow(node);
  return node instanceof Document || "nodeType" in node && node.nodeType === Node.DOCUMENT_NODE;
}
function isHTMLElement(node) {
  if (!node || isWindow(node)) return false;
  return node instanceof getWindow(node).HTMLElement || "namespaceURI" in node && typeof node.namespaceURI === "string" && node.namespaceURI.endsWith("html");
}
function isSVGElement(node) {
  return node instanceof getWindow(node).SVGElement || "namespaceURI" in node && typeof node.namespaceURI === "string" && node.namespaceURI.endsWith("svg");
}
function getDocument(target) {
  if (!target) {
    return document;
  }
  if (isWindow(target)) {
    return target.document;
  }
  if (!isNode(target)) {
    return document;
  }
  if (isDocument(target)) {
    return target;
  }
  if (isHTMLElement(target) || isSVGElement(target)) {
    return target.ownerDocument;
  }
  return document;
}
function getViewportBoundingRectangle(element) {
  const { documentElement } = getDocument(element);
  const width = documentElement.clientWidth;
  const height = documentElement.clientHeight;
  return {
    top: 0,
    left: 0,
    right: width,
    bottom: height,
    width,
    height
  };
}
function isOverflowVisible(element, style) {
  if (isDetailsElement(element) && element.open === false) {
    return false;
  }
  const { overflow, overflowX, overflowY } = getComputedStyle(element);
  return overflow === "visible" && overflowX === "visible" && overflowY === "visible";
}
function isDetailsElement(element) {
  return element.tagName === "DETAILS";
}
function getVisibleBoundingRectangle(element, boundingClientRect = element.getBoundingClientRect(), margin = 0) {
  var _a5;
  let rect = boundingClientRect;
  const { ownerDocument } = element;
  const ownerWindow = (_a5 = ownerDocument.defaultView) != null ? _a5 : window;
  let ancestor = element.parentElement;
  while (ancestor && ancestor !== ownerDocument.documentElement) {
    if (!isOverflowVisible(ancestor)) {
      const ancestorRect = ancestor.getBoundingClientRect();
      const marginTop = margin * (ancestorRect.bottom - ancestorRect.top);
      const marginRight = margin * (ancestorRect.right - ancestorRect.left);
      const marginBottom = margin * (ancestorRect.bottom - ancestorRect.top);
      const marginLeft = margin * (ancestorRect.right - ancestorRect.left);
      rect = {
        top: Math.max(rect.top, ancestorRect.top - marginTop),
        right: Math.min(rect.right, ancestorRect.right + marginRight),
        bottom: Math.min(rect.bottom, ancestorRect.bottom + marginBottom),
        left: Math.max(rect.left, ancestorRect.left - marginLeft),
        width: 0,
        // Will be calculated next
        height: 0
        // Will be calculated next
      };
      rect.width = rect.right - rect.left;
      rect.height = rect.bottom - rect.top;
    }
    ancestor = ancestor.parentElement;
  }
  const viewportWidth = ownerWindow.innerWidth;
  const viewportHeight = ownerWindow.innerHeight;
  const viewportMarginY = margin * viewportHeight;
  const viewportMarginX = margin * viewportWidth;
  rect = {
    top: Math.max(rect.top, 0 - viewportMarginY),
    right: Math.min(rect.right, viewportWidth + viewportMarginX),
    bottom: Math.min(rect.bottom, viewportHeight + viewportMarginY),
    left: Math.max(rect.left, 0 - viewportMarginX),
    width: 0,
    // Will be calculated next
    height: 0
    // Will be calculated next
  };
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  if (rect.width < 0) {
    rect.width = 0;
  }
  if (rect.height < 0) {
    rect.height = 0;
  }
  return rect;
}
function isSafari() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function cloneElement(element) {
  const selector = "input, textarea, select, canvas, [contenteditable]";
  const clonedElement = element.cloneNode(true);
  const fields = Array.from(element.querySelectorAll(selector));
  const clonedFields = Array.from(clonedElement.querySelectorAll(selector));
  clonedFields.forEach((field, index) => {
    const originalField = fields[index];
    if (isField(field) && isField(originalField)) {
      if (field.type !== "file") {
        field.value = originalField.value;
      }
      if (field.type === "radio" && field.name) {
        field.name = `Cloned__${field.name}`;
      }
    }
    if (isCanvasElement(field) && isCanvasElement(originalField) && originalField.width > 0 && originalField.height > 0) {
      const destCtx = field.getContext("2d");
      destCtx == null ? void 0 : destCtx.drawImage(originalField, 0, 0);
    }
  });
  return clonedElement;
}
function isField(element) {
  return "value" in element;
}
function isCanvasElement(element) {
  return element.tagName === "CANVAS";
}
function getElementFromPoint(document2, { x, y: y2 }) {
  const element = document2.elementFromPoint(x, y2);
  if (isIFrameElement(element)) {
    const { contentDocument } = element;
    if (contentDocument) {
      const { left, top } = element.getBoundingClientRect();
      return getElementFromPoint(contentDocument, {
        x: x - left,
        y: y2 - top
      });
    }
  }
  return element;
}
function isIFrameElement(element) {
  return (element == null ? void 0 : element.tagName) === "IFRAME";
}
var ProxiedElements = /* @__PURE__ */ new WeakMap();
var Listeners = class {
  constructor() {
    this.entries = /* @__PURE__ */ new Set();
    this.clear = () => {
      for (const entry of this.entries) {
        const [target, { type, listener, options: options2 }] = entry;
        target.removeEventListener(type, listener, options2);
      }
      this.entries.clear();
    };
  }
  bind(target, input) {
    const listeners = Array.isArray(input) ? input : [input];
    const entries = [];
    for (const descriptor2 of listeners) {
      const { type, listener, options: options2 } = descriptor2;
      const entry = [target, descriptor2];
      target.addEventListener(type, listener, options2);
      this.entries.add(entry);
      entries.push(entry);
    }
    return function cleanup() {
      for (const [target2, { type, listener, options: options2 }] of entries) {
        target2.removeEventListener(type, listener, options2);
      }
    };
  }
};
function getFrameElement(el) {
  const refWindow = el == null ? void 0 : el.ownerDocument.defaultView;
  if (refWindow && refWindow.self !== refWindow.parent) {
    return refWindow.frameElement;
  }
}
function getFrameElements(el) {
  const frames = /* @__PURE__ */ new Set();
  let frame = getFrameElement(el);
  while (frame) {
    frames.add(frame);
    frame = getFrameElement(frame);
  }
  return frames;
}
function timeout(callback, duration) {
  const id = setTimeout(callback, duration);
  return () => clearTimeout(id);
}
function throttle(func, limit) {
  const time = () => performance.now();
  let cancel;
  let lastRan;
  return function(...args) {
    const context = this;
    if (!lastRan) {
      func.apply(context, args);
      lastRan = time();
    } else {
      cancel == null ? void 0 : cancel();
      cancel = timeout(
        () => {
          func.apply(context, args);
          lastRan = time();
        },
        limit - (time() - lastRan)
      );
    }
  };
}
function isRectEqual(a2, b2) {
  if (a2 === b2) return true;
  if (!a2 || !b2) return false;
  return a2.top == b2.top && a2.left == b2.left && a2.right == b2.right && a2.bottom == b2.bottom;
}
function isVisible(element, boundingClientRect = element.getBoundingClientRect()) {
  const { width, height } = getVisibleBoundingRectangle(
    element,
    boundingClientRect
  );
  return width > 0 && height > 0;
}
var Observer = canUseDOM ? ResizeObserver : class MockResizeObserver {
  observe() {
  }
  unobserve() {
  }
  disconnect() {
  }
};
var _initialized;
var ResizeNotifier = class extends Observer {
  constructor(callback) {
    super((entries) => {
      if (!__privateGet4(this, _initialized)) {
        __privateSet4(this, _initialized, true);
        return;
      }
      callback(entries, this);
    });
    __privateAdd4(this, _initialized, false);
  }
};
_initialized = /* @__PURE__ */ new WeakMap();
var threshold = Array.from({ length: 100 }, (_2, index) => index / 100);
var THROTTLE_INTERVAL = 75;
var _visible;
var _previousBoundingClientRect;
var _resizeObserver;
var _positionObserver;
var _visibilityObserver;
var _debug;
var _disconnected;
var _observePosition;
var _PositionObserver_instances;
var notify_fn;
var updateDebug_fn;
var PositionObserver = class {
  constructor(element, callback, options2 = {
    debug: false,
    skipInitial: false
  }) {
    this.element = element;
    this.callback = callback;
    __privateAdd4(this, _PositionObserver_instances);
    this.disconnect = () => {
      var _a5, _b3, _c4;
      __privateSet4(this, _disconnected, true);
      (_a5 = __privateGet4(this, _resizeObserver)) == null ? void 0 : _a5.disconnect();
      (_b3 = __privateGet4(this, _positionObserver)) == null ? void 0 : _b3.disconnect();
      __privateGet4(this, _visibilityObserver).disconnect();
      (_c4 = __privateGet4(this, _debug)) == null ? void 0 : _c4.remove();
    };
    __privateAdd4(this, _visible, true);
    __privateAdd4(this, _previousBoundingClientRect);
    __privateAdd4(this, _resizeObserver);
    __privateAdd4(this, _positionObserver);
    __privateAdd4(this, _visibilityObserver);
    __privateAdd4(this, _debug);
    __privateAdd4(this, _disconnected, false);
    __privateAdd4(this, _observePosition, throttle(() => {
      var _a5, _b3, _c4;
      const { element: element2 } = this;
      (_a5 = __privateGet4(this, _positionObserver)) == null ? void 0 : _a5.disconnect();
      if (__privateGet4(this, _disconnected) || !__privateGet4(this, _visible) || !element2.isConnected) {
        return;
      }
      const root2 = (_b3 = element2.ownerDocument) != null ? _b3 : document;
      const { innerHeight, innerWidth } = (_c4 = root2.defaultView) != null ? _c4 : window;
      const clientRect = element2.getBoundingClientRect();
      const visibleRect = getVisibleBoundingRectangle(element2, clientRect);
      const { top, left, bottom, right } = visibleRect;
      const insetTop = -Math.floor(top);
      const insetLeft = -Math.floor(left);
      const insetRight = -Math.floor(innerWidth - right);
      const insetBottom = -Math.floor(innerHeight - bottom);
      const rootMargin = `${insetTop}px ${insetRight}px ${insetBottom}px ${insetLeft}px`;
      this.boundingClientRect = clientRect;
      __privateSet4(this, _positionObserver, new IntersectionObserver(
        (entries) => {
          const [entry] = entries;
          const { intersectionRect } = entry;
          const intersectionRatio = entry.intersectionRatio !== 1 ? entry.intersectionRatio : Rectangle.intersectionRatio(
            intersectionRect,
            getVisibleBoundingRectangle(element2)
          );
          if (intersectionRatio !== 1) {
            __privateGet4(this, _observePosition).call(this);
          }
        },
        {
          threshold,
          rootMargin,
          root: root2
        }
      ));
      __privateGet4(this, _positionObserver).observe(element2);
      __privateMethod4(this, _PositionObserver_instances, notify_fn).call(this);
    }, THROTTLE_INTERVAL));
    this.boundingClientRect = element.getBoundingClientRect();
    __privateSet4(this, _visible, isVisible(element, this.boundingClientRect));
    let initial = true;
    this.callback = (boundingClientRect) => {
      if (initial) {
        initial = false;
        if (options2.skipInitial) return;
      }
      callback(boundingClientRect);
    };
    const root = element.ownerDocument;
    if (options2 == null ? void 0 : options2.debug) {
      __privateSet4(this, _debug, document.createElement("div"));
      __privateGet4(this, _debug).style.background = "rgba(0,0,0,0.15)";
      __privateGet4(this, _debug).style.position = "fixed";
      __privateGet4(this, _debug).style.pointerEvents = "none";
      root.body.appendChild(__privateGet4(this, _debug));
    }
    __privateSet4(this, _visibilityObserver, new IntersectionObserver(
      (entries) => {
        var _a5, _b3;
        const entry = entries[entries.length - 1];
        const { boundingClientRect, isIntersecting: visible } = entry;
        const { width, height } = boundingClientRect;
        const previousVisible = __privateGet4(this, _visible);
        __privateSet4(this, _visible, visible);
        if (!width && !height) return;
        if (previousVisible && !visible) {
          (_a5 = __privateGet4(this, _positionObserver)) == null ? void 0 : _a5.disconnect();
          this.callback(null);
          (_b3 = __privateGet4(this, _resizeObserver)) == null ? void 0 : _b3.disconnect();
          __privateSet4(this, _resizeObserver, void 0);
          if (__privateGet4(this, _debug)) __privateGet4(this, _debug).style.visibility = "hidden";
        } else {
          __privateGet4(this, _observePosition).call(this);
        }
        if (visible && !__privateGet4(this, _resizeObserver)) {
          __privateSet4(this, _resizeObserver, new ResizeNotifier(__privateGet4(this, _observePosition)));
          __privateGet4(this, _resizeObserver).observe(element);
        }
      },
      {
        threshold,
        root
      }
    ));
    if (__privateGet4(this, _visible) && !options2.skipInitial) {
      this.callback(this.boundingClientRect);
    }
    __privateGet4(this, _visibilityObserver).observe(element);
  }
};
_visible = /* @__PURE__ */ new WeakMap();
_previousBoundingClientRect = /* @__PURE__ */ new WeakMap();
_resizeObserver = /* @__PURE__ */ new WeakMap();
_positionObserver = /* @__PURE__ */ new WeakMap();
_visibilityObserver = /* @__PURE__ */ new WeakMap();
_debug = /* @__PURE__ */ new WeakMap();
_disconnected = /* @__PURE__ */ new WeakMap();
_observePosition = /* @__PURE__ */ new WeakMap();
_PositionObserver_instances = /* @__PURE__ */ new WeakSet();
notify_fn = function() {
  if (__privateGet4(this, _disconnected)) return;
  __privateMethod4(this, _PositionObserver_instances, updateDebug_fn).call(this);
  if (isRectEqual(this.boundingClientRect, __privateGet4(this, _previousBoundingClientRect)))
    return;
  this.callback(this.boundingClientRect);
  __privateSet4(this, _previousBoundingClientRect, this.boundingClientRect);
};
updateDebug_fn = function() {
  if (__privateGet4(this, _debug)) {
    const { top, left, width, height } = getVisibleBoundingRectangle(
      this.element
    );
    __privateGet4(this, _debug).style.overflow = "hidden";
    __privateGet4(this, _debug).style.visibility = "visible";
    __privateGet4(this, _debug).style.top = `${Math.floor(top)}px`;
    __privateGet4(this, _debug).style.left = `${Math.floor(left)}px`;
    __privateGet4(this, _debug).style.width = `${Math.floor(width)}px`;
    __privateGet4(this, _debug).style.height = `${Math.floor(height)}px`;
  }
};
var framePositionObservers = /* @__PURE__ */ new WeakMap();
var scrollListeners = /* @__PURE__ */ new WeakMap();
function addFrameListener(frame, callback) {
  let cached = framePositionObservers.get(frame);
  if (!cached) {
    const observer = new PositionObserver(
      frame,
      (boundingClientRect) => {
        const cached2 = framePositionObservers.get(frame);
        if (!cached2) return;
        cached2.callbacks.forEach((callback2) => callback2(boundingClientRect));
      },
      { skipInitial: true }
    );
    cached = { disconnect: observer.disconnect, callbacks: /* @__PURE__ */ new Set() };
  }
  cached.callbacks.add(callback);
  framePositionObservers.set(frame, cached);
  return () => {
    cached.callbacks.delete(callback);
    if (cached.callbacks.size === 0) {
      framePositionObservers.delete(frame);
      cached.disconnect();
    }
  };
}
function observeParentFrames(frames, callback) {
  const cleanup = /* @__PURE__ */ new Set();
  for (const frame of frames) {
    const remove = addFrameListener(frame, callback);
    cleanup.add(remove);
  }
  return () => cleanup.forEach((remove) => remove());
}
function addScrollListener(element, callback) {
  var _a5;
  const doc = element.ownerDocument;
  if (!scrollListeners.has(doc)) {
    const controller = new AbortController();
    const listeners2 = /* @__PURE__ */ new Set();
    document.addEventListener(
      "scroll",
      (event) => listeners2.forEach((listener) => listener(event)),
      {
        capture: true,
        passive: true,
        signal: controller.signal
      }
    );
    scrollListeners.set(doc, { disconnect: () => controller.abort(), listeners: listeners2 });
  }
  const { listeners, disconnect } = (_a5 = scrollListeners.get(doc)) != null ? _a5 : {};
  if (!listeners || !disconnect) return () => {
  };
  listeners.add(callback);
  return () => {
    listeners.delete(callback);
    if (listeners.size === 0) {
      disconnect();
      scrollListeners.delete(doc);
    }
  };
}
var _elementObserver;
var _disconnected2;
var _frames;
var _handleScroll;
var FrameObserver = class {
  constructor(element, callback, options2) {
    this.callback = callback;
    __privateAdd4(this, _elementObserver);
    __privateAdd4(this, _disconnected2, false);
    __privateAdd4(this, _frames);
    __privateAdd4(this, _handleScroll, throttle((event) => {
      if (__privateGet4(this, _disconnected2)) return;
      if (!event.target) return;
      if ("contains" in event.target && typeof event.target.contains === "function") {
        for (const frame of __privateGet4(this, _frames)) {
          if (event.target.contains(frame)) {
            this.callback(__privateGet4(this, _elementObserver).boundingClientRect);
            break;
          }
        }
      }
    }, THROTTLE_INTERVAL));
    const frames = getFrameElements(element);
    const unobserveParentFrames = observeParentFrames(frames, callback);
    const removeScrollListener = addScrollListener(element, __privateGet4(this, _handleScroll));
    __privateSet4(this, _frames, frames);
    __privateSet4(this, _elementObserver, new PositionObserver(element, callback, options2));
    this.disconnect = () => {
      if (__privateGet4(this, _disconnected2)) return;
      __privateSet4(this, _disconnected2, true);
      unobserveParentFrames();
      removeScrollListener();
      __privateGet4(this, _elementObserver).disconnect();
    };
  }
};
_elementObserver = /* @__PURE__ */ new WeakMap();
_disconnected2 = /* @__PURE__ */ new WeakMap();
_frames = /* @__PURE__ */ new WeakMap();
_handleScroll = /* @__PURE__ */ new WeakMap();
function supportsPopover(element) {
  return "showPopover" in element && "hidePopover" in element && typeof element.showPopover === "function" && typeof element.hidePopover === "function";
}
function showPopover(element) {
  try {
    if (supportsPopover(element) && element.isConnected && element.hasAttribute("popover") && // This selector can throw an error in browsers that don't support it
    !element.matches(":popover-open")) {
      element.showPopover();
    }
  } catch (error) {
  }
}
function isDocumentScrollingElement(element) {
  if (!canUseDOM || !element) {
    return false;
  }
  return element === getDocument(element).scrollingElement;
}
function getScrollPosition(scrollableElement) {
  const window2 = getWindow(scrollableElement);
  const rect = isDocumentScrollingElement(scrollableElement) ? getViewportBoundingRectangle(scrollableElement) : getBoundingRectangle(scrollableElement);
  const dimensions = isDocumentScrollingElement(scrollableElement) ? {
    height: window2.innerHeight,
    width: window2.innerWidth
  } : {
    height: scrollableElement.clientHeight,
    width: scrollableElement.clientWidth
  };
  const position = {
    current: {
      x: scrollableElement.scrollLeft,
      y: scrollableElement.scrollTop
    },
    max: {
      x: scrollableElement.scrollWidth - dimensions.width,
      y: scrollableElement.scrollHeight - dimensions.height
    }
  };
  const isTop = position.current.y <= 0;
  const isLeft = position.current.x <= 0;
  const isBottom = position.current.y >= position.max.y;
  const isRight = position.current.x >= position.max.x;
  return {
    rect,
    position,
    isTop,
    isLeft,
    isBottom,
    isRight
  };
}
function canScroll(scrollableElement, by) {
  const { isTop, isBottom, isLeft, isRight, position } = getScrollPosition(scrollableElement);
  const { x, y: y2 } = by != null ? by : { x: 0, y: 0 };
  const top = !isTop && position.current.y + y2 > 0;
  const bottom = !isBottom && position.current.y + y2 < position.max.y;
  const left = !isLeft && position.current.x + x > 0;
  const right = !isRight && position.current.x + x < position.max.x;
  return {
    top,
    bottom,
    left,
    right,
    x: left || right,
    y: top || bottom
  };
}
var Scheduler = class {
  constructor(scheduler4) {
    this.scheduler = scheduler4;
    this.pending = false;
    this.tasks = /* @__PURE__ */ new Set();
    this.resolvers = /* @__PURE__ */ new Set();
    this.flush = () => {
      const { tasks, resolvers } = this;
      this.pending = false;
      this.tasks = /* @__PURE__ */ new Set();
      this.resolvers = /* @__PURE__ */ new Set();
      for (const task of tasks) {
        task();
      }
      for (const resolve of resolvers) {
        resolve();
      }
    };
  }
  schedule(task) {
    this.tasks.add(task);
    if (!this.pending) {
      this.pending = true;
      this.scheduler(this.flush);
    }
    return new Promise((resolve) => this.resolvers.add(resolve));
  }
};
var scheduler = new Scheduler((callback) => {
  if (typeof requestAnimationFrame === "function") {
    requestAnimationFrame(callback);
  } else {
    callback();
  }
});
var scheduler2 = new Scheduler((callback) => setTimeout(callback, 50));
var cachedStyles = /* @__PURE__ */ new Map();
var clear = cachedStyles.clear.bind(cachedStyles);
function getComputedStyles(element, cached = false) {
  if (!cached) return computeStyles(element);
  let styles2 = cachedStyles.get(element);
  if (styles2) return styles2;
  styles2 = computeStyles(element);
  cachedStyles.set(element, styles2);
  scheduler2.schedule(clear);
  return styles2;
}
function computeStyles(element) {
  return getWindow(element).getComputedStyle(element);
}
function isFixed(node, computedStyle = getComputedStyles(node, true)) {
  return computedStyle.position === "fixed" || computedStyle.position === "sticky";
}
function isScrollable(element, computedStyle = getComputedStyles(element, true)) {
  const overflowRegex = /(auto|scroll|overlay)/;
  const properties = ["overflow", "overflowX", "overflowY"];
  return properties.some((property) => {
    const value = computedStyle[property];
    return typeof value === "string" ? overflowRegex.test(value) : false;
  });
}
var defaultOptions = {
  excludeElement: true
};
function getScrollableAncestors(element, options2 = defaultOptions) {
  const { limit, excludeElement } = options2;
  const scrollParents = /* @__PURE__ */ new Set();
  function findScrollableAncestors(node) {
    if (limit != null && scrollParents.size >= limit) {
      return scrollParents;
    }
    if (!node) {
      return scrollParents;
    }
    if (isDocument(node) && node.scrollingElement != null && !scrollParents.has(node.scrollingElement)) {
      scrollParents.add(node.scrollingElement);
      return scrollParents;
    }
    if (!isHTMLElement(node)) {
      if (isSVGElement(node)) {
        return findScrollableAncestors(node.parentElement);
      }
      return scrollParents;
    }
    if (scrollParents.has(node)) {
      return scrollParents;
    }
    const computedStyle = getComputedStyles(node, true);
    if (excludeElement && node === element) ;
    else if (isScrollable(node, computedStyle)) {
      scrollParents.add(node);
    }
    if (isFixed(node, computedStyle)) {
      const { scrollingElement } = node.ownerDocument;
      if (scrollingElement) scrollParents.add(scrollingElement);
      return scrollParents;
    }
    return findScrollableAncestors(node.parentNode);
  }
  if (!element) {
    return scrollParents;
  }
  return findScrollableAncestors(element);
}
function getFirstScrollableAncestor(node) {
  const [firstScrollableAncestor] = getScrollableAncestors(node, { limit: 1 });
  return firstScrollableAncestor != null ? firstScrollableAncestor : null;
}
function getFrameTransform(el, boundary = window.frameElement) {
  const transform = {
    x: 0,
    y: 0,
    scaleX: 1,
    scaleY: 1
  };
  if (!el) return transform;
  let frame = getFrameElement(el);
  while (frame) {
    if (frame === boundary) {
      return transform;
    }
    const rect = getBoundingRectangle(frame);
    const { x: scaleX, y: scaleY } = getScale(frame, rect);
    transform.x = transform.x + rect.left;
    transform.y = transform.y + rect.top;
    transform.scaleX = transform.scaleX * scaleX;
    transform.scaleY = transform.scaleY * scaleY;
    frame = getFrameElement(frame);
  }
  return transform;
}
function getScale(element, boundingRectangle = getBoundingRectangle(element)) {
  const width = Math.round(boundingRectangle.width);
  const height = Math.round(boundingRectangle.height);
  if (isHTMLElement(element)) {
    return {
      x: width / element.offsetWidth,
      y: height / element.offsetHeight
    };
  }
  const styles2 = getComputedStyles(element, true);
  return {
    x: (parseFloat(styles2.width) || width) / width,
    y: (parseFloat(styles2.height) || height) / height
  };
}
function parseScale(scale) {
  if (scale === "none") {
    return null;
  }
  const values = scale.split(" ");
  const x = parseFloat(values[0]);
  const y2 = parseFloat(values[1]);
  if (isNaN(x) && isNaN(y2)) {
    return null;
  }
  return {
    x: isNaN(x) ? y2 : x,
    y: isNaN(y2) ? x : y2
  };
}
function parseTranslate(translate) {
  if (translate === "none") {
    return null;
  }
  const [x, y2, z = "0"] = translate.split(" ");
  const output = { x: parseFloat(x), y: parseFloat(y2), z: parseInt(z, 10) };
  if (isNaN(output.x) && isNaN(output.y)) {
    return null;
  }
  return {
    x: isNaN(output.x) ? 0 : output.x,
    y: isNaN(output.y) ? 0 : output.y,
    z: isNaN(output.z) ? 0 : output.z
  };
}
function parseTransform(computedStyles) {
  var _a5, _b3, _c4, _d2, _e, _f, _g, _h, _i;
  const { scale, transform, translate } = computedStyles;
  const parsedScale = parseScale(scale);
  const parsedTranslate = parseTranslate(translate);
  const parsedMatrix = parseTransformMatrix(transform);
  if (!parsedMatrix && !parsedScale && !parsedTranslate) {
    return null;
  }
  const normalizedScale = {
    x: (_a5 = parsedScale == null ? void 0 : parsedScale.x) != null ? _a5 : 1,
    y: (_b3 = parsedScale == null ? void 0 : parsedScale.y) != null ? _b3 : 1
  };
  const normalizedTranslate = {
    x: (_c4 = parsedTranslate == null ? void 0 : parsedTranslate.x) != null ? _c4 : 0,
    y: (_d2 = parsedTranslate == null ? void 0 : parsedTranslate.y) != null ? _d2 : 0
  };
  const normalizedMatrix = {
    x: (_e = parsedMatrix == null ? void 0 : parsedMatrix.x) != null ? _e : 0,
    y: (_f = parsedMatrix == null ? void 0 : parsedMatrix.y) != null ? _f : 0,
    scaleX: (_g = parsedMatrix == null ? void 0 : parsedMatrix.scaleX) != null ? _g : 1,
    scaleY: (_h = parsedMatrix == null ? void 0 : parsedMatrix.scaleY) != null ? _h : 1
  };
  return {
    x: normalizedTranslate.x + normalizedMatrix.x,
    y: normalizedTranslate.y + normalizedMatrix.y,
    z: (_i = parsedTranslate == null ? void 0 : parsedTranslate.z) != null ? _i : 0,
    scaleX: normalizedScale.x * normalizedMatrix.scaleX,
    scaleY: normalizedScale.y * normalizedMatrix.scaleY
  };
}
function parseTransformMatrix(transform) {
  if (transform.startsWith("matrix3d(")) {
    const transformArray = transform.slice(9, -1).split(/, /);
    return {
      x: +transformArray[12],
      y: +transformArray[13],
      scaleX: +transformArray[0],
      scaleY: +transformArray[5]
    };
  } else if (transform.startsWith("matrix(")) {
    const transformArray = transform.slice(7, -1).split(/, /);
    return {
      x: +transformArray[4],
      y: +transformArray[5],
      scaleX: +transformArray[0],
      scaleY: +transformArray[3]
    };
  }
  return null;
}
var ScrollDirection = ((ScrollDirection2) => {
  ScrollDirection2[ScrollDirection2["Idle"] = 0] = "Idle";
  ScrollDirection2[ScrollDirection2["Forward"] = 1] = "Forward";
  ScrollDirection2[ScrollDirection2["Reverse"] = -1] = "Reverse";
  return ScrollDirection2;
})(ScrollDirection || {});
var defaultThreshold = {
  x: 0.2,
  y: 0.2
};
var defaultTolerance = {
  x: 10,
  y: 10
};
function detectScrollIntent(scrollableElement, coordinates, intent, acceleration = 25, thresholdPercentage = defaultThreshold, tolerance = defaultTolerance) {
  const { x, y: y2 } = coordinates;
  const { rect, isTop, isBottom, isLeft, isRight } = getScrollPosition(scrollableElement);
  const frameTransform = getFrameTransform(scrollableElement);
  const computedStyles = getComputedStyles(scrollableElement, true);
  const parsedTransform = parseTransform(computedStyles);
  const isXAxisInverted = parsedTransform !== null ? (parsedTransform == null ? void 0 : parsedTransform.scaleX) < 0 : false;
  const isYAxisInverted = parsedTransform !== null ? (parsedTransform == null ? void 0 : parsedTransform.scaleY) < 0 : false;
  const scrollContainerRect = new Rectangle(
    rect.left * frameTransform.scaleX + frameTransform.x,
    rect.top * frameTransform.scaleY + frameTransform.y,
    rect.width * frameTransform.scaleX,
    rect.height * frameTransform.scaleY
  );
  const direction = {
    x: 0,
    y: 0
    /* Idle */
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold2 = {
    height: scrollContainerRect.height * thresholdPercentage.y,
    width: scrollContainerRect.width * thresholdPercentage.x
  };
  if ((!isTop || isYAxisInverted && !isBottom) && y2 <= scrollContainerRect.top + threshold2.height && (intent == null ? void 0 : intent.y) !== 1 && x >= scrollContainerRect.left - tolerance.x && x <= scrollContainerRect.right + tolerance.x) {
    direction.y = isYAxisInverted ? 1 : -1;
    speed.y = acceleration * Math.abs(
      (scrollContainerRect.top + threshold2.height - y2) / threshold2.height
    );
  } else if ((!isBottom || isYAxisInverted && !isTop) && y2 >= scrollContainerRect.bottom - threshold2.height && (intent == null ? void 0 : intent.y) !== -1 && x >= scrollContainerRect.left - tolerance.x && x <= scrollContainerRect.right + tolerance.x) {
    direction.y = isYAxisInverted ? -1 : 1;
    speed.y = acceleration * Math.abs(
      (scrollContainerRect.bottom - threshold2.height - y2) / threshold2.height
    );
  }
  if ((!isRight || isXAxisInverted && !isLeft) && x >= scrollContainerRect.right - threshold2.width && (intent == null ? void 0 : intent.x) !== -1 && y2 >= scrollContainerRect.top - tolerance.y && y2 <= scrollContainerRect.bottom + tolerance.y) {
    direction.x = isXAxisInverted ? -1 : 1;
    speed.x = acceleration * Math.abs(
      (scrollContainerRect.right - threshold2.width - x) / threshold2.width
    );
  } else if ((!isLeft || isXAxisInverted && !isRight) && x <= scrollContainerRect.left + threshold2.width && (intent == null ? void 0 : intent.x) !== 1 && y2 >= scrollContainerRect.top - tolerance.y && y2 <= scrollContainerRect.bottom + tolerance.y) {
    direction.x = isXAxisInverted ? 1 : -1;
    speed.x = acceleration * Math.abs(
      (scrollContainerRect.left + threshold2.width - x) / threshold2.width
    );
  }
  return {
    direction,
    speed
  };
}
function supportsScrollIntoViewIfNeeded(element) {
  return "scrollIntoViewIfNeeded" in element && typeof element.scrollIntoViewIfNeeded === "function";
}
function scrollIntoViewIfNeeded(el, centerIfNeeded = false) {
  if (supportsScrollIntoViewIfNeeded(el)) {
    el.scrollIntoViewIfNeeded(centerIfNeeded);
    return;
  }
  if (!isHTMLElement(el)) {
    return el.scrollIntoView();
  }
  var parent = getFirstScrollableAncestor(el);
  if (!isHTMLElement(parent)) {
    return;
  }
  const parentComputedStyle = getComputedStyles(parent, true), parentBorderTopWidth = parseInt(
    parentComputedStyle.getPropertyValue("border-top-width")
  ), parentBorderLeftWidth = parseInt(
    parentComputedStyle.getPropertyValue("border-left-width")
  ), overTop = el.offsetTop - parent.offsetTop < parent.scrollTop, overBottom = el.offsetTop - parent.offsetTop + el.clientHeight - parentBorderTopWidth > parent.scrollTop + parent.clientHeight, overLeft = el.offsetLeft - parent.offsetLeft < parent.scrollLeft, overRight = el.offsetLeft - parent.offsetLeft + el.clientWidth - parentBorderLeftWidth > parent.scrollLeft + parent.clientWidth, alignWithTop = overTop && !overBottom;
  if ((overTop || overBottom) && centerIfNeeded) {
    parent.scrollTop = el.offsetTop - parent.offsetTop - parent.clientHeight / 2 - parentBorderTopWidth + el.clientHeight / 2;
  }
  if ((overLeft || overRight) && centerIfNeeded) {
    parent.scrollLeft = el.offsetLeft - parent.offsetLeft - parent.clientWidth / 2 - parentBorderLeftWidth + el.clientWidth / 2;
  }
  if ((overTop || overBottom || overLeft || overRight) && !centerIfNeeded) {
    el.scrollIntoView(alignWithTop);
  }
}
function applyTransform(rect, parsedTransform, transformOrigin) {
  const { scaleX, scaleY, x: translateX, y: translateY } = parsedTransform;
  const x = rect.left + translateX + (1 - scaleX) * parseFloat(transformOrigin);
  const y2 = rect.top + translateY + (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
  const w2 = scaleX ? rect.width * scaleX : rect.width;
  const h2 = scaleY ? rect.height * scaleY : rect.height;
  return {
    width: w2,
    height: h2,
    top: y2,
    right: x + w2,
    bottom: y2 + h2,
    left: x
  };
}
function inverseTransform(rect, parsedTransform, transformOrigin) {
  const { scaleX, scaleY, x: translateX, y: translateY } = parsedTransform;
  const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);
  const y2 = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
  const w2 = scaleX ? rect.width / scaleX : rect.width;
  const h2 = scaleY ? rect.height / scaleY : rect.height;
  return {
    width: w2,
    height: h2,
    top: y2,
    right: x + w2,
    bottom: y2 + h2,
    left: x
  };
}
function animateTransform({ element, keyframes, options: options2 }) {
  return element.animate(keyframes, options2).finished;
}
function computeTranslate(element, translate = getComputedStyles(element).translate, projected = true) {
  if (projected) {
    const keyframe = getFinalKeyframe(
      element,
      (keyframe2) => "translate" in keyframe2
    );
    if (keyframe) {
      const { translate: translate2 = "" } = keyframe[0];
      if (typeof translate2 === "string") {
        const finalTranslate = parseTranslate(translate2);
        if (finalTranslate) {
          return finalTranslate;
        }
      }
    }
  }
  if (translate) {
    const finalTranslate = parseTranslate(translate);
    if (finalTranslate) {
      return finalTranslate;
    }
  }
  return { x: 0, y: 0, z: 0 };
}
var scheduler3 = new Scheduler((callback) => setTimeout(callback, 0));
var animations = /* @__PURE__ */ new Map();
var clear2 = animations.clear.bind(animations);
function getDocumentAnimations(element) {
  const document2 = element.ownerDocument;
  let documentAnimations = animations.get(document2);
  if (documentAnimations) return documentAnimations;
  documentAnimations = document2.getAnimations();
  animations.set(document2, documentAnimations);
  scheduler3.schedule(clear2);
  const elementAnimations = documentAnimations.filter(
    (animation) => isKeyframeEffect(animation.effect) && animation.effect.target === element
  );
  animations.set(element, elementAnimations);
  return documentAnimations;
}
function forceFinishAnimations(element, options2) {
  const animations2 = getDocumentAnimations(element).filter((animation) => {
    var _a5, _b3;
    if (isKeyframeEffect(animation.effect)) {
      const { target } = animation.effect;
      const isValidTarget = (_b3 = target && ((_a5 = options2.isValidTarget) == null ? void 0 : _a5.call(options2, target))) != null ? _b3 : true;
      if (isValidTarget) {
        return animation.effect.getKeyframes().some((keyframe) => {
          for (const property of options2.properties) {
            if (keyframe[property]) return true;
          }
        });
      }
    }
  }).map((animation) => {
    const { effect, currentTime } = animation;
    const duration = effect == null ? void 0 : effect.getComputedTiming().duration;
    if (animation.pending || animation.playState === "finished") return;
    if (typeof duration == "number" && typeof currentTime == "number" && currentTime < duration) {
      animation.currentTime = duration;
      return () => {
        animation.currentTime = currentTime;
      };
    }
  });
  if (animations2.length > 0) {
    return () => animations2.forEach((reset) => reset == null ? void 0 : reset());
  }
}
var DOMRectangle = class extends Rectangle {
  constructor(element, options2 = {}) {
    var _a5, _b3, _c4, _d2;
    const {
      frameTransform = getFrameTransform(element),
      ignoreTransforms,
      getBoundingClientRect = getBoundingRectangle
    } = options2;
    const resetAnimations = forceFinishAnimations(element, {
      properties: ["transform", "translate", "scale", "width", "height"],
      isValidTarget: (target) => (target !== element || isSafari()) && target.contains(element)
    });
    const boundingRectangle = getBoundingClientRect(element);
    let { top, left, width, height } = boundingRectangle;
    let updated;
    const computedStyles = getComputedStyles(element);
    const parsedTransform = parseTransform(computedStyles);
    const scale = {
      x: (_a5 = parsedTransform == null ? void 0 : parsedTransform.scaleX) != null ? _a5 : 1,
      y: (_b3 = parsedTransform == null ? void 0 : parsedTransform.scaleY) != null ? _b3 : 1
    };
    const projectedTransform = getProjectedTransform(element, computedStyles);
    resetAnimations == null ? void 0 : resetAnimations();
    if (parsedTransform) {
      updated = inverseTransform(
        boundingRectangle,
        parsedTransform,
        computedStyles.transformOrigin
      );
      if (ignoreTransforms || projectedTransform) {
        top = updated.top;
        left = updated.left;
        width = updated.width;
        height = updated.height;
      }
    }
    const intrinsic = {
      width: (_c4 = updated == null ? void 0 : updated.width) != null ? _c4 : width,
      height: (_d2 = updated == null ? void 0 : updated.height) != null ? _d2 : height
    };
    if (projectedTransform && !ignoreTransforms && updated) {
      const projected = applyTransform(
        updated,
        projectedTransform,
        computedStyles.transformOrigin
      );
      top = projected.top;
      left = projected.left;
      width = projected.width;
      height = projected.height;
      scale.x = projectedTransform.scaleX;
      scale.y = projectedTransform.scaleY;
    }
    if (frameTransform) {
      if (!ignoreTransforms) {
        left *= frameTransform.scaleX;
        width *= frameTransform.scaleX;
        top *= frameTransform.scaleY;
        height *= frameTransform.scaleY;
      }
      left += frameTransform.x;
      top += frameTransform.y;
    }
    super(left, top, width, height);
    this.scale = scale;
    this.intrinsicWidth = intrinsic.width;
    this.intrinsicHeight = intrinsic.height;
  }
};
function getProjectedTransform(element, computedStyles) {
  var _a5;
  const animations2 = element.getAnimations();
  let projectedTransform = null;
  if (!animations2.length) return null;
  for (const animation of animations2) {
    if (animation.playState !== "running") continue;
    const keyframes = isKeyframeEffect(animation.effect) ? animation.effect.getKeyframes() : [];
    const keyframe = keyframes[keyframes.length - 1];
    if (!keyframe) continue;
    const { transform, translate, scale } = keyframe;
    if (transform || translate || scale) {
      const parsedTransform = parseTransform({
        transform: typeof transform === "string" && transform ? transform : computedStyles.transform,
        translate: typeof translate === "string" && translate ? translate : computedStyles.translate,
        scale: typeof scale === "string" && scale ? scale : computedStyles.scale
      });
      if (parsedTransform) {
        projectedTransform = projectedTransform ? {
          x: projectedTransform.x + parsedTransform.x,
          y: projectedTransform.y + parsedTransform.y,
          z: (_a5 = projectedTransform.z) != null ? _a5 : parsedTransform.z,
          scaleX: projectedTransform.scaleX * parsedTransform.scaleX,
          scaleY: projectedTransform.scaleY * parsedTransform.scaleY
        } : parsedTransform;
      }
    }
  }
  return projectedTransform;
}
function supportsStyle(element) {
  return "style" in element && typeof element.style === "object" && element.style !== null && "setProperty" in element.style && "removeProperty" in element.style && typeof element.style.setProperty === "function" && typeof element.style.removeProperty === "function";
}
var Styles = class {
  constructor(element) {
    this.element = element;
    this.initial = /* @__PURE__ */ new Map();
  }
  set(properties, prefix = "") {
    const { element } = this;
    if (!supportsStyle(element)) {
      return;
    }
    for (const [key, value] of Object.entries(properties)) {
      const property = `${prefix}${key}`;
      if (!this.initial.has(property)) {
        this.initial.set(property, element.style.getPropertyValue(property));
      }
      element.style.setProperty(
        property,
        typeof value === "string" ? value : `${value}px`
      );
    }
  }
  remove(properties, prefix = "") {
    const { element } = this;
    if (!supportsStyle(element)) {
      return;
    }
    for (const key of properties) {
      const property = `${prefix}${key}`;
      element.style.removeProperty(property);
    }
  }
  reset() {
    const { element } = this;
    if (!supportsStyle(element)) {
      return;
    }
    for (const [key, value] of this.initial) {
      element.style.setProperty(key, value);
    }
    if (element.getAttribute("style") === "") {
      element.removeAttribute("style");
    }
  }
};
function isElement(target) {
  if (!target) return false;
  return target instanceof getWindow(target).Element || isNode(target) && target.nodeType === Node.ELEMENT_NODE;
}
function isKeyboardEvent(event) {
  if (!event) return false;
  const { KeyboardEvent } = getWindow(event.target);
  return event instanceof KeyboardEvent;
}
function isPointerEvent(event) {
  if (!event) return false;
  const { PointerEvent: PointerEvent2 } = getWindow(event.target);
  return event instanceof PointerEvent2;
}
function isTextInput(target) {
  if (!isElement(target)) return false;
  const { tagName } = target;
  return tagName === "INPUT" || tagName === "TEXTAREA" || isContentEditable(target);
}
function isContentEditable(element) {
  return element.hasAttribute("contenteditable") && element.getAttribute("contenteditable") !== "false";
}
var ids = {};
function generateUniqueId(prefix) {
  const id = ids[prefix] == null ? 0 : ids[prefix] + 1;
  ids[prefix] = id;
  return `${prefix}-${id}`;
}

// node_modules/@dnd-kit/collision/dist/index.js
var pointerIntersection = ({
  dragOperation,
  droppable
}) => {
  const pointerCoordinates = dragOperation.position.current;
  if (!pointerCoordinates) {
    return null;
  }
  const { id } = droppable;
  if (!droppable.shape) {
    return null;
  }
  if (droppable.shape.containsPoint(pointerCoordinates)) {
    const distance = Point.distance(droppable.shape.center, pointerCoordinates);
    return {
      id,
      value: 1 / distance,
      type: CollisionType.PointerIntersection,
      priority: CollisionPriority.High
    };
  }
  return null;
};
var shapeIntersection = ({
  dragOperation,
  droppable
}) => {
  const { shape } = dragOperation;
  if (!droppable.shape || !(shape == null ? void 0 : shape.current)) {
    return null;
  }
  const intersectionArea = shape.current.intersectionArea(droppable.shape);
  if (intersectionArea) {
    const { position } = dragOperation;
    const distance = Point.distance(droppable.shape.center, position.current);
    const intersectionRatio = intersectionArea / (shape.current.area + droppable.shape.area - intersectionArea);
    const value = intersectionRatio / distance;
    return {
      id: droppable.id,
      value,
      type: CollisionType.ShapeIntersection,
      priority: CollisionPriority.Normal
    };
  }
  return null;
};
var defaultCollisionDetection = (args) => {
  var _a5;
  return (_a5 = pointerIntersection(args)) != null ? _a5 : shapeIntersection(args);
};
var closestCorners = (input) => {
  const { dragOperation, droppable } = input;
  const { shape, position } = dragOperation;
  if (!droppable.shape) {
    return null;
  }
  const shapeCorners = shape ? Rectangle.from(shape.current.boundingRectangle).corners : void 0;
  const distance = Rectangle.from(
    droppable.shape.boundingRectangle
  ).corners.reduce(
    (acc, corner, index) => {
      var _a5;
      return acc + Point.distance(
        Point.from(corner),
        (_a5 = shapeCorners == null ? void 0 : shapeCorners[index]) != null ? _a5 : position.current
      );
    },
    0
  );
  const value = distance / 4;
  return {
    id: droppable.id,
    value: 1 / value,
    type: CollisionType.Collision,
    priority: CollisionPriority.Normal
  };
};

// node_modules/@dnd-kit/dom/index.js
var __create4 = Object.create;
var __defProp4 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __knownSymbol4 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp4.call(b2, prop))
      __defNormalProp4(a2, prop, b2[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b2)) {
      if (__propIsEnum4.call(b2, prop))
        __defNormalProp4(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps4 = (a2, b2) => __defProps3(a2, __getOwnPropDescs3(b2));
var __name4 = (target, value) => __defProp4(target, "name", { value, configurable: true });
var __objRest3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decoratorStart4 = (base) => {
  var _a42;
  return [, , , __create4((_a42 = base == null ? void 0 : base[__knownSymbol4("metadata")]) != null ? _a42 : null)];
};
var __decoratorStrings4 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn4 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError5("Function expected") : fn;
var __decoratorContext4 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings4[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError5("Already initialized") : fns.push(__expectFn4(fn || null)) });
var __decoratorMetadata4 = (array, target) => __defNormalProp4(target, __knownSymbol4("metadata"), array[3]);
var __runInitializers4 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n2 = fns && fns.length; i2 < n2; i2++) flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement4 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p2 = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s2 ? 1 : 2 : 0, key = __decoratorStrings4[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p2 && !s2 && (target = target.prototype), k < 5 && (k > 3 || !p2) && __getOwnPropDesc4(k < 4 ? target : { get [name]() {
    return __privateGet5(this, extra);
  }, set [name](x) {
    return __privateSet5(this, extra, x);
  } }, name));
  k ? p2 && k < 4 && __name4(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name4(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext4(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: p2 ? (x) => __privateIn4(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p2 ? (x) => (k ^ 1 ? __privateGet5 : __privateMethod5)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p2 ? (x, y2) => __privateSet5(x, target, y2, k ^ 4 ? extra : desc.set) : (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p2 ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn4(it) && (k > 4 ? initializers.unshift(it) : k ? p2 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError5("Object expected");
    else __expectFn4(fn = it.get) && (desc.get = fn), __expectFn4(fn = it.set) && (desc.set = fn), __expectFn4(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata4(array, target), desc && __defProp4(target, name, desc), p2 ? k ^ 4 ? extra : desc : target;
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateIn4 = (member, obj) => Object(obj) !== obj ? __typeError5('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet5 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value) => member.has(obj) ? __typeError5("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet5 = (obj, member, value, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod5 = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var defaultAttributes = {
  role: "button",
  roleDescription: "draggable"
};
var defaultDescriptionIdPrefix = `dnd-kit-description`;
var defaultAnnouncementIdPrefix = `dnd-kit-announcement`;
var defaultScreenReaderInstructions = {
  draggable: `To pick up a draggable item, press the space bar. While dragging, use the arrow keys to move the item in a given direction. Press space again to drop the item in its new position, or press escape to cancel.`
};
var defaultAnnouncements = {
  dragstart({ operation: { source } }) {
    if (!source) return;
    return `Picked up draggable item ${source.id}.`;
  },
  dragover({ operation: { source, target } }) {
    if (!source || source.id === (target == null ? void 0 : target.id)) return;
    if (target) {
      return `Draggable item ${source.id} was moved over droppable target ${target.id}.`;
    }
    return `Draggable item ${source.id} is no longer over a droppable target.`;
  },
  dragend({ operation: { source, target }, canceled }) {
    if (!source) return;
    if (canceled) {
      return `Dragging was cancelled. Draggable item ${source.id} was dropped.`;
    }
    if (target) {
      return `Draggable item ${source.id} was dropped over droppable target ${target.id}`;
    }
    return `Draggable item ${source.id} was dropped.`;
  }
};
function isFocusable(element) {
  const tagName = element.tagName.toLowerCase();
  return ["input", "select", "textarea", "a", "button"].includes(tagName);
}
function createHiddenText(id, value) {
  const element = document.createElement("div");
  element.id = id;
  element.style.setProperty("display", "none");
  element.textContent = value;
  return element;
}
function createLiveRegion(id) {
  const element = document.createElement("div");
  element.id = id;
  element.setAttribute("role", "status");
  element.setAttribute("aria-live", "polite");
  element.setAttribute("aria-atomic", "true");
  element.style.setProperty("position", "fixed");
  element.style.setProperty("width", "1px");
  element.style.setProperty("height", "1px");
  element.style.setProperty("margin", "-1px");
  element.style.setProperty("border", "0");
  element.style.setProperty("padding", "0");
  element.style.setProperty("overflow", "hidden");
  element.style.setProperty("clip", "rect(0 0 0 0)");
  element.style.setProperty("clip-path", "inset(100%)");
  element.style.setProperty("white-space", "nowrap");
  return element;
}
var debouncedEvents = ["dragover", "dragmove"];
var Accessibility = class extends Plugin {
  constructor(manager, options2) {
    super(manager);
    const {
      id,
      idPrefix: {
        description: descriptionPrefix = defaultDescriptionIdPrefix,
        announcement: announcementPrefix = defaultAnnouncementIdPrefix
      } = {},
      announcements = defaultAnnouncements,
      screenReaderInstructions = defaultScreenReaderInstructions,
      debounce: debounceMs = 500
    } = options2 != null ? options2 : {};
    const descriptionId = id ? `${descriptionPrefix}-${id}` : generateUniqueId(descriptionPrefix);
    const announcementId = id ? `${announcementPrefix}-${id}` : generateUniqueId(announcementPrefix);
    let hiddenTextElement;
    let liveRegionElement;
    let liveRegionTextNode;
    let latestAnnouncement;
    const updateAnnouncement = (value = latestAnnouncement) => {
      if (!liveRegionTextNode || !value) return;
      if ((liveRegionTextNode == null ? void 0 : liveRegionTextNode.nodeValue) !== value) {
        liveRegionTextNode.nodeValue = value;
      }
    };
    const scheduleUpdateAnnouncement = () => scheduler.schedule(updateAnnouncement);
    const debouncedUpdateAnnouncement = debounce(
      scheduleUpdateAnnouncement,
      debounceMs
    );
    const eventListeners = Object.entries(announcements).map(
      ([eventName, getAnnouncement]) => {
        return this.manager.monitor.addEventListener(
          eventName,
          (event, manager2) => {
            const element = liveRegionTextNode;
            if (!element) return;
            const announcement = getAnnouncement == null ? void 0 : getAnnouncement(event, manager2);
            if (announcement && element.nodeValue !== announcement) {
              latestAnnouncement = announcement;
              if (debouncedEvents.includes(eventName)) {
                debouncedUpdateAnnouncement();
              } else {
                scheduleUpdateAnnouncement();
                debouncedUpdateAnnouncement.cancel();
              }
            }
          }
        );
      }
    );
    const initialize = () => {
      let elements = [];
      if (!(hiddenTextElement == null ? void 0 : hiddenTextElement.isConnected)) {
        hiddenTextElement = createHiddenText(
          descriptionId,
          screenReaderInstructions.draggable
        );
        elements.push(hiddenTextElement);
      }
      if (!(liveRegionElement == null ? void 0 : liveRegionElement.isConnected)) {
        liveRegionElement = createLiveRegion(announcementId);
        liveRegionTextNode = document.createTextNode("");
        liveRegionElement.appendChild(liveRegionTextNode);
        elements.push(liveRegionElement);
      }
      if (elements.length > 0) {
        document.body.append(...elements);
      }
    };
    const mutations = /* @__PURE__ */ new Set();
    function executeMutations() {
      for (const operation of mutations) {
        operation();
      }
    }
    this.registerEffect(() => {
      var _a42;
      mutations.clear();
      for (const draggable of this.manager.registry.draggables.value) {
        const activator = (_a42 = draggable.handle) != null ? _a42 : draggable.element;
        if (activator) {
          if (!hiddenTextElement || !liveRegionElement) {
            mutations.add(initialize);
          }
          if ((!isFocusable(activator) || isSafari()) && !activator.hasAttribute("tabindex")) {
            mutations.add(() => activator.setAttribute("tabindex", "0"));
          }
          if (!activator.hasAttribute("role") && !(activator.tagName.toLowerCase() === "button")) {
            mutations.add(
              () => activator.setAttribute("role", defaultAttributes.role)
            );
          }
          if (!activator.hasAttribute("aria-roledescription")) {
            mutations.add(
              () => activator.setAttribute(
                "aria-roledescription",
                defaultAttributes.roleDescription
              )
            );
          }
          if (!activator.hasAttribute("aria-describedby")) {
            mutations.add(
              () => activator.setAttribute("aria-describedby", descriptionId)
            );
          }
          for (const key of ["aria-pressed", "aria-grabbed"]) {
            const value = String(draggable.isDragging);
            if (activator.getAttribute(key) !== value) {
              mutations.add(() => activator.setAttribute(key, value));
            }
          }
          const disabled = String(draggable.disabled);
          if (activator.getAttribute("aria-disabled") !== disabled) {
            mutations.add(
              () => activator.setAttribute("aria-disabled", disabled)
            );
          }
        }
      }
      if (mutations.size > 0) {
        scheduler.schedule(executeMutations);
      }
    });
    this.destroy = () => {
      super.destroy();
      hiddenTextElement == null ? void 0 : hiddenTextElement.remove();
      liveRegionElement == null ? void 0 : liveRegionElement.remove();
      eventListeners.forEach((unsubscribe) => unsubscribe());
    };
  }
};
function debounce(fn, wait) {
  let timeout3;
  const debounced = () => {
    clearTimeout(timeout3);
    timeout3 = setTimeout(fn, wait);
  };
  debounced.cancel = () => clearTimeout(timeout3);
  return debounced;
}
var Cursor = class extends Plugin {
  constructor(manager, options2) {
    super(manager, options2);
    this.manager = manager;
    const doc = computed(
      () => {
        var _a42;
        return getDocument((_a42 = this.manager.dragOperation.source) == null ? void 0 : _a42.element);
      }
    );
    this.destroy = m(() => {
      var _a42;
      const { dragOperation } = this.manager;
      const { cursor = "grabbing", nonce } = (_a42 = this.options) != null ? _a42 : {};
      if (dragOperation.status.initialized) {
        const document2 = doc.value;
        const style = document2.createElement("style");
        if (nonce) {
          style.setAttribute("nonce", nonce);
        }
        style.textContent = `* { cursor: ${cursor} !important; }`;
        document2.head.appendChild(style);
        return () => style.remove();
      }
    });
  }
};
var ATTR_PREFIX = "data-dnd-";
var DROPPING_ATTRIBUTE = `${ATTR_PREFIX}dropping`;
var CSS_PREFIX = "--dnd-";
var ATTRIBUTE = `${ATTR_PREFIX}dragging`;
var PLACEHOLDER_ATTRIBUTE = `${ATTR_PREFIX}placeholder`;
var IGNORED_ATTRIBUTES = [
  ATTRIBUTE,
  PLACEHOLDER_ATTRIBUTE,
  "popover",
  "aria-pressed",
  "aria-grabbing"
];
var IGNORED_STYLES = ["view-transition-name"];
var CSS_RULES = `
  :root [${ATTRIBUTE}] {
    position: fixed !important;
    pointer-events: none !important;
    touch-action: none;
    z-index: calc(infinity);
    will-change: translate;
    top: var(${CSS_PREFIX}top, 0px) !important;
    left: var(${CSS_PREFIX}left, 0px) !important;
    right: unset !important;
    bottom: unset !important;
    width: var(${CSS_PREFIX}width, auto);
    max-width: var(${CSS_PREFIX}width, auto);
    height: var(${CSS_PREFIX}height, auto);
    max-height: var(${CSS_PREFIX}height, auto);
    transition: var(${CSS_PREFIX}transition) !important;
  }

  :root [${PLACEHOLDER_ATTRIBUTE}] {
    transition: none;
  }

  :root [${PLACEHOLDER_ATTRIBUTE}='hidden'] {
    visibility: hidden;
  }

  [${ATTRIBUTE}] * {
    pointer-events: none !important;
  }

  [${ATTRIBUTE}]:not([${DROPPING_ATTRIBUTE}]) {
    translate: var(${CSS_PREFIX}translate) !important;
  }

  [${ATTRIBUTE}][style*='${CSS_PREFIX}scale'] {
    scale: var(${CSS_PREFIX}scale) !important;
    transform-origin: var(${CSS_PREFIX}transform-origin) !important;
  }

  @layer {
    :where([${ATTRIBUTE}][popover]) {
      overflow: visible;
      background: unset;
      border: unset;
      margin: unset;
      padding: unset;
      color: inherit;

      &:is(input, button) {
        border: revert;
        background: revert;
      }
    }
  }
  [${ATTRIBUTE}]::backdrop, [${ATTR_PREFIX}overlay]:not([${ATTRIBUTE}]) {
    display: none;
    visibility: hidden;
  }
`.replace(/\n+/g, " ").replace(/\s+/g, " ").trim();
function createPlaceholder(source, type = "hidden") {
  return o(() => {
    const { element, manager } = source;
    if (!element || !manager) return;
    const containedDroppables = findContainedDroppables(
      element,
      manager.registry.droppables
    );
    const cleanup = [];
    const placeholder = cloneElement(element);
    const { remove } = placeholder;
    proxyDroppableElements(containedDroppables, placeholder, cleanup);
    configurePlaceholder(placeholder, type);
    placeholder.remove = () => {
      cleanup.forEach((fn) => fn());
      remove.call(placeholder);
    };
    return placeholder;
  });
}
function findContainedDroppables(element, droppables) {
  const containedDroppables = /* @__PURE__ */ new Map();
  for (const droppable of droppables) {
    if (!droppable.element) continue;
    if (element === droppable.element || element.contains(droppable.element)) {
      const identifierAttribute = `${ATTR_PREFIX}${generateUniqueId("dom-id")}`;
      droppable.element.setAttribute(identifierAttribute, "");
      containedDroppables.set(droppable, identifierAttribute);
    }
  }
  return containedDroppables;
}
function proxyDroppableElements(containedDroppables, placeholder, cleanup) {
  for (const [droppable, identifierAttribute] of containedDroppables) {
    if (!droppable.element) continue;
    const selector = `[${identifierAttribute}]`;
    const clonedElement = placeholder.matches(selector) ? placeholder : placeholder.querySelector(selector);
    droppable.element.removeAttribute(identifierAttribute);
    if (!clonedElement) continue;
    const originalElement = droppable.element;
    droppable.proxy = clonedElement;
    clonedElement.removeAttribute(identifierAttribute);
    ProxiedElements.set(originalElement, clonedElement);
    cleanup.push(() => {
      ProxiedElements.delete(originalElement);
      droppable.proxy = void 0;
    });
  }
}
function configurePlaceholder(placeholder, type = "hidden") {
  placeholder.setAttribute("inert", "true");
  placeholder.setAttribute("tab-index", "-1");
  placeholder.setAttribute("aria-hidden", "true");
  placeholder.setAttribute(PLACEHOLDER_ATTRIBUTE, type);
}
function isSameFrame(element, target) {
  if (element === target) return true;
  return getFrameElement(element) === getFrameElement(target);
}
function preventPopoverClose(event) {
  const { target } = event;
  if ("newState" in event && event.newState === "closed" && isElement(target) && target.hasAttribute("popover")) {
    requestAnimationFrame(() => showPopover(target));
  }
}
function isTableRow(element) {
  return element.tagName === "TR";
}
var styleSheetRegistry = /* @__PURE__ */ new Map();
var _overlay_dec;
var _a3;
var _init7;
var _overlay;
var _Feedback_instances;
var render_fn;
var injectStyles_fn;
var _Feedback = class _Feedback2 extends (_a3 = Plugin, _overlay_dec = [reactive], _a3) {
  constructor(manager, options2) {
    super(manager, options2);
    __privateAdd5(this, _Feedback_instances);
    __privateAdd5(this, _overlay, __runInitializers4(_init7, 8, this)), __runInitializers4(_init7, 11, this);
    this.state = {
      initial: {},
      current: {}
    };
    this.registerEffect(__privateMethod5(this, _Feedback_instances, injectStyles_fn));
    this.registerEffect(__privateMethod5(this, _Feedback_instances, render_fn));
  }
  destroy() {
    super.destroy();
    for (const [doc, registration] of styleSheetRegistry.entries()) {
      if (registration.instances.has(this)) {
        registration.instances.delete(this);
        if (registration.instances.size === 0) {
          registration.cleanup();
          styleSheetRegistry.delete(doc);
        }
      }
    }
  }
};
_init7 = __decoratorStart4(_a3);
_overlay = /* @__PURE__ */ new WeakMap();
_Feedback_instances = /* @__PURE__ */ new WeakSet();
render_fn = function() {
  var _a42, _b22, _c32;
  const { state, manager, options: options2 } = this;
  const { dragOperation } = manager;
  const { position, source, status } = dragOperation;
  if (status.idle) {
    state.current = {};
    state.initial = {};
    return;
  }
  if (!source) return;
  const { element, feedback } = source;
  if (!element || feedback === "none" || !status.initialized || status.initializing) {
    return;
  }
  const { initial } = state;
  const feedbackElement = (_a42 = this.overlay) != null ? _a42 : element;
  const frameTransform = getFrameTransform(feedbackElement);
  const elementFrameTransform = getFrameTransform(element);
  const crossFrame = !isSameFrame(element, feedbackElement);
  const shape = new DOMRectangle(element, {
    frameTransform: crossFrame ? elementFrameTransform : null,
    ignoreTransforms: !crossFrame
  });
  const scaleDelta = {
    x: elementFrameTransform.scaleX / frameTransform.scaleX,
    y: elementFrameTransform.scaleY / frameTransform.scaleY
  };
  let { width, height, top, left } = shape;
  if (crossFrame) {
    width = width / scaleDelta.x;
    height = height / scaleDelta.y;
  }
  let elementMutationObserver;
  let documentMutationObserver;
  const styles2 = new Styles(feedbackElement);
  const {
    transition,
    translate,
    boxSizing,
    paddingBlockStart,
    paddingBlockEnd,
    paddingInlineStart,
    paddingInlineEnd,
    borderInlineStartWidth,
    borderInlineEndWidth,
    borderBlockStartWidth,
    borderBlockEndWidth
  } = getComputedStyles(element);
  const clone = feedback === "clone";
  const contentBox = boxSizing === "content-box";
  const widthOffset = contentBox ? parseInt(paddingInlineStart) + parseInt(paddingInlineEnd) + parseInt(borderInlineStartWidth) + parseInt(borderInlineEndWidth) : 0;
  const heightOffset = contentBox ? parseInt(paddingBlockStart) + parseInt(paddingBlockEnd) + parseInt(borderBlockStartWidth) + parseInt(borderBlockEndWidth) : 0;
  const placeholder = feedback !== "move" && !this.overlay ? createPlaceholder(source, clone ? "clone" : "hidden") : null;
  const isKeyboardOperation = o(
    () => isKeyboardEvent(manager.dragOperation.activatorEvent)
  );
  if (translate !== "none") {
    const parsedTranslate = parseTranslate(translate);
    if (parsedTranslate && !initial.translate) {
      initial.translate = parsedTranslate;
    }
  }
  if (!initial.transformOrigin) {
    const current = o(() => position.current);
    initial.transformOrigin = {
      x: (current.x - left * frameTransform.scaleX - frameTransform.x) / (width * frameTransform.scaleX),
      y: (current.y - top * frameTransform.scaleY - frameTransform.y) / (height * frameTransform.scaleY)
    };
  }
  const { transformOrigin } = initial;
  const relativeTop = top * frameTransform.scaleY + frameTransform.y;
  const relativeLeft = left * frameTransform.scaleX + frameTransform.x;
  if (!initial.coordinates) {
    initial.coordinates = {
      x: relativeLeft,
      y: relativeTop
    };
    if (scaleDelta.x !== 1 || scaleDelta.y !== 1) {
      const { scaleX, scaleY } = elementFrameTransform;
      const { x: tX2, y: tY2 } = transformOrigin;
      initial.coordinates.x += (width * scaleX - width) * tX2;
      initial.coordinates.y += (height * scaleY - height) * tY2;
    }
  }
  if (!initial.dimensions) {
    initial.dimensions = { width, height };
  }
  if (!initial.frameTransform) {
    initial.frameTransform = frameTransform;
  }
  const coordinatesDelta = {
    x: initial.coordinates.x - relativeLeft,
    y: initial.coordinates.y - relativeTop
  };
  const sizeDelta = {
    width: (initial.dimensions.width * initial.frameTransform.scaleX - width * frameTransform.scaleX) * transformOrigin.x,
    height: (initial.dimensions.height * initial.frameTransform.scaleY - height * frameTransform.scaleY) * transformOrigin.y
  };
  const delta = {
    x: coordinatesDelta.x / frameTransform.scaleX + sizeDelta.width,
    y: coordinatesDelta.y / frameTransform.scaleY + sizeDelta.height
  };
  const projected = {
    left: left + delta.x,
    top: top + delta.y
  };
  feedbackElement.setAttribute(ATTRIBUTE, "true");
  const transform = o(() => dragOperation.transform);
  const initialTranslate = (_b22 = initial.translate) != null ? _b22 : { x: 0, y: 0 };
  const tX = transform.x * frameTransform.scaleX + initialTranslate.x;
  const tY = transform.y * frameTransform.scaleY + initialTranslate.y;
  const translateString = `${tX}px ${tY}px 0`;
  const transitionString = transition ? `${transition}, translate 0ms linear` : "";
  styles2.set(
    {
      width: width - widthOffset,
      height: height - heightOffset,
      top: projected.top,
      left: projected.left,
      translate: translateString,
      transition: transitionString,
      scale: crossFrame ? `${scaleDelta.x} ${scaleDelta.y}` : "",
      "transform-origin": `${transformOrigin.x * 100}% ${transformOrigin.y * 100}%`
    },
    CSS_PREFIX
  );
  if (placeholder) {
    element.insertAdjacentElement("afterend", placeholder);
    if (options2 == null ? void 0 : options2.rootElement) {
      const root = typeof options2.rootElement === "function" ? options2.rootElement(source) : options2.rootElement;
      root.appendChild(element);
    }
  }
  if (supportsPopover(feedbackElement)) {
    if (!feedbackElement.hasAttribute("popover")) {
      feedbackElement.setAttribute("popover", "manual");
    }
    showPopover(feedbackElement);
    feedbackElement.addEventListener("beforetoggle", preventPopoverClose);
  }
  const resizeObserver = new ResizeObserver(() => {
    if (!placeholder) return;
    const placeholderShape = new DOMRectangle(placeholder, {
      frameTransform,
      ignoreTransforms: true
    });
    const origin = transformOrigin != null ? transformOrigin : { x: 1, y: 1 };
    const dX = (width - placeholderShape.width) * origin.x + delta.x;
    const dY = (height - placeholderShape.height) * origin.y + delta.y;
    styles2.set(
      {
        width: placeholderShape.width - widthOffset,
        height: placeholderShape.height - heightOffset,
        top: top + dY,
        left: left + dX
      },
      CSS_PREFIX
    );
    elementMutationObserver == null ? void 0 : elementMutationObserver.takeRecords();
    if (isTableRow(element) && isTableRow(placeholder)) {
      const cells = Array.from(element.cells);
      const placeholderCells = Array.from(placeholder.cells);
      for (const [index, cell] of cells.entries()) {
        const placeholderCell = placeholderCells[index];
        cell.style.width = `${placeholderCell.offsetWidth}px`;
      }
    }
    dragOperation.shape = new DOMRectangle(feedbackElement);
  });
  const initialShape = new DOMRectangle(feedbackElement);
  o(() => dragOperation.shape = initialShape);
  const feedbackWindow = getWindow(feedbackElement);
  const handleWindowResize = (event) => {
    this.manager.actions.stop({ event });
  };
  if (isKeyboardOperation) {
    feedbackWindow.addEventListener("resize", handleWindowResize);
  }
  if (o(() => source.status) === "idle") {
    requestAnimationFrame(() => source.status = "dragging");
  }
  if (placeholder) {
    resizeObserver.observe(placeholder);
    elementMutationObserver = new MutationObserver((mutations) => {
      let hasChildrenMutations = false;
      for (const mutation of mutations) {
        if (mutation.target !== element) {
          hasChildrenMutations = true;
          continue;
        }
        if (mutation.type !== "attributes") {
          continue;
        }
        const attributeName = mutation.attributeName;
        if (attributeName.startsWith("aria-") || IGNORED_ATTRIBUTES.includes(attributeName)) {
          continue;
        }
        const attributeValue = element.getAttribute(attributeName);
        if (attributeName === "style") {
          if (supportsStyle(element) && supportsStyle(placeholder)) {
            const styles22 = element.style;
            for (const key of Array.from(placeholder.style)) {
              if (styles22.getPropertyValue(key) === "") {
                placeholder.style.removeProperty(key);
              }
            }
            for (const key of Array.from(styles22)) {
              if (IGNORED_STYLES.includes(key) || key.startsWith(CSS_PREFIX)) {
                continue;
              }
              const value = styles22.getPropertyValue(key);
              placeholder.style.setProperty(key, value);
            }
          }
        } else if (attributeValue !== null) {
          placeholder.setAttribute(attributeName, attributeValue);
        } else {
          placeholder.removeAttribute(attributeName);
        }
      }
      if (hasChildrenMutations && clone) {
        placeholder.innerHTML = element.innerHTML;
      }
    });
    elementMutationObserver.observe(element, {
      attributes: true,
      subtree: true,
      childList: true
    });
    documentMutationObserver = new MutationObserver((entries) => {
      for (const entry of entries) {
        if (entry.addedNodes.length === 0) continue;
        for (const node of Array.from(entry.addedNodes)) {
          if (node.contains(element) && element.nextElementSibling !== placeholder) {
            element.insertAdjacentElement("afterend", placeholder);
            showPopover(feedbackElement);
            return;
          }
          if (node.contains(placeholder) && placeholder.previousElementSibling !== element) {
            placeholder.insertAdjacentElement("beforebegin", element);
            showPopover(feedbackElement);
            return;
          }
        }
      }
    });
    documentMutationObserver.observe(element.ownerDocument.body, {
      childList: true,
      subtree: true
    });
  }
  const id = (_c32 = manager.dragOperation.source) == null ? void 0 : _c32.id;
  const restoreFocus = () => {
    var _a5;
    if (!isKeyboardOperation || id == null) {
      return;
    }
    const draggable = manager.registry.draggables.get(id);
    const element2 = (_a5 = draggable == null ? void 0 : draggable.handle) != null ? _a5 : draggable == null ? void 0 : draggable.element;
    if (isHTMLElement(element2)) {
      element2.focus();
    }
  };
  const cleanup = () => {
    elementMutationObserver == null ? void 0 : elementMutationObserver.disconnect();
    documentMutationObserver == null ? void 0 : documentMutationObserver.disconnect();
    resizeObserver.disconnect();
    feedbackWindow.removeEventListener("resize", handleWindowResize);
    if (supportsPopover(feedbackElement)) {
      feedbackElement.removeEventListener(
        "beforetoggle",
        preventPopoverClose
      );
      feedbackElement.removeAttribute("popover");
    }
    feedbackElement.removeAttribute(ATTRIBUTE);
    styles2.reset();
    source.status = "idle";
    const moved = state.current.translate != null;
    if (placeholder && (moved || placeholder.parentElement !== feedbackElement.parentElement) && feedbackElement.isConnected) {
      placeholder.replaceWith(feedbackElement);
    }
    placeholder == null ? void 0 : placeholder.remove();
  };
  const cleanupEffects = effects(
    // Update transform on move
    () => {
      var _a5;
      const { transform: transform2, status: status2 } = dragOperation;
      if (!transform2.x && !transform2.y && !state.current.translate) {
        return;
      }
      if (status2.dragging) {
        const initialTranslate2 = (_a5 = initial.translate) != null ? _a5 : { x: 0, y: 0 };
        const translate2 = {
          x: transform2.x / frameTransform.scaleX + initialTranslate2.x,
          y: transform2.y / frameTransform.scaleY + initialTranslate2.y
        };
        const previousTranslate = state.current.translate;
        const modifiers = o(() => dragOperation.modifiers);
        const currentShape = o(() => {
          var _a6;
          return (_a6 = dragOperation.shape) == null ? void 0 : _a6.current;
        });
        const translateTransition = isKeyboardOperation ? "250ms cubic-bezier(0.25, 1, 0.5, 1)" : "0ms linear";
        styles2.set(
          {
            transition: `${transition}, translate ${translateTransition}`,
            translate: `${translate2.x}px ${translate2.y}px 0`
          },
          CSS_PREFIX
        );
        elementMutationObserver == null ? void 0 : elementMutationObserver.takeRecords();
        if (currentShape && currentShape !== initialShape && previousTranslate && !modifiers.length) {
          const delta2 = Point.delta(translate2, previousTranslate);
          dragOperation.shape = Rectangle.from(
            currentShape.boundingRectangle
          ).translate(
            // Need to take into account frame transform when optimistically updating shape
            delta2.x * frameTransform.scaleX,
            delta2.y * frameTransform.scaleY
          );
        } else {
          dragOperation.shape = new DOMRectangle(feedbackElement);
        }
        state.current.translate = translate2;
      }
    },
    // Drop animation
    function() {
      if (dragOperation.status.dropped) {
        this.dispose();
        source.status = "dropping";
        let translate2 = state.current.translate;
        const moved = translate2 != null;
        if (!translate2 && element !== feedbackElement) {
          translate2 = {
            x: 0,
            y: 0
          };
        }
        if (!translate2) {
          cleanup();
          return;
        }
        const dropAnimation = () => {
          var _a5, _b3;
          {
            showPopover(feedbackElement);
            const [, animation] = (_a5 = getFinalKeyframe(
              feedbackElement,
              (keyframe) => "translate" in keyframe
            )) != null ? _a5 : [];
            animation == null ? void 0 : animation.pause();
            const target = placeholder != null ? placeholder : element;
            const options22 = {
              frameTransform: isSameFrame(feedbackElement, target) ? null : void 0
            };
            const current = new DOMRectangle(feedbackElement, options22);
            const currentTranslate = (_b3 = parseTranslate(getComputedStyles(feedbackElement).translate)) != null ? _b3 : translate2;
            const final = new DOMRectangle(target, options22);
            const delta2 = Rectangle.delta(current, final, source.alignment);
            const finalTranslate = {
              x: currentTranslate.x - delta2.x,
              y: currentTranslate.y - delta2.y
            };
            const heightKeyframes = Math.round(current.intrinsicHeight) !== Math.round(final.intrinsicHeight) ? {
              minHeight: [
                `${current.intrinsicHeight}px`,
                `${final.intrinsicHeight}px`
              ],
              maxHeight: [
                `${current.intrinsicHeight}px`,
                `${final.intrinsicHeight}px`
              ]
            } : {};
            const widthKeyframes = Math.round(current.intrinsicWidth) !== Math.round(final.intrinsicWidth) ? {
              minWidth: [
                `${current.intrinsicWidth}px`,
                `${final.intrinsicWidth}px`
              ],
              maxWidth: [
                `${current.intrinsicWidth}px`,
                `${final.intrinsicWidth}px`
              ]
            } : {};
            styles2.set({ transition }, CSS_PREFIX);
            feedbackElement.setAttribute(DROPPING_ATTRIBUTE, "");
            elementMutationObserver == null ? void 0 : elementMutationObserver.takeRecords();
            animateTransform({
              element: feedbackElement,
              keyframes: __spreadProps4(__spreadValues5(__spreadValues5({}, heightKeyframes), widthKeyframes), {
                translate: [
                  `${currentTranslate.x}px ${currentTranslate.y}px 0`,
                  `${finalTranslate.x}px ${finalTranslate.y}px 0`
                ]
              }),
              options: {
                duration: moved || feedbackElement !== element ? 250 : 0,
                easing: "ease"
              }
            }).then(() => {
              feedbackElement.removeAttribute(DROPPING_ATTRIBUTE);
              animation == null ? void 0 : animation.finish();
              cleanup();
              requestAnimationFrame(restoreFocus);
            });
          }
        };
        manager.renderer.rendering.then(dropAnimation);
      }
    }
  );
  return () => {
    cleanup();
    cleanupEffects();
  };
};
injectStyles_fn = function() {
  var _a42, _b22, _c32;
  const { status, source, target } = this.manager.dragOperation;
  const { nonce } = (_a42 = this.options) != null ? _a42 : {};
  if (status.initializing) {
    const sourceDocument = getDocument((_b22 = source == null ? void 0 : source.element) != null ? _b22 : null);
    const targetDocument = getDocument((_c32 = target == null ? void 0 : target.element) != null ? _c32 : null);
    const documents = /* @__PURE__ */ new Set([sourceDocument, targetDocument]);
    for (const doc of documents) {
      let registration = styleSheetRegistry.get(doc);
      if (!registration) {
        const style = document.createElement("style");
        style.textContent = CSS_RULES;
        if (nonce) {
          style.setAttribute("nonce", nonce);
        }
        doc.head.prepend(style);
        const mutationObserver = new MutationObserver((entries) => {
          for (const entry of entries) {
            if (entry.type === "childList") {
              const removedNodes = Array.from(entry.removedNodes);
              if (removedNodes.length > 0 && removedNodes.includes(style)) {
                doc.head.prepend(style);
              }
            }
          }
        });
        mutationObserver.observe(doc.head, { childList: true });
        registration = {
          cleanup: () => {
            mutationObserver.disconnect();
            style.remove();
          },
          instances: /* @__PURE__ */ new Set()
        };
        styleSheetRegistry.set(doc, registration);
      }
      registration.instances.add(this);
    }
  }
};
__decorateElement4(_init7, 4, "overlay", _overlay_dec, _Feedback, _overlay);
__decoratorMetadata4(_init7, _Feedback);
_Feedback.configure = configurator(_Feedback);
var Feedback = _Feedback;
var LOCKED = true;
var UNLOCKED = false;
var _dec;
var _a22;
var _dec2;
var _b2;
var _init23;
var __b;
var __a;
_b2 = (_dec2 = [reactive], ScrollDirection.Forward), _a22 = (_dec = [reactive], ScrollDirection.Reverse);
var ScrollLock = class {
  constructor() {
    __privateAdd5(this, __b, __runInitializers4(_init23, 8, this, LOCKED)), __runInitializers4(_init23, 11, this);
    __privateAdd5(this, __a, __runInitializers4(_init23, 12, this, LOCKED)), __runInitializers4(_init23, 15, this);
  }
  isLocked(direction) {
    if (direction === ScrollDirection.Idle) {
      return false;
    }
    if (direction == null) {
      return this[ScrollDirection.Forward] === LOCKED && this[ScrollDirection.Reverse] === LOCKED;
    }
    return this[direction] === LOCKED;
  }
  unlock(direction) {
    if (direction === ScrollDirection.Idle) {
      return;
    }
    this[direction] = UNLOCKED;
  }
};
_init23 = __decoratorStart4(null);
__b = /* @__PURE__ */ new WeakMap();
__a = /* @__PURE__ */ new WeakMap();
__decorateElement4(_init23, 4, _b2, _dec2, ScrollLock, __b);
__decorateElement4(_init23, 4, _a22, _dec, ScrollLock, __a);
__decoratorMetadata4(_init23, ScrollLock);
var DIRECTIONS = [ScrollDirection.Forward, ScrollDirection.Reverse];
var ScrollIntent = class {
  constructor() {
    this.x = new ScrollLock();
    this.y = new ScrollLock();
  }
  isLocked() {
    return this.x.isLocked() && this.y.isLocked();
  }
};
var ScrollIntentTracker = class extends Plugin {
  constructor(manager) {
    super(manager);
    const scrollIntent = c2(new ScrollIntent());
    let previousDelta = null;
    this.signal = scrollIntent;
    m(() => {
      const { status } = manager.dragOperation;
      if (!status.initialized) {
        previousDelta = null;
        scrollIntent.value = new ScrollIntent();
        return;
      }
      const { delta } = manager.dragOperation.position;
      if (previousDelta) {
        const directions = {
          x: getDirection(delta.x, previousDelta.x),
          y: getDirection(delta.y, previousDelta.y)
        };
        const intent = scrollIntent.peek();
        n(() => {
          for (const axis of Axes) {
            for (const direction of DIRECTIONS) {
              if (directions[axis] === direction) {
                intent[axis].unlock(direction);
              }
            }
          }
          scrollIntent.value = intent;
        });
      }
      previousDelta = delta;
    });
  }
  get current() {
    return this.signal.peek();
  }
};
function getDirection(a2, b2) {
  return Math.sign(a2 - b2);
}
var _autoScrolling_dec;
var _a32;
var _init33;
var _autoScrolling;
var _meta;
var _scroll;
var Scroller = class extends (_a32 = CorePlugin, _autoScrolling_dec = [reactive], _a32) {
  constructor(manager) {
    super(manager);
    __privateAdd5(this, _autoScrolling, __runInitializers4(_init33, 8, this, false)), __runInitializers4(_init33, 11, this);
    __privateAdd5(this, _meta);
    __privateAdd5(this, _scroll, () => {
      if (!__privateGet5(this, _meta)) {
        return;
      }
      const { element, by } = __privateGet5(this, _meta);
      if (by.y) element.scrollTop += by.y;
      if (by.x) element.scrollLeft += by.x;
    });
    this.scroll = (options2) => {
      var _a42;
      if (this.disabled) {
        return false;
      }
      const elements = this.getScrollableElements();
      if (!elements) {
        __privateSet5(this, _meta, void 0);
        return false;
      }
      const { position } = this.manager.dragOperation;
      const currentPosition = position == null ? void 0 : position.current;
      if (currentPosition) {
        const { by } = options2 != null ? options2 : {};
        const intent = by ? {
          x: getScrollIntent(by.x),
          y: getScrollIntent(by.y)
        } : void 0;
        const scrollIntent = intent ? void 0 : this.scrollIntentTracker.current;
        if (scrollIntent == null ? void 0 : scrollIntent.isLocked()) {
          return false;
        }
        for (const scrollableElement of elements) {
          const elementCanScroll = canScroll(scrollableElement, by);
          if (elementCanScroll.x || elementCanScroll.y) {
            const { speed, direction } = detectScrollIntent(
              scrollableElement,
              currentPosition,
              intent
            );
            if (scrollIntent) {
              for (const axis of Axes) {
                if (scrollIntent[axis].isLocked(direction[axis])) {
                  speed[axis] = 0;
                  direction[axis] = 0;
                }
              }
            }
            if (direction.x || direction.y) {
              const { x, y: y2 } = by != null ? by : direction;
              const scrollLeftBy = x * speed.x;
              const scrollTopBy = y2 * speed.y;
              if (scrollLeftBy || scrollTopBy) {
                const previousScrollBy = (_a42 = __privateGet5(this, _meta)) == null ? void 0 : _a42.by;
                if (this.autoScrolling && previousScrollBy) {
                  const scrollIntentMismatch = previousScrollBy.x && !scrollLeftBy || previousScrollBy.y && !scrollTopBy;
                  if (scrollIntentMismatch) continue;
                }
                __privateSet5(this, _meta, {
                  element: scrollableElement,
                  by: {
                    x: scrollLeftBy,
                    y: scrollTopBy
                  }
                });
                scheduler.schedule(__privateGet5(this, _scroll));
                return true;
              }
            }
          }
        }
      }
      __privateSet5(this, _meta, void 0);
      return false;
    };
    let previousElementFromPoint = null;
    let previousScrollableElements = null;
    const elementFromPoint = computed(() => {
      const { position, source } = manager.dragOperation;
      if (!position) {
        return null;
      }
      const element = getElementFromPoint(
        getDocument(source == null ? void 0 : source.element),
        position.current
      );
      if (element) {
        previousElementFromPoint = element;
      }
      return element != null ? element : previousElementFromPoint;
    });
    const scrollableElements = computed(() => {
      const element = elementFromPoint.value;
      const { documentElement } = getDocument(element);
      if (!element || element === documentElement) {
        const { target } = manager.dragOperation;
        const targetElement = target == null ? void 0 : target.element;
        if (targetElement) {
          const elements = getScrollableAncestors(targetElement, {
            excludeElement: false
          });
          previousScrollableElements = elements;
          return elements;
        }
      }
      if (element) {
        const elements = getScrollableAncestors(element, {
          excludeElement: false
        });
        if (this.autoScrolling && previousScrollableElements && elements.size < (previousScrollableElements == null ? void 0 : previousScrollableElements.size)) {
          return previousScrollableElements;
        }
        previousScrollableElements = elements;
        return elements;
      }
      previousScrollableElements = null;
      return null;
    }, deepEqual2);
    this.getScrollableElements = () => {
      return scrollableElements.value;
    };
    this.scrollIntentTracker = new ScrollIntentTracker(manager);
    this.destroy = manager.monitor.addEventListener("dragmove", (event) => {
      if (this.disabled || event.defaultPrevented || !isKeyboardEvent(manager.dragOperation.activatorEvent) || !event.by) {
        return;
      }
      if (this.scroll({ by: event.by })) {
        event.preventDefault();
      }
    });
  }
};
_init33 = __decoratorStart4(_a32);
_autoScrolling = /* @__PURE__ */ new WeakMap();
_meta = /* @__PURE__ */ new WeakMap();
_scroll = /* @__PURE__ */ new WeakMap();
__decorateElement4(_init33, 4, "autoScrolling", _autoScrolling_dec, Scroller, _autoScrolling);
__decoratorMetadata4(_init33, Scroller);
function getScrollIntent(value) {
  if (value > 0) {
    return ScrollDirection.Forward;
  }
  if (value < 0) {
    return ScrollDirection.Reverse;
  }
  return ScrollDirection.Idle;
}
var Scheduler2 = class {
  constructor(scheduler5) {
    this.scheduler = scheduler5;
    this.pending = false;
    this.tasks = /* @__PURE__ */ new Set();
    this.resolvers = /* @__PURE__ */ new Set();
    this.flush = () => {
      const { tasks, resolvers } = this;
      this.pending = false;
      this.tasks = /* @__PURE__ */ new Set();
      this.resolvers = /* @__PURE__ */ new Set();
      for (const task of tasks) {
        task();
      }
      for (const resolve of resolvers) {
        resolve();
      }
    };
  }
  schedule(task) {
    this.tasks.add(task);
    if (!this.pending) {
      this.pending = true;
      this.scheduler(this.flush);
    }
    return new Promise((resolve) => this.resolvers.add(resolve));
  }
};
var scheduler32 = new Scheduler2((callback) => {
  if (typeof requestAnimationFrame === "function") {
    requestAnimationFrame(callback);
  } else {
    callback();
  }
});
var AUTOSCROLL_INTERVAL = 10;
var AutoScroller = class extends Plugin {
  constructor(manager, _options) {
    super(manager);
    const scroller = manager.registry.plugins.get(Scroller);
    if (!scroller) {
      throw new Error("AutoScroller plugin depends on Scroller plugin");
    }
    this.destroy = m(() => {
      if (this.disabled) {
        return;
      }
      const { position: _2, status } = manager.dragOperation;
      if (status.dragging) {
        const canScroll2 = scroller.scroll();
        if (canScroll2) {
          scroller.autoScrolling = true;
          const interval = setInterval(
            () => scheduler32.schedule(scroller.scroll),
            AUTOSCROLL_INTERVAL
          );
          return () => {
            clearInterval(interval);
          };
        } else {
          scroller.autoScrolling = false;
        }
      }
    });
  }
};
var listenerOptions = {
  capture: true,
  passive: true
};
var _timeout;
var ScrollListener = class extends CorePlugin {
  constructor(manager) {
    super(manager);
    __privateAdd5(this, _timeout);
    this.handleScroll = () => {
      if (__privateGet5(this, _timeout) == null) {
        __privateSet5(this, _timeout, setTimeout(() => {
          this.manager.collisionObserver.forceUpdate(false);
          __privateSet5(this, _timeout, void 0);
        }, 50));
      }
    };
    const { dragOperation } = this.manager;
    this.destroy = m(() => {
      var _a42, _b22, _c32;
      const enabled = dragOperation.status.dragging;
      if (enabled) {
        const root = (_c32 = (_b22 = (_a42 = dragOperation.source) == null ? void 0 : _a42.element) == null ? void 0 : _b22.ownerDocument) != null ? _c32 : document;
        root.addEventListener("scroll", this.handleScroll, listenerOptions);
        return () => {
          root.removeEventListener(
            "scroll",
            this.handleScroll,
            listenerOptions
          );
        };
      }
    });
  }
};
_timeout = /* @__PURE__ */ new WeakMap();
var PreventSelection = class extends Plugin {
  constructor(manager, options2) {
    super(manager, options2);
    this.manager = manager;
    this.destroy = m(() => {
      var _a42;
      const { dragOperation } = this.manager;
      const { nonce } = (_a42 = this.options) != null ? _a42 : {};
      if (dragOperation.status.initialized) {
        const style = document.createElement("style");
        if (nonce) {
          style.setAttribute("nonce", nonce);
        }
        style.textContent = `* { user-select: none !important; -webkit-user-select: none !important; }`;
        document.head.appendChild(style);
        removeSelection();
        document.addEventListener("selectionchange", removeSelection, {
          capture: true
        });
        return () => {
          document.removeEventListener("selectionchange", removeSelection, {
            capture: true
          });
          style.remove();
        };
      }
    });
  }
};
function removeSelection() {
  var _a42;
  (_a42 = document.getSelection()) == null ? void 0 : _a42.removeAllRanges();
}
var defaults = Object.freeze({
  offset: 10,
  keyboardCodes: {
    start: ["Space", "Enter"],
    cancel: ["Escape"],
    end: ["Space", "Enter", "Tab"],
    up: ["ArrowUp"],
    down: ["ArrowDown"],
    left: ["ArrowLeft"],
    right: ["ArrowRight"]
  },
  shouldActivate(args) {
    var _a42;
    const { event, source } = args;
    const target = (_a42 = source.handle) != null ? _a42 : source.element;
    return event.target === target;
  }
});
var _cleanupFunctions2;
var _KeyboardSensor = class _KeyboardSensor2 extends Sensor {
  constructor(manager, options2) {
    super(manager);
    this.manager = manager;
    this.options = options2;
    __privateAdd5(this, _cleanupFunctions2, []);
    this.listeners = new Listeners();
    this.handleSourceKeyDown = (event, source, options3) => {
      if (this.disabled || event.defaultPrevented) {
        return;
      }
      if (!isElement(event.target)) {
        return;
      }
      if (source.disabled) {
        return;
      }
      const {
        keyboardCodes = defaults.keyboardCodes,
        shouldActivate = defaults.shouldActivate
      } = options3 != null ? options3 : {};
      if (!keyboardCodes.start.includes(event.code)) {
        return;
      }
      if (!this.manager.dragOperation.status.idle) {
        return;
      }
      if (shouldActivate({ event, source, manager: this.manager })) {
        this.handleStart(event, source, options3);
      }
    };
  }
  bind(source, options2 = this.options) {
    const unbind = m(() => {
      var _a42;
      const target = (_a42 = source.handle) != null ? _a42 : source.element;
      const listener = (event) => {
        if (isKeyboardEvent(event)) {
          this.handleSourceKeyDown(event, source, options2);
        }
      };
      if (target) {
        target.addEventListener("keydown", listener);
        return () => {
          target.removeEventListener("keydown", listener);
        };
      }
    });
    return unbind;
  }
  handleStart(event, source, options2) {
    const { element } = source;
    if (!element) {
      throw new Error("Source draggable does not have an associated element");
    }
    event.preventDefault();
    event.stopImmediatePropagation();
    scrollIntoViewIfNeeded(element);
    const { center } = new DOMRectangle(element);
    const controller = this.manager.actions.start({
      event,
      coordinates: {
        x: center.x,
        y: center.y
      },
      source
    });
    if (controller.signal.aborted) return this.cleanup();
    this.sideEffects();
    const sourceDocument = getDocument(element);
    const listeners = [
      this.listeners.bind(sourceDocument, [
        {
          type: "keydown",
          listener: (event2) => this.handleKeyDown(event2, source, options2),
          options: { capture: true }
        }
      ])
    ];
    __privateGet5(this, _cleanupFunctions2).push(...listeners);
  }
  handleKeyDown(event, _source, options2) {
    const { keyboardCodes = defaults.keyboardCodes } = options2 != null ? options2 : {};
    if (isKeycode(event, [...keyboardCodes.end, ...keyboardCodes.cancel])) {
      event.preventDefault();
      const canceled = isKeycode(event, keyboardCodes.cancel);
      this.handleEnd(event, canceled);
      return;
    }
    if (isKeycode(event, keyboardCodes.up)) {
      this.handleMove("up", event);
    } else if (isKeycode(event, keyboardCodes.down)) {
      this.handleMove("down", event);
    }
    if (isKeycode(event, keyboardCodes.left)) {
      this.handleMove("left", event);
    } else if (isKeycode(event, keyboardCodes.right)) {
      this.handleMove("right", event);
    }
  }
  handleEnd(event, canceled) {
    this.manager.actions.stop({
      event,
      canceled
    });
    this.cleanup();
  }
  handleMove(direction, event) {
    var _a42, _b22;
    const { shape } = this.manager.dragOperation;
    const factor = event.shiftKey ? 5 : 1;
    let by = {
      x: 0,
      y: 0
    };
    let offset = (_b22 = (_a42 = this.options) == null ? void 0 : _a42.offset) != null ? _b22 : defaults.offset;
    if (typeof offset === "number") {
      offset = { x: offset, y: offset };
    }
    if (!shape) {
      return;
    }
    switch (direction) {
      case "up":
        by = { x: 0, y: -offset.y * factor };
        break;
      case "down":
        by = { x: 0, y: offset.y * factor };
        break;
      case "left":
        by = { x: -offset.x * factor, y: 0 };
        break;
      case "right":
        by = { x: offset.x * factor, y: 0 };
        break;
    }
    if (by.x || by.y) {
      event.preventDefault();
      this.manager.actions.move({
        event,
        by
      });
    }
  }
  sideEffects() {
    const autoScroller = this.manager.registry.plugins.get(AutoScroller);
    if ((autoScroller == null ? void 0 : autoScroller.disabled) === false) {
      autoScroller.disable();
      __privateGet5(this, _cleanupFunctions2).push(() => {
        autoScroller.enable();
      });
    }
  }
  cleanup() {
    __privateGet5(this, _cleanupFunctions2).forEach((cleanup) => cleanup());
    __privateSet5(this, _cleanupFunctions2, []);
  }
  destroy() {
    this.cleanup();
    this.listeners.clear();
  }
};
_cleanupFunctions2 = /* @__PURE__ */ new WeakMap();
_KeyboardSensor.configure = configurator(_KeyboardSensor);
_KeyboardSensor.defaults = defaults;
var KeyboardSensor = _KeyboardSensor;
function isKeycode(event, codes) {
  return codes.includes(event.code);
}
var defaults2 = Object.freeze({
  activationConstraints(event, source) {
    var _a42;
    const { pointerType, target } = event;
    if (pointerType === "mouse" && isElement(target) && (source.handle === target || ((_a42 = source.handle) == null ? void 0 : _a42.contains(target)))) {
      return void 0;
    }
    if (pointerType === "touch") {
      return {
        delay: { value: 250, tolerance: 5 }
      };
    }
    if (isTextInput(target) && !event.defaultPrevented) {
      return {
        delay: { value: 200, tolerance: 0 }
      };
    }
    return {
      delay: { value: 200, tolerance: 10 },
      distance: { value: 5 }
    };
  }
});
var _cleanup;
var _clearTimeout;
var _PointerSensor = class _PointerSensor2 extends Sensor {
  constructor(manager, options2) {
    super(manager);
    this.manager = manager;
    this.options = options2;
    __privateAdd5(this, _cleanup, /* @__PURE__ */ new Set());
    __privateAdd5(this, _clearTimeout);
    this.listeners = new Listeners();
    this.latest = {
      event: void 0,
      coordinates: void 0
    };
    this.handleMove = () => {
      const { event, coordinates: to } = this.latest;
      if (!event || !to) {
        return;
      }
      this.manager.actions.move({ event, to });
    };
    this.handleCancel = this.handleCancel.bind(this);
    this.handlePointerUp = this.handlePointerUp.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
  }
  activationConstraints(event, source) {
    var _a42;
    const { activationConstraints = defaults2.activationConstraints } = (_a42 = this.options) != null ? _a42 : {};
    const constraints = typeof activationConstraints === "function" ? activationConstraints(event, source) : activationConstraints;
    return constraints;
  }
  bind(source, options2 = this.options) {
    const unbind = m(() => {
      var _a42;
      const controller = new AbortController();
      const { signal: signal3 } = controller;
      const listener = (event) => {
        if (isPointerEvent(event)) {
          this.handlePointerDown(event, source, options2);
        }
      };
      let targets = [(_a42 = source.handle) != null ? _a42 : source.element];
      if (options2 == null ? void 0 : options2.activatorElements) {
        if (Array.isArray(options2.activatorElements)) {
          targets = options2.activatorElements;
        } else {
          targets = options2.activatorElements(source);
        }
      }
      for (const target of targets) {
        if (!target) continue;
        patchWindow(target.ownerDocument.defaultView);
        target.addEventListener("pointerdown", listener, { signal: signal3 });
      }
      return () => controller.abort();
    });
    return unbind;
  }
  handlePointerDown(event, source, options2 = {}) {
    if (this.disabled || !event.isPrimary || event.button !== 0 || !isElement(event.target) || source.disabled || isCapturedBySensor(event) || !this.manager.dragOperation.status.idle) {
      return;
    }
    const { target } = event;
    const isNativeDraggable = isHTMLElement(target) && target.draggable && target.getAttribute("draggable") === "true";
    const offset = getFrameTransform(source.element);
    this.initialCoordinates = {
      x: event.clientX * offset.scaleX + offset.x,
      y: event.clientY * offset.scaleY + offset.y
    };
    const constraints = this.activationConstraints(event, source);
    event.sensor = this;
    if (!(constraints == null ? void 0 : constraints.delay) && !(constraints == null ? void 0 : constraints.distance)) {
      this.handleStart(source, event);
    } else {
      const { delay } = constraints;
      if (delay) {
        const timeout3 = setTimeout(
          () => this.handleStart(source, event),
          delay.value
        );
        __privateSet5(this, _clearTimeout, () => {
          clearTimeout(timeout3);
          __privateSet5(this, _clearTimeout, void 0);
        });
      }
    }
    const ownerDocument = getDocument(event.target);
    const unbindListeners = this.listeners.bind(ownerDocument, [
      {
        type: "pointermove",
        listener: (event2) => this.handlePointerMove(event2, source)
      },
      {
        type: "pointerup",
        listener: this.handlePointerUp,
        options: {
          capture: true
        }
      },
      {
        // Cancel activation if there is a competing Drag and Drop interaction
        type: "dragstart",
        listener: isNativeDraggable ? this.handleCancel : preventDefault,
        options: {
          capture: true
        }
      }
    ]);
    const cleanup = () => {
      var _a42;
      unbindListeners();
      (_a42 = __privateGet5(this, _clearTimeout)) == null ? void 0 : _a42.call(this);
      this.initialCoordinates = void 0;
    };
    __privateGet5(this, _cleanup).add(cleanup);
  }
  handlePointerMove(event, source) {
    const coordinates = {
      x: event.clientX,
      y: event.clientY
    };
    const offset = getFrameTransform(source.element);
    coordinates.x = coordinates.x * offset.scaleX + offset.x;
    coordinates.y = coordinates.y * offset.scaleY + offset.y;
    if (this.manager.dragOperation.status.dragging) {
      event.preventDefault();
      event.stopPropagation();
      this.latest.event = event;
      this.latest.coordinates = coordinates;
      scheduler.schedule(this.handleMove);
      return;
    }
    if (!this.initialCoordinates) {
      return;
    }
    const delta = {
      x: coordinates.x - this.initialCoordinates.x,
      y: coordinates.y - this.initialCoordinates.y
    };
    const constraints = this.activationConstraints(event, source);
    const { distance, delay } = constraints != null ? constraints : {};
    if (distance) {
      if (distance.tolerance != null && exceedsDistance(delta, distance.tolerance)) {
        return this.handleCancel(event);
      }
      if (exceedsDistance(delta, distance.value)) {
        return this.handleStart(source, event);
      }
    }
    if (delay) {
      if (exceedsDistance(delta, delay.tolerance)) {
        return this.handleCancel(event);
      }
    }
  }
  handlePointerUp(event) {
    const { status } = this.manager.dragOperation;
    if (!status.idle) {
      event.preventDefault();
      event.stopPropagation();
      const canceled = !status.initialized;
      this.manager.actions.stop({ event, canceled });
    }
    this.cleanup();
  }
  handleKeyDown(event) {
    if (event.key === "Escape") {
      event.preventDefault();
      this.handleCancel(event);
    }
  }
  handleStart(source, event) {
    var _a42;
    const { manager, initialCoordinates } = this;
    (_a42 = __privateGet5(this, _clearTimeout)) == null ? void 0 : _a42.call(this);
    if (!initialCoordinates || !manager.dragOperation.status.idle) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    const controller = manager.actions.start({
      coordinates: initialCoordinates,
      event,
      source
    });
    if (controller.signal.aborted) return this.cleanup();
    event.preventDefault();
    const ownerDocument = getDocument(event.target);
    const pointerCaptureTarget = ownerDocument.body;
    pointerCaptureTarget.setPointerCapture(event.pointerId);
    const unbind = this.listeners.bind(ownerDocument, [
      {
        // Prevent scrolling on touch devices
        type: "touchmove",
        listener: preventDefault,
        options: {
          passive: false
        }
      },
      {
        // Prevent click events
        type: "click",
        listener: preventDefault
      },
      {
        type: "contextmenu",
        listener: preventDefault
      },
      {
        type: "keydown",
        listener: this.handleKeyDown
      },
      {
        type: "lostpointercapture",
        listener: (event2) => {
          if (event2.target !== pointerCaptureTarget) return;
          this.handlePointerUp(event2);
        }
      }
    ]);
    __privateGet5(this, _cleanup).add(unbind);
  }
  handleCancel(event) {
    const { dragOperation } = this.manager;
    if (dragOperation.status.initialized) {
      this.manager.actions.stop({ event, canceled: true });
    }
    this.cleanup();
  }
  cleanup() {
    this.latest = {
      event: void 0,
      coordinates: void 0
    };
    __privateGet5(this, _cleanup).forEach((cleanup) => cleanup());
    __privateGet5(this, _cleanup).clear();
  }
  destroy() {
    this.cleanup();
    this.listeners.clear();
  }
};
_cleanup = /* @__PURE__ */ new WeakMap();
_clearTimeout = /* @__PURE__ */ new WeakMap();
_PointerSensor.configure = configurator(_PointerSensor);
_PointerSensor.defaults = defaults2;
var PointerSensor = _PointerSensor;
function isCapturedBySensor(event) {
  return "sensor" in event;
}
function preventDefault(event) {
  event.preventDefault();
}
function noop() {
}
var windows = /* @__PURE__ */ new WeakSet();
function patchWindow(window2) {
  if (!window2 || windows.has(window2)) {
    return;
  }
  window2.addEventListener("touchmove", noop, {
    capture: false,
    passive: false
  });
  windows.add(window2);
}
var defaultPreset = {
  modifiers: [],
  plugins: [Accessibility, AutoScroller, Cursor, Feedback, PreventSelection],
  sensors: [PointerSensor, KeyboardSensor]
};
var DragDropManager2 = class extends DragDropManager {
  constructor(input = {}) {
    const {
      plugins = defaultPreset.plugins,
      sensors = defaultPreset.sensors,
      modifiers = []
    } = input;
    super(__spreadProps4(__spreadValues5({}, input), {
      plugins: [ScrollListener, Scroller, ...plugins],
      sensors,
      modifiers
    }));
  }
};
var _feedback_dec;
var _element_dec;
var _handle_dec;
var _c3;
var _init42;
var _handle;
var _element;
var _feedback;
var Draggable2 = class extends (_c3 = Draggable, _handle_dec = [reactive], _element_dec = [reactive], _feedback_dec = [reactive], _c3) {
  constructor(_a42, manager) {
    var _b22 = _a42, {
      element,
      effects: effects2 = () => [],
      handle,
      feedback = "default"
    } = _b22, input = __objRest3(_b22, [
      "element",
      "effects",
      "handle",
      "feedback"
    ]);
    super(
      __spreadValues5({
        effects: () => [
          ...effects2(),
          () => {
            var _a5, _b3;
            const { manager: manager2 } = this;
            if (!manager2) return;
            const sensors = (_b3 = (_a5 = this.sensors) == null ? void 0 : _a5.map(descriptor)) != null ? _b3 : [
              ...manager2.sensors
            ];
            const unbindFunctions = sensors.map((entry) => {
              const sensorInstance = entry instanceof Sensor ? entry : manager2.registry.register(entry.plugin);
              const options2 = entry instanceof Sensor ? void 0 : entry.options;
              const unbind = sensorInstance.bind(this, options2);
              return unbind;
            });
            return function cleanup() {
              unbindFunctions.forEach((unbind) => unbind());
            };
          }
        ]
      }, input),
      manager
    );
    __privateAdd5(this, _handle, __runInitializers4(_init42, 8, this)), __runInitializers4(_init42, 11, this);
    __privateAdd5(this, _element, __runInitializers4(_init42, 12, this)), __runInitializers4(_init42, 15, this);
    __privateAdd5(this, _feedback, __runInitializers4(_init42, 16, this)), __runInitializers4(_init42, 19, this);
    this.element = element;
    this.handle = handle;
    this.feedback = feedback;
  }
};
_init42 = __decoratorStart4(_c3);
_handle = /* @__PURE__ */ new WeakMap();
_element = /* @__PURE__ */ new WeakMap();
_feedback = /* @__PURE__ */ new WeakMap();
__decorateElement4(_init42, 4, "handle", _handle_dec, Draggable2, _handle);
__decorateElement4(_init42, 4, "element", _element_dec, Draggable2, _element);
__decorateElement4(_init42, 4, "feedback", _feedback_dec, Draggable2, _feedback);
__decoratorMetadata4(_init42, Draggable2);
var _proxy_dec;
var _element_dec2;
var _c23;
var _init52;
var _element2;
var _d;
var element_get;
var element_set;
var _Droppable_instances;
var _proxy;
var Droppable2 = class extends (_c23 = Droppable, _element_dec2 = [reactive], _proxy_dec = [reactive], _c23) {
  constructor(_a42, manager) {
    var _b22 = _a42, { element, effects: effects2 = () => [] } = _b22, input = __objRest3(_b22, ["element", "effects"]);
    const { collisionDetector = defaultCollisionDetection } = input;
    const updateShape = (boundingClientRect) => {
      const { manager: manager2, element: element2 } = this;
      if (!element2 || boundingClientRect === null) {
        this.shape = void 0;
        return void 0;
      }
      if (!manager2) return;
      const updatedShape = new DOMRectangle(element2);
      const shape = o(() => this.shape);
      if (updatedShape && (shape == null ? void 0 : shape.equals(updatedShape))) {
        return shape;
      }
      this.shape = updatedShape;
      return updatedShape;
    };
    const observePosition = c2(false);
    super(
      __spreadProps4(__spreadValues5({}, input), {
        collisionDetector,
        effects: () => [
          ...effects2(),
          () => {
            const { element: element2, manager: manager2 } = this;
            if (!manager2) return;
            const { dragOperation } = manager2;
            const { source } = dragOperation;
            observePosition.value = Boolean(
              source && dragOperation.status.initialized && element2 && !this.disabled && this.accepts(source)
            );
          },
          () => {
            const { element: element2 } = this;
            if (observePosition.value && element2) {
              const positionObserver = new FrameObserver(
                element2,
                updateShape
              );
              return () => {
                positionObserver.disconnect();
                this.shape = void 0;
              };
            }
          },
          () => {
            var _a5;
            if ((_a5 = this.manager) == null ? void 0 : _a5.dragOperation.status.initialized) {
              return () => {
                this.shape = void 0;
              };
            }
          }
        ]
      }),
      manager
    );
    __privateAdd5(this, _Droppable_instances);
    __privateAdd5(this, _element2, __runInitializers4(_init52, 8, this)), __runInitializers4(_init52, 11, this);
    __privateAdd5(this, _proxy, __runInitializers4(_init52, 12, this)), __runInitializers4(_init52, 15, this);
    this.element = element;
    this.refreshShape = () => updateShape();
  }
  set element(element) {
    __privateSet5(this, _Droppable_instances, element, element_set);
  }
  get element() {
    var _a42;
    return (_a42 = this.proxy) != null ? _a42 : __privateGet5(this, _Droppable_instances, element_get);
  }
};
_init52 = __decoratorStart4(_c23);
_element2 = /* @__PURE__ */ new WeakMap();
_Droppable_instances = /* @__PURE__ */ new WeakSet();
_proxy = /* @__PURE__ */ new WeakMap();
_d = __decorateElement4(_init52, 20, "#element", _element_dec2, _Droppable_instances, _element2), element_get = _d.get, element_set = _d.set;
__decorateElement4(_init52, 4, "proxy", _proxy_dec, Droppable2, _proxy);
__decoratorMetadata4(_init52, Droppable2);

// node_modules/@puckeditor/core/node_modules/@dnd-kit/react/hooks.js
var import_react5 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@puckeditor/core/node_modules/@dnd-kit/react/utilities.js
function isRef(value) {
  return value != null && typeof value === "object" && "current" in value;
}
function currentValue(value) {
  var _a5;
  if (value == null) {
    return void 0;
  }
  if (isRef(value)) {
    return (_a5 = value.current) != null ? _a5 : void 0;
  }
  return value;
}

// node_modules/@puckeditor/core/node_modules/@dnd-kit/react/hooks.js
var canUseDOM2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useIsomorphicLayoutEffect = canUseDOM2 ? import_react5.useLayoutEffect : import_react5.useEffect;
function useForceUpdate() {
  const setState = (0, import_react5.useState)(0)[1];
  return (0, import_react5.useCallback)(() => {
    setState((value) => value + 1);
  }, [setState]);
}
function useDeepSignal(target, synchronous) {
  const tracked = (0, import_react5.useRef)(/* @__PURE__ */ new Map());
  const forceUpdate = useForceUpdate();
  useIsomorphicLayoutEffect(() => {
    if (!target) {
      tracked.current.clear();
      return;
    }
    return m(() => {
      var _a5;
      let stale = false;
      let sync = false;
      for (const entry of tracked.current) {
        const [key] = entry;
        const value = o(() => entry[1]);
        const latestValue = target[key];
        if (value !== latestValue) {
          stale = true;
          tracked.current.set(key, latestValue);
          sync = (_a5 = synchronous == null ? void 0 : synchronous(key, value, latestValue)) != null ? _a5 : false;
        }
      }
      if (stale) {
        sync ? (0, import_react_dom.flushSync)(forceUpdate) : forceUpdate();
      }
    });
  }, [target]);
  return (0, import_react5.useMemo)(
    () => target ? new Proxy(target, {
      get(target2, key) {
        const value = target2[key];
        tracked.current.set(key, value);
        return value;
      }
    }) : target,
    [target]
  );
}
function useImmediateEffect(callback, _2) {
  callback();
}
function useLatest(value) {
  const valueRef = (0, import_react5.useRef)(value);
  useIsomorphicLayoutEffect(() => {
    valueRef.current = value;
  }, [value]);
  return valueRef;
}
function useOnValueChange(value, onChange, effect3 = import_react5.useEffect, compare = Object.is) {
  const tracked = (0, import_react5.useRef)(value);
  effect3(() => {
    const oldValue = tracked.current;
    if (!compare(value, oldValue)) {
      tracked.current = value;
      onChange(value, oldValue);
    }
  }, [onChange, value]);
}
function useOnElementChange(value, onChange) {
  const previous = (0, import_react5.useRef)(currentValue(value));
  useIsomorphicLayoutEffect(() => {
    const current = currentValue(value);
    if (current !== previous.current) {
      previous.current = current;
      onChange(current);
    }
  });
}

// node_modules/@puckeditor/core/node_modules/@dnd-kit/react/index.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var __defProp5 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues6 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp5.call(b2, prop))
      __defNormalProp5(a2, prop, b2[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b2)) {
      if (__propIsEnum5.call(b2, prop))
        __defNormalProp5(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps5 = (a2, b2) => __defProps4(a2, __getOwnPropDescs4(b2));
var __objRest4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var defaultManager = new DragDropManager2();
var DragDropContext = (0, import_react6.createContext)(
  defaultManager
);
var Renderer = (0, import_react6.memo)(
  (0, import_react6.forwardRef)(({ children }, ref) => {
    const [transitionCount, setTransitionCount] = (0, import_react6.useState)(0);
    const rendering = (0, import_react6.useRef)(null);
    const resolver = (0, import_react6.useRef)(null);
    const renderer = (0, import_react6.useMemo)(
      () => ({
        renderer: {
          get rendering() {
            var _a23;
            return (_a23 = rendering.current) != null ? _a23 : Promise.resolve();
          }
        },
        trackRendering(callback) {
          if (!rendering.current) {
            rendering.current = new Promise((resolve) => {
              resolver.current = resolve;
            });
          }
          (0, import_react6.startTransition)(() => {
            callback();
            setTransitionCount((count) => count + 1);
          });
        }
      }),
      []
    );
    useIsomorphicLayoutEffect(() => {
      var _a23;
      (_a23 = resolver.current) == null ? void 0 : _a23.call(resolver);
      rendering.current = null;
    }, [children, transitionCount]);
    (0, import_react6.useImperativeHandle)(ref, () => renderer);
    return null;
  })
);
var options = [void 0, deepEqual2];
function DragDropProvider(_a23) {
  var _b3 = _a23, {
    children,
    onCollision,
    onBeforeDragStart,
    onDragStart,
    onDragMove,
    onDragOver,
    onDragEnd
  } = _b3, input = __objRest4(_b3, [
    "children",
    "onCollision",
    "onBeforeDragStart",
    "onDragStart",
    "onDragMove",
    "onDragOver",
    "onDragEnd"
  ]);
  var _a33;
  const rendererRef = (0, import_react6.useRef)(null);
  const [manager, setManager] = (0, import_react6.useState)((_a33 = input.manager) != null ? _a33 : null);
  const { plugins, modifiers, sensors } = input;
  const handleBeforeDragStart = useLatest(onBeforeDragStart);
  const handleDragStart = useLatest(onDragStart);
  const handleDragOver = useLatest(onDragOver);
  const handleDragMove = useLatest(onDragMove);
  const handleDragEnd = useLatest(onDragEnd);
  const handleCollision = useLatest(onCollision);
  (0, import_react6.useEffect)(() => {
    var _a42;
    if (!rendererRef.current) throw new Error("Renderer not found");
    const { renderer, trackRendering } = rendererRef.current;
    const manager2 = (_a42 = input.manager) != null ? _a42 : new DragDropManager2(input);
    manager2.renderer = renderer;
    manager2.monitor.addEventListener("beforedragstart", (event) => {
      const callback = handleBeforeDragStart.current;
      if (callback) {
        trackRendering(() => callback(event, manager2));
      }
    });
    manager2.monitor.addEventListener(
      "dragstart",
      (event) => {
        var _a5;
        return (_a5 = handleDragStart.current) == null ? void 0 : _a5.call(handleDragStart, event, manager2);
      }
    );
    manager2.monitor.addEventListener("dragover", (event) => {
      const callback = handleDragOver.current;
      if (callback) {
        trackRendering(() => callback(event, manager2));
      }
    });
    manager2.monitor.addEventListener("dragmove", (event) => {
      const callback = handleDragMove.current;
      if (callback) {
        trackRendering(() => callback(event, manager2));
      }
    });
    manager2.monitor.addEventListener("dragend", (event) => {
      const callback = handleDragEnd.current;
      if (callback) {
        trackRendering(() => callback(event, manager2));
      }
    });
    manager2.monitor.addEventListener(
      "collision",
      (event) => {
        var _a5;
        return (_a5 = handleCollision.current) == null ? void 0 : _a5.call(handleCollision, event, manager2);
      }
    );
    (0, import_react6.startTransition)(() => setManager(manager2));
    return manager2.destroy;
  }, [input.manager]);
  useOnValueChange(
    plugins,
    () => manager && (manager.plugins = plugins != null ? plugins : defaultPreset.plugins),
    ...options
  );
  useOnValueChange(
    sensors,
    () => manager && (manager.sensors = sensors != null ? sensors : defaultPreset.sensors),
    ...options
  );
  useOnValueChange(
    modifiers,
    () => manager && (manager.modifiers = modifiers != null ? modifiers : defaultPreset.modifiers),
    ...options
  );
  return (0, import_jsx_runtime4.jsxs)(DragDropContext.Provider, { value: manager, children: [
    (0, import_jsx_runtime4.jsx)(Renderer, { ref: rendererRef, children }),
    children
  ] });
}
function useDragDropManager() {
  return (0, import_react6.useContext)(DragDropContext);
}
function useInstance(initializer) {
  var _a23;
  const manager = (_a23 = useDragDropManager()) != null ? _a23 : void 0;
  const [instance] = (0, import_react6.useState)(() => initializer(manager));
  if (instance.manager !== manager) {
    instance.manager = manager;
  }
  useIsomorphicLayoutEffect(instance.register, [manager, instance]);
  return instance;
}
function useDraggable(input) {
  const { disabled, data, element, handle, id, modifiers, sensors } = input;
  const draggable = useInstance(
    (manager) => new Draggable2(
      __spreadProps5(__spreadValues6({}, input), {
        register: false,
        handle: currentValue(handle),
        element: currentValue(element)
      }),
      manager
    )
  );
  const trackedDraggable = useDeepSignal(draggable, shouldUpdateSynchronously);
  useOnValueChange(id, () => draggable.id = id);
  useOnElementChange(handle, (handle2) => draggable.handle = handle2);
  useOnElementChange(element, (element2) => draggable.element = element2);
  useOnValueChange(data, () => data && (draggable.data = data));
  useOnValueChange(disabled, () => draggable.disabled = disabled === true);
  useOnValueChange(sensors, () => draggable.sensors = sensors);
  useOnValueChange(
    modifiers,
    () => draggable.modifiers = modifiers,
    void 0,
    deepEqual2
  );
  useOnValueChange(
    input.feedback,
    () => {
      var _a23;
      return draggable.feedback = (_a23 = input.feedback) != null ? _a23 : "default";
    }
  );
  useOnValueChange(
    input.alignment,
    () => draggable.alignment = input.alignment
  );
  return {
    draggable: trackedDraggable,
    get isDragging() {
      return trackedDraggable.isDragging;
    },
    get isDropping() {
      return trackedDraggable.isDropping;
    },
    get isDragSource() {
      return trackedDraggable.isDragSource;
    },
    handleRef: (0, import_react6.useCallback)(
      (element2) => {
        draggable.handle = element2 != null ? element2 : void 0;
      },
      [draggable]
    ),
    ref: (0, import_react6.useCallback)(
      (element2) => {
        var _a23, _b3;
        if (!element2 && ((_a23 = draggable.element) == null ? void 0 : _a23.isConnected) && !((_b3 = draggable.manager) == null ? void 0 : _b3.dragOperation.status.idle)) {
          return;
        }
        draggable.element = element2 != null ? element2 : void 0;
      },
      [draggable]
    )
  };
}
function shouldUpdateSynchronously(key, oldValue, newValue) {
  if (key === "isDragSource" && !newValue && oldValue) return true;
  return false;
}
var __create5 = Object.create;
var __defProp22 = Object.defineProperty;
var __getOwnPropDesc5 = Object.getOwnPropertyDescriptor;
var __knownSymbol5 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError6 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp22 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart5 = (base) => {
  var _a23;
  return [, , , __create5((_a23 = base == null ? void 0 : base[__knownSymbol5("metadata")]) != null ? _a23 : null)];
};
var __decoratorStrings5 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn5 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError6("Function expected") : fn;
var __decoratorContext5 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings5[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError6("Already initialized") : fns.push(__expectFn5(fn || null)) });
var __decoratorMetadata5 = (array, target) => __defNormalProp22(target, __knownSymbol5("metadata"), array[3]);
var __runInitializers5 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n2 = fns && fns.length; i2 < n2; i2++) fns[i2].call(self2);
  return value;
};
var __decorateElement5 = (array, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p2 = false;
  var j = 2, key = __decoratorStrings5[k + 5];
  var extraInitializers = array[j] || (array[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc5(target, name));
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext5(k, name, done = {}, array[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i2])(desc[key], ctx), done._ = 1;
    __expectFn5(it) && (desc[key] = it);
  }
  return desc && __defProp22(target, name, desc), target;
};
var __accessCheck6 = (obj, member, msg) => member.has(obj) || __typeError6("Cannot " + msg);
var __privateGet6 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), member.get(obj));
var __privateAdd6 = (obj, member, value) => member.has(obj) ? __typeError6("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet6 = (obj, member, value, setter) => (__accessCheck6(obj, member, "write to private field"), member.set(obj, value), value);
var Point2 = class _Point2 {
  /**
   * @param {number} Coordinate of the point on the horizontal axis
   * @param {number} Coordinate of the point on the vertical axis
   */
  constructor(x, y2) {
    this.x = x;
    this.y = y2;
  }
  /**
   * Returns the delta between this point and another point.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static delta(a2, b2) {
    return new _Point2(a2.x - b2.x, a2.y - b2.y);
  }
  /**
   * Returns the distance (hypotenuse) between this point and another point.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static distance(a2, b2) {
    return Math.hypot(a2.x - b2.x, a2.y - b2.y);
  }
  /**
   * Returns true if both points are equal.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static equals(a2, b2) {
    return a2.x === b2.x && a2.y === b2.y;
  }
  static from({ x, y: y2 }) {
    return new _Point2(x, y2);
  }
};
var _direction_dec2;
var _delta_dec2;
var _a4;
var _timestamp2;
var _init8;
var Position2 = class extends (_a4 = ValueHistory, _delta_dec2 = [derived], _direction_dec2 = [derived], _a4) {
  constructor(initialValue) {
    const point = Point2.from(initialValue);
    super(point, (a2, b2) => Point2.equals(a2, b2));
    __runInitializers5(_init8, 5, this);
    __privateAdd6(this, _timestamp2, 0);
    this.velocity = { x: 0, y: 0 };
  }
  get delta() {
    return Point2.delta(this.current, this.initial);
  }
  get direction() {
    const { current, previous } = this;
    if (!previous) return null;
    const delta = {
      x: current.x - previous.x,
      y: current.y - previous.y
    };
    if (!delta.x && !delta.y) {
      return null;
    }
    if (Math.abs(delta.x) > Math.abs(delta.y)) {
      return delta.x > 0 ? "right" : "left";
    }
    return delta.y > 0 ? "down" : "up";
  }
  get current() {
    return super.current;
  }
  set current(coordinates) {
    const { current } = this;
    const point = Point2.from(coordinates);
    const delta = {
      x: point.x - current.x,
      y: point.y - current.y
    };
    const timestamp = Date.now();
    const timeDelta = timestamp - __privateGet6(this, _timestamp2);
    const velocity = (delta2) => Math.round(delta2 / timeDelta * 100);
    n(() => {
      __privateSet6(this, _timestamp2, timestamp);
      this.velocity = {
        x: velocity(delta.x),
        y: velocity(delta.y)
      };
      super.current = point;
    });
  }
  reset(coordinates = this.defaultValue) {
    super.reset(Point2.from(coordinates));
    this.velocity = { x: 0, y: 0 };
  }
};
_init8 = __decoratorStart5(_a4);
_timestamp2 = /* @__PURE__ */ new WeakMap();
__decorateElement5(_init8, 2, "delta", _delta_dec2, Position2);
__decorateElement5(_init8, 2, "direction", _direction_dec2, Position2);
__decoratorMetadata5(_init8, Position2);
var Axis2 = ((Axis22) => {
  Axis22["Horizontal"] = "x";
  Axis22["Vertical"] = "y";
  return Axis22;
})(Axis2 || {});
Object.values(Axis2);
var pointerIntersection2 = ({
  dragOperation,
  droppable
}) => {
  const pointerCoordinates = dragOperation.position.current;
  if (!pointerCoordinates) {
    return null;
  }
  const { id } = droppable;
  if (!droppable.shape) {
    return null;
  }
  if (droppable.shape.containsPoint(pointerCoordinates)) {
    const distance = Point2.distance(droppable.shape.center, pointerCoordinates);
    return {
      id,
      value: 1 / distance,
      type: CollisionType.PointerIntersection,
      priority: CollisionPriority.High
    };
  }
  return null;
};
var shapeIntersection2 = ({
  dragOperation,
  droppable
}) => {
  const { shape } = dragOperation;
  if (!droppable.shape || !(shape == null ? void 0 : shape.current)) {
    return null;
  }
  const intersectionArea = shape.current.intersectionArea(droppable.shape);
  if (intersectionArea) {
    const { position } = dragOperation;
    const distance = Point2.distance(droppable.shape.center, position.current);
    const intersectionRatio = intersectionArea / (shape.current.area + droppable.shape.area - intersectionArea);
    const value = intersectionRatio / distance;
    return {
      id: droppable.id,
      value,
      type: CollisionType.ShapeIntersection,
      priority: CollisionPriority.Normal
    };
  }
  return null;
};
var defaultCollisionDetection2 = (args) => {
  var _a23;
  return (_a23 = pointerIntersection2(args)) != null ? _a23 : shapeIntersection2(args);
};
function useDroppable(input) {
  const { collisionDetector, data, disabled, element, id, accept, type } = input;
  const droppable = useInstance(
    (manager) => new Droppable2(
      __spreadProps5(__spreadValues6({}, input), {
        register: false,
        element: currentValue(element)
      }),
      manager
    )
  );
  const trackedDroppalbe = useDeepSignal(droppable);
  useOnValueChange(id, () => droppable.id = id);
  useOnElementChange(element, (element2) => droppable.element = element2);
  useOnValueChange(
    accept,
    () => droppable.accept = accept,
    void 0,
    deepEqual2
  );
  useOnValueChange(
    collisionDetector,
    () => droppable.collisionDetector = collisionDetector != null ? collisionDetector : defaultCollisionDetection2
  );
  useOnValueChange(data, () => data && (droppable.data = data));
  useOnValueChange(disabled, () => droppable.disabled = disabled === true);
  useOnValueChange(type, () => droppable.type = type);
  return {
    droppable: trackedDroppalbe,
    get isDropTarget() {
      return trackedDroppalbe.isDropTarget;
    },
    ref: (0, import_react6.useCallback)(
      (element2) => {
        var _a23, _b3;
        if (!element2 && ((_a23 = droppable.element) == null ? void 0 : _a23.isConnected) && !((_b3 = droppable.manager) == null ? void 0 : _b3.dragOperation.status.idle)) {
          return;
        }
        droppable.element = element2 != null ? element2 : void 0;
      },
      [droppable]
    )
  };
}

// node_modules/@puckeditor/core/dist/chunk-EBISZQTK.mjs
var import_react14 = __toESM(require_react(), 1);

// node_modules/@puckeditor/core/node_modules/@dnd-kit/react/sortable.js
var import_react7 = __toESM(require_react());

// node_modules/@dnd-kit/dom/sortable.js
var __create6 = Object.create;
var __defProp6 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDesc6 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols6 = Object.getOwnPropertySymbols;
var __hasOwnProp6 = Object.prototype.hasOwnProperty;
var __propIsEnum6 = Object.prototype.propertyIsEnumerable;
var __knownSymbol6 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError7 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues7 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp6.call(b2, prop))
      __defNormalProp6(a2, prop, b2[prop]);
  if (__getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(b2)) {
      if (__propIsEnum6.call(b2, prop))
        __defNormalProp6(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps6 = (a2, b2) => __defProps5(a2, __getOwnPropDescs5(b2));
var __objRest5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decoratorStart6 = (base) => {
  var _a5;
  return [, , , __create6((_a5 = void 0) != null ? _a5 : null)];
};
var __decoratorStrings6 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn6 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError7("Function expected") : fn;
var __decoratorContext6 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings6[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError7("Already initialized") : fns.push(__expectFn6(fn || null)) });
var __decoratorMetadata6 = (array, target) => __defNormalProp6(target, __knownSymbol6("metadata"), array[3]);
var __runInitializers6 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n2 = fns && fns.length; i2 < n2; i2++) flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement6 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = false, p2 = false;
  var j = array.length + 1, key = __decoratorStrings6[k + 5];
  var initializers = array[j - 1] = [], extraInitializers = array[j] || (array[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc6({ get [name]() {
    return __privateGet7(this, extra);
  }, set [name](x) {
    return __privateSet7(this, extra, x);
  } }, name));
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext6(k, name, done = {}, array[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
      access.set = (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])({ get: desc.get, set: desc.set }, ctx), done._ = 1;
    if (it === void 0) __expectFn6(it) && (desc[key] = it);
    else if (typeof it !== "object" || it === null) __typeError7("Object expected");
    else __expectFn6(fn = it.get) && (desc.get = fn), __expectFn6(fn = it.set) && (desc.set = fn), __expectFn6(fn = it.init) && initializers.unshift(fn);
  }
  return desc && __defProp6(target, name, desc), target;
};
var __accessCheck7 = (obj, member, msg) => member.has(obj) || __typeError7("Cannot " + msg);
var __privateGet7 = (obj, member, getter) => (__accessCheck7(obj, member, "read from private field"), member.get(obj));
var __privateAdd7 = (obj, member, value) => member.has(obj) ? __typeError7("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet7 = (obj, member, value, setter) => (__accessCheck7(obj, member, "write to private field"), member.set(obj, value), value);
function isSortable(element) {
  return element instanceof SortableDroppable || element instanceof SortableDraggable;
}
var TOLERANCE = 10;
var SortableKeyboardPlugin = class extends Plugin {
  constructor(manager) {
    super(manager);
    const cleanupEffect = m(() => {
      const { dragOperation } = manager;
      if (!isKeyboardEvent(dragOperation.activatorEvent)) {
        return;
      }
      if (!isSortable(dragOperation.source)) {
        return;
      }
      if (dragOperation.status.initialized) {
        const scroller = manager.registry.plugins.get(Scroller);
        if (scroller) {
          scroller.disable();
          return () => scroller.enable();
        }
      }
    });
    const unsubscribe = manager.monitor.addEventListener(
      "dragmove",
      (event, manager2) => {
        queueMicrotask(() => {
          if (this.disabled || event.defaultPrevented || !event.nativeEvent) {
            return;
          }
          const { dragOperation } = manager2;
          if (!isKeyboardEvent(event.nativeEvent)) {
            return;
          }
          if (!isSortable(dragOperation.source)) {
            return;
          }
          if (!dragOperation.shape) {
            return;
          }
          const { actions, collisionObserver, registry } = manager2;
          const { by } = event;
          if (!by) {
            return;
          }
          const direction = getDirection2(by);
          const { source, target } = dragOperation;
          const { center } = dragOperation.shape.current;
          const potentialTargets = [];
          const cleanup = [];
          n(() => {
            for (const droppable of registry.droppables) {
              const { id: id2 } = droppable;
              if (!droppable.accepts(source) || id2 === (target == null ? void 0 : target.id) && isSortable(droppable) || !droppable.element) {
                continue;
              }
              let previousShape = droppable.shape;
              const shape = new DOMRectangle(droppable.element, {
                getBoundingClientRect: (element) => getVisibleBoundingRectangle(element, void 0, 0.2)
              });
              if (!shape.height || !shape.width) continue;
              if (direction == "down" && center.y + TOLERANCE < shape.center.y || direction == "up" && center.y - TOLERANCE > shape.center.y || direction == "left" && center.x - TOLERANCE > shape.center.x || direction == "right" && center.x + TOLERANCE < shape.center.x) {
                potentialTargets.push(droppable);
                droppable.shape = shape;
                cleanup.push(() => droppable.shape = previousShape);
              }
            }
          });
          event.preventDefault();
          collisionObserver.disable();
          const collisions = collisionObserver.computeCollisions(
            potentialTargets,
            closestCorners
          );
          n(() => cleanup.forEach((clean) => clean()));
          const [firstCollision] = collisions;
          if (!firstCollision) {
            return;
          }
          const { id } = firstCollision;
          const { index, group } = source.sortable;
          actions.setDropTarget(id).then(() => {
            const { source: source2, target: target2, shape } = dragOperation;
            if (!source2 || !isSortable(source2) || !shape) {
              return;
            }
            const {
              index: newIndex,
              group: newGroup,
              target: targetElement
            } = source2.sortable;
            const updated = index !== newIndex || group !== newGroup;
            const element = updated ? targetElement : target2 == null ? void 0 : target2.element;
            if (!element) return;
            scrollIntoViewIfNeeded(element);
            const updatedShape = new DOMRectangle(element);
            if (!updatedShape) {
              return;
            }
            const delta = Rectangle.delta(
              updatedShape,
              Rectangle.from(shape.current.boundingRectangle),
              source2.alignment
            );
            actions.move({
              by: delta
            });
            if (updated) {
              actions.setDropTarget(source2.id).then(() => collisionObserver.enable());
            } else {
              collisionObserver.enable();
            }
          });
        });
      }
    );
    this.destroy = () => {
      unsubscribe();
      cleanupEffect();
    };
  }
};
function getDirection2(delta) {
  const { x, y: y2 } = delta;
  if (x > 0) {
    return "right";
  } else if (x < 0) {
    return "left";
  } else if (y2 > 0) {
    return "down";
  } else if (y2 < 0) {
    return "up";
  }
}
var __defProp23 = Object.defineProperty;
var __defProps22 = Object.defineProperties;
var __getOwnPropDescs22 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols22 = Object.getOwnPropertySymbols;
var __hasOwnProp22 = Object.prototype.hasOwnProperty;
var __propIsEnum22 = Object.prototype.propertyIsEnumerable;
var __defNormalProp23 = (obj, key, value) => key in obj ? __defProp23(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues22 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp22.call(b2, prop))
      __defNormalProp23(a2, prop, b2[prop]);
  if (__getOwnPropSymbols22)
    for (var prop of __getOwnPropSymbols22(b2)) {
      if (__propIsEnum22.call(b2, prop))
        __defNormalProp23(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps22 = (a2, b2) => __defProps22(a2, __getOwnPropDescs22(b2));
function arrayMove(array, from, to) {
  if (from === to) {
    return array;
  }
  const newArray = array.slice();
  newArray.splice(to, 0, newArray.splice(from, 1)[0]);
  return newArray;
}
function mutate(items, event, mutation) {
  var _a5, _b3;
  const { source, target, canceled } = event.operation;
  if (!source || !target || canceled) {
    if ("preventDefault" in event) event.preventDefault();
    return items;
  }
  const findIndex = (item, id) => item === id || typeof item === "object" && "id" in item && item.id === id;
  if (Array.isArray(items)) {
    const sourceIndex2 = items.findIndex((item) => findIndex(item, source.id));
    const targetIndex2 = items.findIndex((item) => findIndex(item, target.id));
    if (sourceIndex2 === -1 || targetIndex2 === -1) {
      return items;
    }
    if (!canceled && "index" in source && typeof source.index === "number") {
      const projectedSourceIndex = source.index;
      if (projectedSourceIndex !== sourceIndex2) {
        return mutation(items, sourceIndex2, projectedSourceIndex);
      }
    }
    return mutation(items, sourceIndex2, targetIndex2);
  }
  const entries = Object.entries(items);
  let sourceIndex = -1;
  let sourceParent;
  let targetIndex = -1;
  let targetParent;
  for (const [id, children] of entries) {
    if (sourceIndex === -1) {
      sourceIndex = children.findIndex((item) => findIndex(item, source.id));
      if (sourceIndex !== -1) {
        sourceParent = id;
      }
    }
    if (targetIndex === -1) {
      targetIndex = children.findIndex((item) => findIndex(item, target.id));
      if (targetIndex !== -1) {
        targetParent = id;
      }
    }
    if (sourceIndex !== -1 && targetIndex !== -1) {
      break;
    }
  }
  if (!source.manager) return items;
  const { dragOperation } = source.manager;
  const position = (_b3 = (_a5 = dragOperation.shape) == null ? void 0 : _a5.current.center) != null ? _b3 : dragOperation.position.current;
  if (targetParent == null) {
    if (target.id in items) {
      const insertionIndex = target.shape && position.y > target.shape.center.y ? items[target.id].length : 0;
      targetParent = target.id;
      targetIndex = insertionIndex;
    }
  }
  if (sourceParent == null || targetParent == null || sourceParent === targetParent && sourceIndex === targetIndex) {
    if ("preventDefault" in event) event.preventDefault();
    return items;
  }
  if (sourceParent === targetParent) {
    return __spreadProps22(__spreadValues22({}, items), {
      [sourceParent]: mutation(items[sourceParent], sourceIndex, targetIndex)
    });
  }
  const isBelowTarget = target.shape && Math.round(position.y) > Math.round(target.shape.center.y);
  const modifier = isBelowTarget ? 1 : 0;
  const sourceItem = items[sourceParent][sourceIndex];
  return __spreadProps22(__spreadValues22({}, items), {
    [sourceParent]: [
      ...items[sourceParent].slice(0, sourceIndex),
      ...items[sourceParent].slice(sourceIndex + 1)
    ],
    [targetParent]: [
      ...items[targetParent].slice(0, targetIndex + modifier),
      sourceItem,
      ...items[targetParent].slice(targetIndex + modifier)
    ]
  });
}
function move(items, event) {
  return mutate(items, event, arrayMove);
}
var defaultGroup = "__default__";
var OptimisticSortingPlugin = class extends Plugin {
  constructor(manager) {
    super(manager);
    const getSortableInstances = () => {
      const sortableInstances = /* @__PURE__ */ new Map();
      for (const droppable of manager.registry.droppables) {
        if (droppable instanceof SortableDroppable) {
          const { sortable } = droppable;
          const { group } = sortable;
          let instances = sortableInstances.get(group);
          if (!instances) {
            instances = /* @__PURE__ */ new Set();
            sortableInstances.set(group, instances);
          }
          instances.add(sortable);
        }
      }
      for (const [group, instances] of sortableInstances) {
        sortableInstances.set(group, new Set(sort(instances)));
      }
      return sortableInstances;
    };
    const unsubscribe = [
      manager.monitor.addEventListener("dragover", (event, manager2) => {
        if (this.disabled) {
          return;
        }
        const { dragOperation } = manager2;
        const { source, target } = dragOperation;
        if (!isSortable(source) || !isSortable(target)) {
          return;
        }
        if (source.sortable === target.sortable) {
          return;
        }
        const instances = getSortableInstances();
        const sameGroup = source.sortable.group === target.sortable.group;
        const sourceInstances = instances.get(source.sortable.group);
        const targetInstances = sameGroup ? sourceInstances : instances.get(target.sortable.group);
        if (!sourceInstances || !targetInstances) return;
        queueMicrotask(() => {
          if (event.defaultPrevented) return;
          manager2.renderer.rendering.then(() => {
            var _a5, _b3, _c4;
            const newInstances = getSortableInstances();
            for (const [group, sortableInstances] of instances.entries()) {
              const entries = Array.from(sortableInstances).entries();
              for (const [index, sortable] of entries) {
                if (sortable.index !== index || sortable.group !== group || !((_a5 = newInstances.get(group)) == null ? void 0 : _a5.has(sortable))) {
                  return;
                }
              }
            }
            const sourceElement = source.sortable.element;
            const targetElement = target.sortable.element;
            if (!targetElement || !sourceElement) {
              return;
            }
            if (!sameGroup && target.id === source.sortable.group) {
              return;
            }
            const orderedSourceSortables = sort(sourceInstances);
            const orderedTargetSortables = sameGroup ? orderedSourceSortables : sort(targetInstances);
            const sourceGroup = (_b3 = source.sortable.group) != null ? _b3 : defaultGroup;
            const targetGroup = (_c4 = target.sortable.group) != null ? _c4 : defaultGroup;
            const state = {
              [sourceGroup]: orderedSourceSortables,
              [targetGroup]: orderedTargetSortables
            };
            const newState = move(state, event);
            if (state === newState) return;
            const sourceIndex = newState[targetGroup].indexOf(source.sortable);
            const targetIndex = newState[targetGroup].indexOf(target.sortable);
            manager2.collisionObserver.disable();
            reorder2(sourceElement, sourceIndex, targetElement, targetIndex);
            n(() => {
              for (const [index, sortable] of newState[sourceGroup].entries()) {
                sortable.index = index;
              }
              if (!sameGroup) {
                for (const [index, sortable] of newState[targetGroup].entries()) {
                  sortable.group = target.sortable.group;
                  sortable.index = index;
                }
              }
            });
            manager2.actions.setDropTarget(source.id).then(() => manager2.collisionObserver.enable());
          });
        });
      }),
      manager.monitor.addEventListener("dragend", (event, manager2) => {
        if (!event.canceled) {
          return;
        }
        const { dragOperation } = manager2;
        const { source } = dragOperation;
        if (!isSortable(source)) {
          return;
        }
        if (source.sortable.initialIndex === source.sortable.index && source.sortable.initialGroup === source.sortable.group) {
          return;
        }
        queueMicrotask(() => {
          const instances = getSortableInstances();
          const initialGroupInstances = instances.get(
            source.sortable.initialGroup
          );
          if (!initialGroupInstances) return;
          manager2.renderer.rendering.then(() => {
            for (const [group, sortableInstances] of instances.entries()) {
              const entries = Array.from(sortableInstances).entries();
              for (const [index, sortable] of entries) {
                if (sortable.index !== index || sortable.group !== group) {
                  return;
                }
              }
            }
            const initialGroup = sort(initialGroupInstances);
            const sourceElement = source.sortable.element;
            const target = initialGroup[source.sortable.initialIndex];
            const targetElement = target == null ? void 0 : target.element;
            if (!target || !targetElement || !sourceElement) {
              return;
            }
            reorder2(sourceElement, target.index, targetElement, source.index);
            n(() => {
              for (const [_2, sortableInstances] of instances.entries()) {
                const entries = Array.from(sortableInstances).values();
                for (const sortable of entries) {
                  sortable.index = sortable.initialIndex;
                  sortable.group = sortable.initialGroup;
                }
              }
            });
          });
        });
      })
    ];
    this.destroy = () => {
      for (const unsubscribeListener of unsubscribe) {
        unsubscribeListener();
      }
    };
  }
};
function reorder2(sourceElement, sourceIndex, targetElement, targetIndex) {
  const position = targetIndex < sourceIndex ? "afterend" : "beforebegin";
  targetElement.insertAdjacentElement(position, sourceElement);
}
function sortByIndex(a2, b2) {
  return a2.index - b2.index;
}
function sort(instances) {
  return Array.from(instances).sort(sortByIndex);
}
var defaultPlugins = [
  SortableKeyboardPlugin,
  OptimisticSortingPlugin
];
var defaultSortableTransition = {
  duration: 250,
  easing: "cubic-bezier(0.25, 1, 0.5, 1)",
  idle: false
};
var store = new WeakStore();
var _group_dec;
var _index_dec;
var _init9;
var _index;
var _previousGroup;
var _previousIndex;
var _group;
var _element3;
_index_dec = [reactive], _group_dec = [reactive];
var Sortable2 = class {
  constructor(_a5, manager) {
    __privateAdd7(this, _index, __runInitializers6(_init9, 8, this)), __runInitializers6(_init9, 11, this);
    __privateAdd7(this, _previousGroup);
    __privateAdd7(this, _previousIndex);
    __privateAdd7(this, _group, __runInitializers6(_init9, 12, this)), __runInitializers6(_init9, 15, this);
    __privateAdd7(this, _element3);
    this.register = () => {
      n(() => {
        var _a6, _b4;
        (_a6 = this.manager) == null ? void 0 : _a6.registry.register(this.droppable);
        (_b4 = this.manager) == null ? void 0 : _b4.registry.register(this.draggable);
      });
      return () => this.unregister();
    };
    this.unregister = () => {
      n(() => {
        var _a6, _b4;
        (_a6 = this.manager) == null ? void 0 : _a6.registry.unregister(this.droppable);
        (_b4 = this.manager) == null ? void 0 : _b4.registry.unregister(this.draggable);
      });
    };
    this.destroy = () => {
      n(() => {
        this.droppable.destroy();
        this.draggable.destroy();
      });
    };
    var _b3 = _a5, {
      effects: inputEffects = () => [],
      group,
      index,
      sensors,
      type,
      transition = defaultSortableTransition,
      plugins = defaultPlugins
    } = _b3, input = __objRest5(_b3, [
      "effects",
      "group",
      "index",
      "sensors",
      "type",
      "transition",
      "plugins"
    ]);
    this.droppable = new SortableDroppable(input, manager, this);
    this.draggable = new SortableDraggable(
      __spreadProps6(__spreadValues7({}, input), {
        effects: () => [
          () => {
            var _a23, _b22, _c4;
            const status = (_a23 = this.manager) == null ? void 0 : _a23.dragOperation.status;
            if ((status == null ? void 0 : status.initializing) && this.id === ((_c4 = (_b22 = this.manager) == null ? void 0 : _b22.dragOperation.source) == null ? void 0 : _c4.id)) {
              store.clear(this.manager);
            }
            if (status == null ? void 0 : status.dragging) {
              store.set(
                this.manager,
                this.id,
                o(() => ({
                  initialIndex: this.index,
                  initialGroup: this.group
                }))
              );
            }
          },
          () => {
            const { index: index2, group: group2, manager: _2 } = this;
            const previousIndex = __privateGet7(this, _previousIndex);
            const previousGroup = __privateGet7(this, _previousGroup);
            if (index2 !== previousIndex || group2 !== previousGroup) {
              __privateSet7(this, _previousIndex, index2);
              __privateSet7(this, _previousGroup, group2);
              this.animate();
            }
          },
          () => {
            const { target } = this;
            const { feedback, isDragSource } = this.draggable;
            if (feedback == "move" && isDragSource) {
              this.droppable.disabled = !target;
            }
          },
          () => {
            const { manager: manager2 } = this;
            for (const plugin of plugins) {
              manager2 == null ? void 0 : manager2.registry.register(plugin);
            }
          },
          ...inputEffects()
        ],
        type,
        sensors
      }),
      manager,
      this
    );
    __privateSet7(this, _element3, input.element);
    this.manager = manager;
    this.index = index;
    __privateSet7(this, _previousIndex, index);
    this.group = group;
    __privateSet7(this, _previousGroup, group);
    this.type = type;
    this.transition = transition;
  }
  get initialIndex() {
    var _a5, _b3;
    return (_b3 = (_a5 = store.get(this.manager, this.id)) == null ? void 0 : _a5.initialIndex) != null ? _b3 : this.index;
  }
  get initialGroup() {
    var _a5, _b3;
    return (_b3 = (_a5 = store.get(this.manager, this.id)) == null ? void 0 : _a5.initialGroup) != null ? _b3 : this.group;
  }
  animate() {
    o(() => {
      const { manager, transition } = this;
      const { shape } = this.droppable;
      if (!manager) return;
      const { idle } = manager.dragOperation.status;
      if (!shape || !transition || idle && !transition.idle) {
        return;
      }
      manager.renderer.rendering.then(() => {
        const { element } = this;
        if (!element) {
          return;
        }
        const updatedShape = this.refreshShape();
        if (!updatedShape) {
          return;
        }
        const delta = {
          x: shape.boundingRectangle.left - updatedShape.boundingRectangle.left,
          y: shape.boundingRectangle.top - updatedShape.boundingRectangle.top
        };
        const { translate } = getComputedStyles(element);
        const currentTranslate = computeTranslate(element, translate, false);
        const finalTranslate = computeTranslate(element, translate);
        if (delta.x || delta.y) {
          animateTransform({
            element,
            keyframes: {
              translate: [
                `${currentTranslate.x + delta.x}px ${currentTranslate.y + delta.y}px ${currentTranslate.z}`,
                `${finalTranslate.x}px ${finalTranslate.y}px ${finalTranslate.z}`
              ]
            },
            options: transition
          }).then(() => {
            if (!manager.dragOperation.status.dragging) {
              this.droppable.shape = void 0;
            }
          });
        }
      });
    });
  }
  get manager() {
    return this.draggable.manager;
  }
  set manager(manager) {
    n(() => {
      this.draggable.manager = manager;
      this.droppable.manager = manager;
    });
  }
  set element(element) {
    n(() => {
      const previousElement = __privateGet7(this, _element3);
      const droppableElement = this.droppable.element;
      const draggableElement = this.draggable.element;
      if (!droppableElement || droppableElement === previousElement) {
        this.droppable.element = element;
      }
      if (!draggableElement || draggableElement === previousElement) {
        this.draggable.element = element;
      }
      __privateSet7(this, _element3, element);
    });
  }
  get element() {
    var _a5, _b3;
    const element = __privateGet7(this, _element3);
    if (!element) return;
    return (_b3 = (_a5 = ProxiedElements.get(element)) != null ? _a5 : element) != null ? _b3 : this.droppable.element;
  }
  set target(target) {
    this.droppable.element = target;
  }
  get target() {
    return this.droppable.element;
  }
  set source(source) {
    this.draggable.element = source;
  }
  get source() {
    return this.draggable.element;
  }
  get disabled() {
    return this.draggable.disabled && this.droppable.disabled;
  }
  set feedback(value) {
    this.draggable.feedback = value;
  }
  set disabled(value) {
    n(() => {
      this.droppable.disabled = value;
      this.draggable.disabled = value;
    });
  }
  set data(data) {
    n(() => {
      this.droppable.data = data;
      this.draggable.data = data;
    });
  }
  set handle(handle) {
    this.draggable.handle = handle;
  }
  set id(id) {
    n(() => {
      this.droppable.id = id;
      this.draggable.id = id;
    });
  }
  get id() {
    return this.droppable.id;
  }
  set sensors(value) {
    this.draggable.sensors = value;
  }
  set modifiers(value) {
    this.draggable.modifiers = value;
  }
  set collisionPriority(value) {
    this.droppable.collisionPriority = value;
  }
  set collisionDetector(value) {
    this.droppable.collisionDetector = value != null ? value : defaultCollisionDetection;
  }
  set alignment(value) {
    this.draggable.alignment = value;
  }
  get alignment() {
    return this.draggable.alignment;
  }
  set type(type) {
    n(() => {
      this.droppable.type = type;
      this.draggable.type = type;
    });
  }
  get type() {
    return this.draggable.type;
  }
  set accept(value) {
    this.droppable.accept = value;
  }
  get accept() {
    return this.droppable.accept;
  }
  get isDropTarget() {
    return this.droppable.isDropTarget;
  }
  /**
   * A boolean indicating whether the sortable item is the source of a drag operation.
   */
  get isDragSource() {
    return this.draggable.isDragSource;
  }
  /**
   * A boolean indicating whether the sortable item is being dragged.
   */
  get isDragging() {
    return this.draggable.isDragging;
  }
  /**
   * A boolean indicating whether the sortable item is being dropped.
   */
  get isDropping() {
    return this.draggable.isDropping;
  }
  get status() {
    return this.draggable.status;
  }
  refreshShape() {
    return this.droppable.refreshShape();
  }
  accepts(draggable) {
    return this.droppable.accepts(draggable);
  }
};
_init9 = __decoratorStart6();
_index = /* @__PURE__ */ new WeakMap();
_previousGroup = /* @__PURE__ */ new WeakMap();
_previousIndex = /* @__PURE__ */ new WeakMap();
_group = /* @__PURE__ */ new WeakMap();
_element3 = /* @__PURE__ */ new WeakMap();
__decorateElement6(_init9, 4, "index", _index_dec, Sortable2, _index);
__decorateElement6(_init9, 4, "group", _group_dec, Sortable2, _group);
__decoratorMetadata6(_init9, Sortable2);
var SortableDraggable = class extends Draggable2 {
  constructor(input, manager, sortable) {
    super(input, manager);
    this.sortable = sortable;
  }
  get index() {
    return this.sortable.index;
  }
};
var SortableDroppable = class extends Droppable2 {
  constructor(input, manager, sortable) {
    super(input, manager);
    this.sortable = sortable;
  }
};

// node_modules/@puckeditor/core/node_modules/@dnd-kit/react/sortable.js
var __defProp7 = Object.defineProperty;
var __defProps6 = Object.defineProperties;
var __getOwnPropDescs6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols7 = Object.getOwnPropertySymbols;
var __hasOwnProp7 = Object.prototype.hasOwnProperty;
var __propIsEnum7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues8 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp7.call(b2, prop))
      __defNormalProp7(a2, prop, b2[prop]);
  if (__getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(b2)) {
      if (__propIsEnum7.call(b2, prop))
        __defNormalProp7(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps7 = (a2, b2) => __defProps6(a2, __getOwnPropDescs6(b2));
function useSortable(input) {
  const {
    accept,
    collisionDetector,
    collisionPriority,
    id,
    data,
    element,
    handle,
    index,
    group,
    disabled,
    feedback,
    modifiers,
    sensors,
    target,
    type
  } = input;
  const transition = __spreadValues8(__spreadValues8({}, defaultSortableTransition), input.transition);
  const sortable = useInstance((manager) => {
    return new Sortable2(
      __spreadProps7(__spreadValues8({}, input), {
        transition,
        register: false,
        handle: currentValue(handle),
        element: currentValue(element),
        target: currentValue(target),
        feedback
      }),
      manager
    );
  });
  const trackedSortable = useDeepSignal(sortable, shouldUpdateSynchronously2);
  useOnValueChange(id, () => sortable.id = id);
  useIsomorphicLayoutEffect(() => {
    n(() => {
      sortable.group = group;
      sortable.index = index;
    });
  }, [sortable, group, index]);
  useOnValueChange(type, () => sortable.type = type);
  useOnValueChange(
    accept,
    () => sortable.accept = accept,
    void 0,
    deepEqual2
  );
  useOnValueChange(data, () => data && (sortable.data = data));
  useOnValueChange(
    index,
    () => {
      var _a5;
      if (((_a5 = sortable.manager) == null ? void 0 : _a5.dragOperation.status.idle) && (transition == null ? void 0 : transition.idle)) {
        sortable.refreshShape();
      }
    },
    useImmediateEffect
  );
  useOnElementChange(handle, (handle2) => sortable.handle = handle2);
  useOnElementChange(element, (element2) => sortable.element = element2);
  useOnElementChange(target, (target2) => sortable.target = target2);
  useOnValueChange(disabled, () => sortable.disabled = disabled === true);
  useOnValueChange(sensors, () => sortable.sensors = sensors);
  useOnValueChange(
    collisionDetector,
    () => sortable.collisionDetector = collisionDetector
  );
  useOnValueChange(
    collisionPriority,
    () => sortable.collisionPriority = collisionPriority
  );
  useOnValueChange(feedback, () => sortable.feedback = feedback != null ? feedback : "default");
  useOnValueChange(
    transition,
    () => sortable.transition = transition,
    void 0,
    deepEqual2
  );
  useOnValueChange(
    modifiers,
    () => sortable.modifiers = modifiers,
    void 0,
    deepEqual2
  );
  useOnValueChange(
    input.alignment,
    () => sortable.alignment = input.alignment
  );
  return {
    sortable: trackedSortable,
    get isDragging() {
      return trackedSortable.isDragging;
    },
    get isDropping() {
      return trackedSortable.isDropping;
    },
    get isDragSource() {
      return trackedSortable.isDragSource;
    },
    get isDropTarget() {
      return trackedSortable.isDropTarget;
    },
    handleRef: (0, import_react7.useCallback)(
      (element2) => {
        sortable.handle = element2 != null ? element2 : void 0;
      },
      [sortable]
    ),
    ref: (0, import_react7.useCallback)(
      (element2) => {
        var _a5, _b3;
        if (!element2 && ((_a5 = sortable.element) == null ? void 0 : _a5.isConnected) && !((_b3 = sortable.manager) == null ? void 0 : _b3.dragOperation.status.idle)) {
          return;
        }
        sortable.element = element2 != null ? element2 : void 0;
      },
      [sortable]
    ),
    sourceRef: (0, import_react7.useCallback)(
      (element2) => {
        var _a5, _b3;
        if (!element2 && ((_a5 = sortable.source) == null ? void 0 : _a5.isConnected) && !((_b3 = sortable.manager) == null ? void 0 : _b3.dragOperation.status.idle)) {
          return;
        }
        sortable.source = element2 != null ? element2 : void 0;
      },
      [sortable]
    ),
    targetRef: (0, import_react7.useCallback)(
      (element2) => {
        var _a5, _b3;
        if (!element2 && ((_a5 = sortable.target) == null ? void 0 : _a5.isConnected) && !((_b3 = sortable.manager) == null ? void 0 : _b3.dragOperation.status.idle)) {
          return;
        }
        sortable.target = element2 != null ? element2 : void 0;
      },
      [sortable]
    )
  };
}
function shouldUpdateSynchronously2(key, oldValue, newValue) {
  if (key === "isDragSource" && !newValue && oldValue) return true;
  return false;
}

// node_modules/@puckeditor/core/dist/chunk-EBISZQTK.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
var import_react20 = __toESM(require_react(), 1);
var import_react21 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);
var import_react24 = __toESM(require_react(), 1);
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react25 = __toESM(require_react(), 1);
var import_react26 = __toESM(require_react(), 1);
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_react27 = __toESM(require_react(), 1);
var import_react29 = __toESM(require_react(), 1);
var import_react30 = __toESM(require_react(), 1);
var import_react31 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var import_react32 = __toESM(require_react(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_react33 = __toESM(require_react(), 1);
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var import_react35 = __toESM(require_react(), 1);
var import_react36 = __toESM(require_react(), 1);
var import_react38 = __toESM(require_react(), 1);
var import_react39 = __toESM(require_react(), 1);
var import_react40 = __toESM(require_react(), 1);
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react41 = __toESM(require_react(), 1);
var import_react42 = __toESM(require_react(), 1);
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_react43 = __toESM(require_react(), 1);
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react44 = __toESM(require_react(), 1);
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react46 = __toESM(require_react(), 1);
var import_react47 = __toESM(require_react(), 1);
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_react48 = __toESM(require_react(), 1);
var import_react49 = __toESM(require_react(), 1);
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react50 = __toESM(require_react(), 1);
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react51 = __toESM(require_react(), 1);
var import_react52 = __toESM(require_react(), 1);
var import_object_hash = __toESM(require_object_hash(), 1);
var import_react_dom4 = __toESM(require_react_dom(), 1);
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var import_react54 = __toESM(require_react(), 1);
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react55 = __toESM(require_react(), 1);
var import_react56 = __toESM(require_react(), 1);
var import_react57 = __toESM(require_react(), 1);
var import_react58 = __toESM(require_react(), 1);
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react59 = __toESM(require_react(), 1);
var import_react60 = __toESM(require_react(), 1);
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_react61 = __toESM(require_react(), 1);
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react62 = __toESM(require_react(), 1);
var import_react63 = __toESM(require_react(), 1);
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react64 = __toESM(require_react(), 1);
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);
var import_react66 = __toESM(require_react(), 1);
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var import_react67 = __toESM(require_react(), 1);
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var overrideKeys = [
  "header",
  "headerActions",
  "fields",
  "fieldLabel",
  "drawer",
  "drawerItem",
  "componentOverlay",
  "outline",
  "puck",
  "preview"
];
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var styles_module_default2 = { "InputWrapper": "_InputWrapper_bsxfo_1", "Input-label": "_Input-label_bsxfo_5", "Input-labelIcon": "_Input-labelIcon_bsxfo_14", "Input-disabledIcon": "_Input-disabledIcon_bsxfo_21", "Input-input": "_Input-input_bsxfo_26", "Input": "_Input_bsxfo_1", "Input--readOnly": "_Input--readOnly_bsxfo_82", "Input-radioGroupItems": "_Input-radioGroupItems_bsxfo_93", "Input-radio": "_Input-radio_bsxfo_93", "Input-radioInner": "_Input-radioInner_bsxfo_110", "Input-radioInput": "_Input-radioInput_bsxfo_155" };
init_react_import();
init_react_import();
init_react_import();
var styles_module_default22 = { "ArrayField": "_ArrayField_1vaho_5", "ArrayField--isDraggingFrom": "_ArrayField--isDraggingFrom_1vaho_13", "ArrayField-addButton": "_ArrayField-addButton_1vaho_18", "ArrayField--hasItems": "_ArrayField--hasItems_1vaho_33", "ArrayField-inner": "_ArrayField-inner_1vaho_59", "ArrayFieldItem": "_ArrayFieldItem_1vaho_67", "ArrayFieldItem--isDragging": "_ArrayFieldItem--isDragging_1vaho_78", "ArrayFieldItem--isExpanded": "_ArrayFieldItem--isExpanded_1vaho_82", "ArrayFieldItem-summary": "_ArrayFieldItem-summary_1vaho_97", "ArrayFieldItem--noFields": "_ArrayFieldItem--noFields_1vaho_122", "ArrayField--addDisabled": "_ArrayField--addDisabled_1vaho_131", "ArrayFieldItem-body": "_ArrayFieldItem-body_1vaho_170", "ArrayFieldItem-fieldset": "_ArrayFieldItem-fieldset_1vaho_179", "ArrayFieldItem-rhs": "_ArrayFieldItem-rhs_1vaho_187", "ArrayFieldItem-actions": "_ArrayFieldItem-actions_1vaho_193" };
init_react_import();
init_react_import();
function useContextStore(context, selector) {
  const store2 = (0, import_react11.useContext)(context);
  if (!store2) {
    throw new Error("useContextStore must be used inside context");
  }
  return useStore(store2, useShallow(selector));
}
function createStoreProvider(ContextComponent) {
  const StoreProvider = ({
    children,
    value
  }) => {
    const [store2] = (0, import_react11.useState)(() => createStore(() => value));
    return (0, import_jsx_runtime5.jsx)(ContextComponent.Provider, { value: store2, children });
  };
  return StoreProvider;
}
function createContextStore(defaultValue) {
  const ctx = (0, import_react11.createContext)(
    createStore(subscribeWithSelector(() => defaultValue))
  );
  return {
    ctx,
    Provider: createStoreProvider(ctx)
  };
}
var fieldContextStore = createContextStore({});
var useFieldStoreApi = () => (0, import_react10.useContext)(fieldContextStore.ctx);
function useFieldStore(selector) {
  const store2 = (0, import_react10.useContext)(fieldContextStore.ctx);
  if (!store2) {
    throw new Error("useContextStore must be used inside context");
  }
  return useStore(store2, useShallow(selector));
}
init_react_import();
init_react_import();
var styles_module_default3 = { "DragIcon": "_DragIcon_17p8x_1", "DragIcon--disabled": "_DragIcon--disabled_17p8x_8" };
var getClassName2 = get_class_name_factory_default("DragIcon", styles_module_default3);
var DragIcon = ({ isDragDisabled }) => (0, import_jsx_runtime6.jsx)("div", { className: getClassName2({ disabled: isDragDisabled }), children: (0, import_jsx_runtime6.jsx)("svg", { viewBox: "0 0 20 20", width: "12", fill: "currentColor", children: (0, import_jsx_runtime6.jsx)("path", { d: "M7 2a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 2zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 8zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 14zm6-8a2 2 0 1 0-.001-4.001A2 2 0 0 0 13 6zm0 2a2 2 0 1 0 .001 4.001A2 2 0 0 0 13 8zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 13 14z" }) }) });
init_react_import();
init_react_import();
var touchDefault = { delay: { value: 200, tolerance: 10 } };
var otherDefault = {
  delay: { value: 200, tolerance: 10 },
  distance: { value: 5 }
};
var useSensors = ({
  other = otherDefault,
  mouse,
  touch = touchDefault
} = {
  touch: touchDefault,
  other: otherDefault
}) => {
  const [sensors] = (0, import_react14.useState)(() => [
    PointerSensor.configure({
      activationConstraints(event, source) {
        var _a5;
        const { pointerType, target } = event;
        if (pointerType === "mouse" && isElement(target) && (source.handle === target || ((_a5 = source.handle) == null ? void 0 : _a5.contains(target)))) {
          return mouse;
        }
        if (pointerType === "touch") {
          return touch;
        }
        return other;
      }
    })
  ]);
  return sensors;
};
init_react_import();
init_react_import();
init_react_import();
var DEBUG = false;
var debugElements = {};
var timeout2;
var collisionDebug = (a2, b2, id, color, label) => {
  if (!DEBUG) return;
  const debugId = `${id}-debug`;
  clearTimeout(timeout2);
  timeout2 = setTimeout(() => {
    Object.entries(debugElements).forEach(([id2, { svg }]) => {
      svg.remove();
      delete debugElements[id2];
    });
  }, 1e3);
  requestAnimationFrame(() => {
    var _a5, _b3;
    const existingEl = debugElements[debugId];
    let line = (_a5 = debugElements[debugId]) == null ? void 0 : _a5.line;
    let text = (_b3 = debugElements[debugId]) == null ? void 0 : _b3.text;
    if (!existingEl) {
      const svgNs = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNs, "svg");
      line = document.createElementNS(svgNs, "line");
      text = document.createElementNS(svgNs, "text");
      svg.setAttribute("id", debugId);
      svg.setAttribute(
        "style",
        "position: fixed; height: 100%; width: 100%; pointer-events: none; top: 0px; left: 0px;"
      );
      svg.appendChild(line);
      svg.appendChild(text);
      text.setAttribute("fill", `black`);
      document.body.appendChild(svg);
      debugElements[debugId] = { svg, line, text };
    }
    line.setAttribute("x1", a2.x.toString());
    line.setAttribute("x2", b2.x.toString());
    line.setAttribute("y1", a2.y.toString());
    line.setAttribute("y2", b2.y.toString());
    line.setAttribute("style", `stroke:${color};stroke-width:2`);
    text.setAttribute("x", (a2.x - (a2.x - b2.x) / 2).toString());
    text.setAttribute("y", (a2.y - (a2.y - b2.y) / 2).toString());
    if (label) {
      text.innerHTML = label;
    }
  });
};
var distanceChange = "increasing";
var directionalCollision = (input, previous) => {
  var _a5;
  const { dragOperation, droppable } = input;
  const { shape: dropShape } = droppable;
  const { position } = dragOperation;
  const dragShape = (_a5 = dragOperation.shape) == null ? void 0 : _a5.current;
  if (!dragShape || !dropShape) return null;
  const dropCenter = dropShape.center;
  const distanceToPrevious = Math.sqrt(
    Math.pow(dropCenter.x - previous.x, 2) + Math.pow(dropCenter.y - previous.y, 2)
  );
  const distanceToCurrent = Math.sqrt(
    Math.pow(dropCenter.x - position.current.x, 2) + Math.pow(dropCenter.y - position.current.y, 2)
  );
  distanceChange = distanceToCurrent === distanceToPrevious ? distanceChange : distanceToCurrent < distanceToPrevious ? "decreasing" : "increasing";
  collisionDebug(
    dragShape.center,
    dropCenter,
    droppable.id.toString(),
    "rebeccapurple"
  );
  if (distanceChange === "decreasing") {
    return {
      id: droppable.id,
      value: 1,
      type: CollisionType.Collision
    };
  }
  return null;
};
init_react_import();
var getDirection3 = (dragAxis, delta) => {
  if (dragAxis === "dynamic") {
    if (Math.abs(delta.y) > Math.abs(delta.x)) {
      return delta.y === 0 ? null : delta.y > 0 ? "down" : "up";
    } else {
      return delta.x === 0 ? null : delta.x > 0 ? "right" : "left";
    }
  } else if (dragAxis === "x") {
    return delta.x === 0 ? null : delta.x > 0 ? "right" : "left";
  }
  return delta.y === 0 ? null : delta.y > 0 ? "down" : "up";
};
init_react_import();
var getMidpointImpact = (dragShape, dropShape, direction, offsetMultiplier = 0) => {
  const dragRect = dragShape.boundingRectangle;
  const dropCenter = dropShape.center;
  if (direction === "down") {
    const offset2 = offsetMultiplier * dropShape.boundingRectangle.height;
    return dragRect.bottom >= dropCenter.y + offset2;
  } else if (direction === "up") {
    const offset2 = offsetMultiplier * dropShape.boundingRectangle.height;
    return dragRect.top < dropCenter.y - offset2;
  } else if (direction === "left") {
    const offset2 = offsetMultiplier * dropShape.boundingRectangle.width;
    return dropCenter.x - offset2 >= dragRect.left;
  }
  const offset = offsetMultiplier * dropShape.boundingRectangle.width;
  return dragRect.right - offset >= dropCenter.x;
};
init_react_import();
var INTERVAL_SENSITIVITY = 10;
var intervalCache = {
  current: { x: 0, y: 0 },
  delta: { x: 0, y: 0 },
  previous: { x: 0, y: 0 },
  direction: null
};
var trackMovementInterval = (point, dragAxis = "dynamic") => {
  intervalCache.current = point;
  intervalCache.delta = {
    x: point.x - intervalCache.previous.x,
    y: point.y - intervalCache.previous.y
  };
  intervalCache.direction = getDirection3(dragAxis, intervalCache.delta) || intervalCache.direction;
  if (Math.abs(intervalCache.delta.x) > INTERVAL_SENSITIVITY || Math.abs(intervalCache.delta.y) > INTERVAL_SENSITIVITY) {
    intervalCache.previous = Point.from(point);
  }
  return intervalCache;
};
init_react_import();
var pointerIntersection3 = ({
  dragOperation,
  droppable
}) => {
  const pointerCoordinates = dragOperation.position.current;
  if (!pointerCoordinates) {
    return null;
  }
  const { id } = droppable;
  if (!droppable.shape) {
    return null;
  }
  if (droppable.shape.containsPoint(pointerCoordinates)) {
    const distance = Point.distance(droppable.shape.center, pointerCoordinates);
    return {
      id,
      value: 1 / distance,
      type: CollisionType.PointerIntersection,
      priority: CollisionPriority.High
    };
  }
  return null;
};
var closestCorners2 = (input) => {
  const { dragOperation, droppable } = input;
  const { shape, position } = dragOperation;
  if (!droppable.shape) {
    return null;
  }
  const shapeCorners = shape ? Rectangle.from(shape.current.boundingRectangle).corners : void 0;
  const distance = Rectangle.from(
    droppable.shape.boundingRectangle
  ).corners.reduce(
    (acc, corner, index) => {
      var _a5;
      return acc + Point.distance(
        Point.from(corner),
        (_a5 = shapeCorners == null ? void 0 : shapeCorners[index]) != null ? _a5 : position.current
      );
    },
    0
  );
  const value = distance / 4;
  return {
    id: droppable.id,
    value: 1 / value,
    type: CollisionType.Collision,
    priority: CollisionPriority.Normal
  };
};
init_react_import();
var collisionStore = createStore(() => ({
  fallbackEnabled: false
}));
var flushNext = "";
var createDynamicCollisionDetector = (dragAxis, midpointOffset = 0.05) => ((input) => {
  var _a5, _b3, _c4, _d2, _e;
  const { dragOperation, droppable } = input;
  const { position } = dragOperation;
  const dragShape = (_a5 = dragOperation.shape) == null ? void 0 : _a5.current;
  const { shape: dropShape } = droppable;
  if (!dragShape || !dropShape) {
    return null;
  }
  const { center: dragCenter } = dragShape;
  const { fallbackEnabled } = collisionStore.getState();
  const interval = trackMovementInterval(position.current, dragAxis);
  const data = {
    direction: interval.direction
  };
  const { center: dropCenter } = dropShape;
  const overMidpoint = getMidpointImpact(
    dragShape,
    dropShape,
    interval.direction,
    midpointOffset
  );
  if (((_b3 = dragOperation.source) == null ? void 0 : _b3.id) === droppable.id) {
    const collision = directionalCollision(input, interval.previous);
    collisionDebug(dragCenter, dropCenter, droppable.id.toString(), "yellow");
    if (collision) {
      return __spreadProps(__spreadValues({}, collision), {
        priority: CollisionPriority.Highest,
        data
      });
    }
  }
  const intersectionArea = dragShape.intersectionArea(dropShape);
  const intersectionRatio = intersectionArea / dropShape.area;
  if (intersectionArea && overMidpoint) {
    collisionDebug(
      dragCenter,
      dropCenter,
      droppable.id.toString(),
      "green",
      interval.direction
    );
    const collision = {
      id: droppable.id,
      value: intersectionRatio,
      priority: CollisionPriority.High,
      type: CollisionType.Collision
    };
    const shouldFlushId = flushNext === droppable.id;
    flushNext = "";
    return __spreadProps(__spreadValues({}, collision), { id: shouldFlushId ? "flush" : collision.id, data });
  }
  if (fallbackEnabled && ((_c4 = dragOperation.source) == null ? void 0 : _c4.id) !== droppable.id) {
    const xAxisIntersection = dropShape.boundingRectangle.right > dragShape.boundingRectangle.left && dropShape.boundingRectangle.left < dragShape.boundingRectangle.right;
    const yAxisIntersection = dropShape.boundingRectangle.bottom > dragShape.boundingRectangle.top && dropShape.boundingRectangle.top < dragShape.boundingRectangle.bottom;
    if (dragAxis === "y" && xAxisIntersection || yAxisIntersection) {
      const fallbackCollision = closestCorners2(input);
      if (fallbackCollision) {
        const direction = getDirection3(dragAxis, {
          x: dragShape.center.x - (((_d2 = droppable.shape) == null ? void 0 : _d2.center.x) || 0),
          y: dragShape.center.y - (((_e = droppable.shape) == null ? void 0 : _e.center.y) || 0)
        });
        data.direction = direction;
        if (intersectionArea) {
          collisionDebug(
            dragCenter,
            dropCenter,
            droppable.id.toString(),
            "red",
            direction || ""
          );
          flushNext = droppable.id;
          return __spreadProps(__spreadValues({}, fallbackCollision), {
            priority: CollisionPriority.Low,
            data
          });
        }
        collisionDebug(
          dragCenter,
          dropCenter,
          droppable.id.toString(),
          "orange",
          direction || ""
        );
        return __spreadProps(__spreadValues({}, fallbackCollision), {
          priority: CollisionPriority.Lowest,
          data
        });
      }
    }
  }
  collisionDebug(dragCenter, dropCenter, droppable.id.toString(), "hotpink");
  return null;
});
var SortableProvider = ({
  children,
  onDragStart,
  onDragEnd,
  onMove
}) => {
  const sensors = useSensors({
    mouse: { distance: { value: 5 } }
  });
  return (0, import_jsx_runtime7.jsx)(
    DragDropProvider,
    {
      sensors,
      onDragStart: (event) => {
        var _a5, _b3;
        return onDragStart((_b3 = (_a5 = event.operation.source) == null ? void 0 : _a5.id.toString()) != null ? _b3 : "");
      },
      onDragOver: (event, manager) => {
        var _a5;
        event.preventDefault();
        const { operation } = event;
        const { source, target } = operation;
        if (!source || !target) return;
        let sourceIndex = source.data.index;
        let targetIndex = target.data.index;
        const collisionData = (_a5 = manager.collisionObserver.collisions[0]) == null ? void 0 : _a5.data;
        if (sourceIndex !== targetIndex && source.id !== target.id) {
          const collisionPosition = (collisionData == null ? void 0 : collisionData.direction) === "up" ? "before" : "after";
          if (targetIndex >= sourceIndex) {
            targetIndex = targetIndex - 1;
          }
          if (collisionPosition === "after") {
            targetIndex = targetIndex + 1;
          }
          onMove({
            source: sourceIndex,
            target: targetIndex
          });
        }
      },
      onDragEnd: () => {
        setTimeout(() => {
          onDragEnd();
        }, 250);
      },
      children
    }
  );
};
var Sortable = ({
  id,
  index,
  disabled,
  children,
  type = "item"
}) => {
  const {
    ref: sortableRef,
    isDragging,
    isDropping,
    handleRef
  } = useSortable({
    id,
    type,
    index,
    disabled,
    data: { index },
    collisionDetector: createDynamicCollisionDetector("y")
  });
  return children({ isDragging, isDropping, ref: sortableRef, handleRef });
};
init_react_import();
var NestedFieldContext = (0, import_react16.createContext)({});
var useNestedFieldContext = () => {
  const context = (0, import_react16.useContext)(NestedFieldContext);
  return __spreadProps(__spreadValues({}, context), {
    readOnlyFields: context.readOnlyFields || {}
  });
};
var NestedFieldProvider = ({
  children,
  name,
  subName,
  wildcardName = name,
  readOnlyFields
}) => {
  const subPath = `${name}.${subName}`;
  const wildcardSubPath = `${wildcardName}.${subName}`;
  const subReadOnlyFields = (0, import_react16.useMemo)(
    () => Object.keys(readOnlyFields).reduce((acc, readOnlyKey) => {
      const isLocal = readOnlyKey.indexOf(subPath) > -1 || readOnlyKey.indexOf(wildcardSubPath) > -1;
      if (isLocal) {
        const subPathPattern = new RegExp(
          `^(${name}|${wildcardName}).`.replace(/\[/g, "\\[").replace(/\]/g, "\\]").replace(/\./g, "\\.").replace(/\*/g, "\\*")
        );
        const localName = readOnlyKey.replace(subPathPattern, "");
        return __spreadProps(__spreadValues({}, acc), {
          [localName]: readOnlyFields[readOnlyKey]
        });
      }
      return acc;
    }, {}),
    [name, subName, wildcardName, readOnlyFields]
  );
  return (0, import_jsx_runtime8.jsx)(
    NestedFieldContext.Provider,
    {
      value: { readOnlyFields: subReadOnlyFields, localName: subName },
      children
    }
  );
};
init_react_import();
var getDeep = (node, path) => {
  const pathParts = path.split(".");
  return pathParts.reduce((acc, item) => {
    if (!acc) return;
    const [prop, indexStr] = item.replace("]", "").split("[");
    const val = acc[prop];
    if (indexStr && val) {
      return val[parseInt(indexStr)];
    }
    return val;
  }, node);
};
init_react_import();
var SubFieldInternal = ({
  field,
  id,
  index,
  name,
  subName,
  localName,
  onChange,
  forceReadOnly
}) => {
  const indexName = typeof index !== "undefined" ? `${name}[${index}]` : name;
  const subPath = name ? `${indexName}.${subName}` : subName;
  const localIndexName = typeof index !== "undefined" ? `${localName}[${index}]` : localName != null ? localName : subName;
  const localWildcardName = typeof index !== "undefined" ? `${localName}[*]` : localName;
  const localSubPath = `${localIndexName}.${subName}`;
  const localWildcardSubPath = `${localWildcardName}.${subName}`;
  const { readOnlyFields } = useNestedFieldContext();
  const subReadOnly = forceReadOnly ? forceReadOnly : typeof readOnlyFields[subPath] !== "undefined" ? readOnlyFields[localSubPath] : readOnlyFields[localWildcardSubPath];
  const label = field.label || subName;
  return (0, import_jsx_runtime9.jsx)(
    NestedFieldProvider,
    {
      name: localIndexName,
      wildcardName: localWildcardName,
      subName,
      readOnlyFields,
      children: (0, import_jsx_runtime9.jsx)(
        AutoFieldPrivate,
        {
          name: subPath,
          label,
          id,
          readOnly: subReadOnly,
          field: __spreadProps(__spreadValues({}, field), {
            label
            // May be used by custom fields
          }),
          onChange: (val, ui) => {
            onChange(val, ui, subName);
          }
        }
      )
    }
  );
};
var SubField = (0, import_react17.memo)(SubFieldInternal);
var getClassName22 = get_class_name_factory_default("ArrayField", styles_module_default22);
var getClassNameItem = get_class_name_factory_default("ArrayFieldItem", styles_module_default22);
var ItemSummaryInner = ({
  index,
  originalIndex,
  field,
  name
}) => {
  const data = useFieldStore((s2) => {
    const path = `${[name]}[${index}]`;
    return getDeep(s2, path);
  });
  const itemSummary = (0, import_react12.useMemo)(() => {
    if (data && field.getItemSummary) {
      return field.getItemSummary(data, index);
    }
    return `Item #${originalIndex}`;
  }, [data, field, originalIndex, index]);
  return itemSummary;
};
var ItemSummary = (0, import_react12.memo)(ItemSummaryInner);
var ArrayFieldItemInternal = ({
  id,
  arrayId,
  index,
  dragIndex,
  originalIndex,
  field,
  onChange,
  onToggleExpand,
  readOnly,
  actions,
  name,
  localName
}) => {
  const isExpanded = useAppStore((s2) => {
    var _a5;
    return ((_a5 = s2.state.ui.arrayState[arrayId]) == null ? void 0 : _a5.openId) === id;
  });
  const canEdit = useAppStore(
    (s2) => s2.permissions.getPermissions({ item: s2.selectedItem }).edit
  );
  const hasVisibleFields = (0, import_react12.useMemo)(() => {
    if (!field.arrayFields) {
      return false;
    }
    return Object.values(field.arrayFields).some(
      (subField) => subField.type !== "slot" && subField.visible !== false
    );
  }, [field.arrayFields]);
  return (0, import_jsx_runtime10.jsx)(Sortable, { id, index: dragIndex, disabled: readOnly, children: ({ isDragging, ref, handleRef }) => (0, import_jsx_runtime10.jsxs)(
    "div",
    {
      ref,
      className: getClassNameItem({
        isExpanded: isExpanded && hasVisibleFields,
        isDragging,
        noFields: !hasVisibleFields
      }),
      children: [
        (0, import_jsx_runtime10.jsxs)(
          "div",
          {
            ref: handleRef,
            onClick: (e2) => {
              if (isDragging || !hasVisibleFields) return;
              e2.preventDefault();
              e2.stopPropagation();
              onToggleExpand(id, isExpanded);
            },
            className: getClassNameItem("summary"),
            children: [
              (0, import_jsx_runtime10.jsx)(
                ItemSummary,
                {
                  index,
                  originalIndex,
                  field,
                  name
                }
              ),
              (0, import_jsx_runtime10.jsxs)("div", { className: getClassNameItem("rhs"), children: [
                !readOnly && (0, import_jsx_runtime10.jsx)("div", { className: getClassNameItem("actions"), children: actions }),
                (0, import_jsx_runtime10.jsx)("div", { children: (0, import_jsx_runtime10.jsx)(DragIcon, {}) })
              ] })
            ]
          }
        ),
        (0, import_jsx_runtime10.jsx)("div", { className: getClassNameItem("body"), children: isExpanded && hasVisibleFields && (0, import_jsx_runtime10.jsx)("fieldset", { className: getClassNameItem("fieldset"), children: Object.keys(field.arrayFields).map((subName) => {
          const subField = field.arrayFields[subName];
          return (0, import_jsx_runtime10.jsx)(
            SubField,
            {
              id: `${id}_${subName}`,
              name,
              index,
              subName,
              localName,
              field: subField,
              onChange,
              forceReadOnly: !canEdit
            },
            `${id}_${subName}_${index}`
          );
        }) }) })
      ]
    }
  ) });
};
var ArrayFieldItem = (0, import_react12.memo)(ArrayFieldItemInternal);
var ArrayField = ({
  field,
  onChange,
  id,
  name = id,
  label,
  labelIcon,
  readOnly,
  Label: Label2 = (props) => (0, import_jsx_runtime10.jsx)("div", __spreadValues({}, props))
}) => {
  const setUi = useAppStore((s2) => s2.setUi);
  const appStoreApi = useAppStoreApi();
  const fieldStore = useFieldStoreApi();
  const { localName = name } = useNestedFieldContext();
  const getValue = () => {
    var _a5;
    return (_a5 = getDeep(fieldStore.getState(), name)) != null ? _a5 : [];
  };
  const getArrayState = (0, import_react12.useCallback)(() => {
    var _a5;
    const { state } = appStoreApi.getState();
    const thisState = state.ui.arrayState[id];
    if ((_a5 = thisState == null ? void 0 : thisState.items) == null ? void 0 : _a5.length) return thisState;
    const value = getValue();
    return {
      items: Array.from(value || []).map((item, idx) => {
        return {
          _originalIndex: idx,
          _currentIndex: idx,
          _arrayId: `${id}-${idx}`
        };
      }),
      openId: ""
    };
  }, [appStoreApi, id, getValue, name]);
  const numItems = useFieldStore(() => {
    return getValue().length;
  });
  const defaultArrayState = (0, import_react12.useMemo)(getArrayState, [getArrayState]);
  const mirror = useAppStore((s2) => {
    const thisArrayState = s2.state.ui.arrayState[id];
    return thisArrayState != null ? thisArrayState : defaultArrayState;
  });
  const appStore = useAppStoreApi();
  const mapArrayStateToUi = (0, import_react12.useCallback)(
    (partialArrayState) => {
      const state = appStore.getState().state;
      return {
        arrayState: __spreadProps(__spreadValues({}, state.ui.arrayState), {
          [id]: __spreadValues(__spreadValues({}, getArrayState()), partialArrayState)
        })
      };
    },
    [appStore]
  );
  const getHighestIndex = (0, import_react12.useCallback)(() => {
    return getArrayState().items.reduce(
      (acc, item) => item._originalIndex > acc ? item._originalIndex : acc,
      -1
    );
  }, []);
  const regenerateArrayState = (0, import_react12.useCallback)((value) => {
    let highestIndex = getHighestIndex();
    const arrayState = getArrayState();
    const newItems = Array.from(value || []).map((item, idx) => {
      var _a5, _b3, _c4;
      const arrayStateItem = arrayState.items[idx];
      const newItem = {
        _originalIndex: (_a5 = arrayStateItem == null ? void 0 : arrayStateItem._originalIndex) != null ? _a5 : highestIndex + 1,
        _currentIndex: (_b3 = arrayStateItem == null ? void 0 : arrayStateItem._currentIndex) != null ? _b3 : idx,
        _arrayId: ((_c4 = arrayState.items[idx]) == null ? void 0 : _c4._arrayId) || `${id}-${highestIndex + 1}`
      };
      if (newItem._originalIndex > highestIndex) {
        highestIndex = newItem._originalIndex;
      }
      return newItem;
    });
    return __spreadProps(__spreadValues({}, arrayState), { items: newItems });
  }, []);
  const [draggedItem, setDraggedItem] = (0, import_react12.useState)("");
  const isDraggingAny = !!draggedItem;
  const valueRef = (0, import_react12.useRef)([]);
  (0, import_react12.useEffect)(() => {
    valueRef.current = getValue();
  }, []);
  const uniqifyItem = (0, import_react12.useCallback)(
    (val) => {
      if (field.type !== "array" || !field.arrayFields) return;
      const config = appStore.getState().config;
      return walkField({
        value: val,
        fields: field.arrayFields,
        mappers: {
          slot: ({ value }) => {
            const content = value;
            return content.map((item) => populateIds(item, config, true));
          }
        },
        config
      });
    },
    [appStore, field]
  );
  const syncCurrentIndexes = (0, import_react12.useCallback)(() => {
    const arrayState = getArrayState();
    const newArrayStateItems = arrayState.items.map((item, index) => __spreadProps(__spreadValues({}, item), {
      _currentIndex: index
    }));
    const state = appStore.getState().state;
    const newUi = {
      arrayState: __spreadProps(__spreadValues({}, state.ui.arrayState), {
        [id]: __spreadProps(__spreadValues({}, arrayState), { items: newArrayStateItems })
      })
    };
    setUi(newUi, false);
  }, []);
  const updateValue = (0, import_react12.useCallback)(
    (newValue) => {
      const newArrayState = regenerateArrayState(newValue);
      setUi(mapArrayStateToUi(newArrayState), false);
      onChange(newValue);
    },
    [regenerateArrayState, setUi, mapArrayStateToUi, onChange]
  );
  (0, import_react12.useEffect)(() => {
    const newArrayState = regenerateArrayState(getValue());
    setUi(mapArrayStateToUi(newArrayState), false);
  }, [numItems]);
  if (field.type !== "array" || !field.arrayFields) {
    return null;
  }
  const addDisabled = field.max !== void 0 && (mirror == null ? void 0 : mirror.items.length) >= field.max || readOnly;
  return (0, import_jsx_runtime10.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime10.jsx)(List, { size: 16 }),
      el: "div",
      readOnly,
      children: (0, import_jsx_runtime10.jsx)(
        SortableProvider,
        {
          onDragStart: (id2) => {
            valueRef.current = getValue();
            setDraggedItem(id2);
            syncCurrentIndexes();
          },
          onDragEnd: () => {
            setDraggedItem("");
            onChange(valueRef.current);
            const currentFieldVal = fieldStore.getState();
            fieldStore.setState(setDeep(currentFieldVal, name, valueRef.current));
            syncCurrentIndexes();
          },
          onMove: (move2) => {
            const arrayState = getArrayState();
            if (arrayState.items[move2.source]._arrayId !== draggedItem) {
              return;
            }
            const newValue = reorder(valueRef.current, move2.source, move2.target);
            const newArrayStateItems = reorder(
              arrayState.items,
              move2.source,
              move2.target
            );
            const state = appStore.getState().state;
            const newUi = {
              arrayState: __spreadProps(__spreadValues({}, state.ui.arrayState), {
                [id]: __spreadProps(__spreadValues({}, arrayState), { items: newArrayStateItems })
              })
            };
            setUi(newUi, false);
            valueRef.current = newValue;
          },
          children: (0, import_jsx_runtime10.jsxs)(
            "div",
            {
              className: getClassName22({
                hasItems: numItems > 0,
                addDisabled
              }),
              children: [
                mirror.items.length > 0 && (0, import_jsx_runtime10.jsx)("div", { className: getClassName22("inner"), "data-dnd-container": true, children: mirror.items.map((item, index) => {
                  const {
                    _arrayId = `${id}-${index}`,
                    _originalIndex = index,
                    _currentIndex = index
                  } = item;
                  return (0, import_jsx_runtime10.jsx)(
                    ArrayFieldItem,
                    {
                      index: _currentIndex,
                      dragIndex: index,
                      originalIndex: _originalIndex,
                      arrayId: id,
                      id: _arrayId,
                      readOnly,
                      field,
                      name,
                      localName,
                      onChange: (val, ui, subName) => {
                        const value = getValue();
                        const data = Array.from(value || [])[index] || {};
                        onChange(
                          replace(value, index, __spreadProps(__spreadValues({}, data), {
                            [subName]: val
                          })),
                          ui
                        );
                      },
                      onToggleExpand: (id2, isExpanded) => {
                        if (isExpanded) {
                          setUi(
                            mapArrayStateToUi({
                              openId: ""
                            })
                          );
                        } else {
                          setUi(
                            mapArrayStateToUi({
                              openId: id2
                            })
                          );
                        }
                      },
                      actions: (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
                        (0, import_jsx_runtime10.jsx)("div", { className: getClassNameItem("action"), children: (0, import_jsx_runtime10.jsx)(
                          IconButton,
                          {
                            type: "button",
                            disabled: !!addDisabled,
                            onClick: (e2) => {
                              e2.stopPropagation();
                              const value = getValue();
                              const existingValue = [...value || []];
                              const newItem = uniqifyItem(existingValue[index]);
                              existingValue.splice(index, 0, newItem);
                              updateValue(existingValue);
                            },
                            title: "Duplicate",
                            children: (0, import_jsx_runtime10.jsx)(Copy, { size: 16 })
                          }
                        ) }),
                        (0, import_jsx_runtime10.jsx)("div", { className: getClassNameItem("action"), children: (0, import_jsx_runtime10.jsx)(
                          IconButton,
                          {
                            type: "button",
                            disabled: field.min !== void 0 && field.min >= mirror.items.length,
                            onClick: (e2) => {
                              e2.stopPropagation();
                              const value = getValue();
                              const existingValue = [...value || []];
                              existingValue.splice(index, 1);
                              updateValue(existingValue);
                            },
                            title: "Delete",
                            children: (0, import_jsx_runtime10.jsx)(Trash, { size: 16 })
                          }
                        ) })
                      ] })
                    },
                    _arrayId
                  );
                }) }),
                !addDisabled && (0, import_jsx_runtime10.jsx)(
                  "button",
                  {
                    type: "button",
                    className: getClassName22("addButton"),
                    onClick: () => {
                      var _a5;
                      if (isDraggingAny) return;
                      const value = getValue();
                      const existingValue = value || [];
                      const defaultProps = typeof field.defaultItemProps === "function" ? field.defaultItemProps(existingValue.length) : (_a5 = field.defaultItemProps) != null ? _a5 : {};
                      const newItem = defaultSlots(
                        uniqifyItem(defaultProps),
                        field.arrayFields
                      );
                      const newValue = [...existingValue, newItem];
                      updateValue(newValue);
                    },
                    children: (0, import_jsx_runtime10.jsx)(Plus, { size: 21 })
                  }
                )
              ]
            }
          )
        }
      )
    }
  );
};
init_react_import();
init_react_import();
init_react_import();
var useDeepField = (path) => {
  return useFieldStore((s2) => getDeep(s2, path));
};
init_react_import();
var useIsFocused = (path) => {
  return useAppStore((s2) => s2.state.ui.field.focus === path);
};
var useLocalValue = (path, onChange) => {
  const value = useDeepField(path);
  const isFocused = useIsFocused(path);
  const [localValue, setLocalValue] = (0, import_react18.useState)(value == null ? void 0 : value.toString());
  const onChangeLocal = (0, import_react18.useCallback)((val) => {
    setLocalValue(val);
    onChange(val);
  }, []);
  (0, import_react18.useEffect)(() => {
    if (!isFocused) {
      setLocalValue(value);
    }
  }, [isFocused, value]);
  return [localValue != null ? localValue : "", onChangeLocal];
};
var getClassName3 = get_class_name_factory_default("Input", styles_module_default2);
var DefaultField = ({
  field,
  onChange,
  readOnly,
  id,
  name = id,
  label,
  labelIcon,
  Label: Label2
}) => {
  const [localValue, onChangeLocal] = useLocalValue(name, onChange);
  return (0, import_jsx_runtime11.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [
        field.type === "text" && (0, import_jsx_runtime11.jsx)(Type, { size: 16 }),
        field.type === "number" && (0, import_jsx_runtime11.jsx)(Hash, { size: 16 })
      ] }),
      readOnly,
      children: (0, import_jsx_runtime11.jsx)(
        "input",
        {
          className: getClassName3("input"),
          autoComplete: "off",
          type: field.type,
          title: label || name,
          name,
          value: localValue,
          onChange: (e2) => {
            if (field.type === "number") {
              const numberValue = Number(e2.currentTarget.value);
              if (typeof field.min !== "undefined" && numberValue < field.min) {
                return;
              }
              if (typeof field.max !== "undefined" && numberValue > field.max) {
                return;
              }
              onChangeLocal(numberValue);
            } else {
              onChangeLocal(e2.currentTarget.value);
            }
          },
          readOnly,
          tabIndex: readOnly ? -1 : void 0,
          id,
          min: field.type === "number" ? field.min : void 0,
          max: field.type === "number" ? field.max : void 0,
          placeholder: field.type === "text" || field.type === "number" ? field.placeholder : void 0,
          step: field.type === "number" ? field.step : void 0
        }
      )
    }
  );
};
init_react_import();
init_react_import();
init_react_import();
var styles_module_default4 = { "ExternalInput-actions": "_ExternalInput-actions_91ls0_1", "ExternalInput-button": "_ExternalInput-button_91ls0_5", "ExternalInput--dataSelected": "_ExternalInput--dataSelected_91ls0_24", "ExternalInput--readOnly": "_ExternalInput--readOnly_91ls0_31", "ExternalInput-detachButton": "_ExternalInput-detachButton_91ls0_35", "ExternalInput": "_ExternalInput_91ls0_1", "ExternalInputModal": "_ExternalInputModal_91ls0_79", "ExternalInputModal-grid": "_ExternalInputModal-grid_91ls0_89", "ExternalInputModal--filtersToggled": "_ExternalInputModal--filtersToggled_91ls0_100", "ExternalInputModal-filters": "_ExternalInputModal-filters_91ls0_105", "ExternalInputModal-masthead": "_ExternalInputModal-masthead_91ls0_124", "ExternalInputModal-tableWrapper": "_ExternalInputModal-tableWrapper_91ls0_133", "ExternalInputModal-table": "_ExternalInputModal-table_91ls0_133", "ExternalInputModal-thead": "_ExternalInputModal-thead_91ls0_149", "ExternalInputModal-th": "_ExternalInputModal-th_91ls0_149", "ExternalInputModal-td": "_ExternalInputModal-td_91ls0_164", "ExternalInputModal-tr": "_ExternalInputModal-tr_91ls0_169", "ExternalInputModal-tbody": "_ExternalInputModal-tbody_91ls0_176", "ExternalInputModal--hasData": "_ExternalInputModal--hasData_91ls0_202", "ExternalInputModal-loadingBanner": "_ExternalInputModal-loadingBanner_91ls0_206", "ExternalInputModal--isLoading": "_ExternalInputModal--isLoading_91ls0_223", "ExternalInputModal-searchForm": "_ExternalInputModal-searchForm_91ls0_227", "ExternalInputModal-search": "_ExternalInputModal-search_91ls0_227", "ExternalInputModal-searchIcon": "_ExternalInputModal-searchIcon_91ls0_264", "ExternalInputModal-searchIconText": "_ExternalInputModal-searchIconText_91ls0_289", "ExternalInputModal-searchInput": "_ExternalInputModal-searchInput_91ls0_299", "ExternalInputModal-searchActions": "_ExternalInputModal-searchActions_91ls0_313", "ExternalInputModal-searchActionIcon": "_ExternalInputModal-searchActionIcon_91ls0_326", "ExternalInputModal-footerContainer": "_ExternalInputModal-footerContainer_91ls0_330", "ExternalInputModal-footer": "_ExternalInputModal-footer_91ls0_330", "ExternalInputModal-field": "_ExternalInputModal-field_91ls0_343" };
init_react_import();
init_react_import();
var styles_module_default5 = { "Modal": "_Modal_ikbaj_1", "Modal--isOpen": "_Modal--isOpen_ikbaj_15", "Modal-inner": "_Modal-inner_ikbaj_19" };
var getClassName4 = get_class_name_factory_default("Modal", styles_module_default5);
var Modal = ({
  children,
  onClose,
  isOpen
}) => {
  const [rootEl, setRootEl] = (0, import_react21.useState)(null);
  (0, import_react21.useEffect)(() => {
    setRootEl(document.getElementById("puck-portal-root"));
  }, []);
  if (!rootEl) {
    return (0, import_jsx_runtime12.jsx)("div", {});
  }
  return (0, import_react_dom2.createPortal)(
    (0, import_jsx_runtime12.jsx)("div", { className: getClassName4({ isOpen }), onClick: onClose, children: (0, import_jsx_runtime12.jsx)(
      "div",
      {
        className: getClassName4("inner"),
        onClick: (e2) => e2.stopPropagation(),
        children
      }
    ) }),
    rootEl
  );
};
init_react_import();
init_react_import();
var styles_module_default6 = { "Heading": "_Heading_qxrry_1", "Heading--xxxxl": "_Heading--xxxxl_qxrry_12", "Heading--xxxl": "_Heading--xxxl_qxrry_18", "Heading--xxl": "_Heading--xxl_qxrry_22", "Heading--xl": "_Heading--xl_qxrry_26", "Heading--l": "_Heading--l_qxrry_30", "Heading--m": "_Heading--m_qxrry_34", "Heading--s": "_Heading--s_qxrry_38", "Heading--xs": "_Heading--xs_qxrry_42" };
var getClassName5 = get_class_name_factory_default("Heading", styles_module_default6);
var Heading = ({ children, rank, size = "m" }) => {
  const Tag = rank ? `h${rank}` : "span";
  return (0, import_jsx_runtime13.jsx)(
    Tag,
    {
      className: getClassName5({
        [size]: true
      }),
      children
    }
  );
};
init_react_import();
init_react_import();
init_react_import();
var Button_module_default = { "Button": "_Button_10byl_1", "Button--medium": "_Button--medium_10byl_29", "Button--large": "_Button--large_10byl_37", "Button-icon": "_Button-icon_10byl_44", "Button--primary": "_Button--primary_10byl_48", "Button--secondary": "_Button--secondary_10byl_67", "Button--flush": "_Button--flush_10byl_84", "Button--disabled": "_Button--disabled_10byl_88", "Button--fullWidth": "_Button--fullWidth_10byl_95", "Button-spinner": "_Button-spinner_10byl_100" };
init_react_import();
var dataAttrRe = /^(data-.*)$/;
var filterDataAttrs = (props) => {
  let filteredProps = {};
  for (const prop in props) {
    if (Object.prototype.hasOwnProperty.call(props, prop) && dataAttrRe.test(prop)) {
      filteredProps[prop] = props[prop];
    }
  }
  return filteredProps;
};
var getClassName6 = get_class_name_factory_default("Button", Button_module_default);
var Button = (_a5) => {
  var _b3 = _a5, {
    children,
    href,
    onClick,
    variant = "primary",
    type,
    disabled,
    tabIndex,
    newTab,
    fullWidth,
    icon,
    size = "medium",
    loading: loadingProp = false
  } = _b3, props = __objRest(_b3, [
    "children",
    "href",
    "onClick",
    "variant",
    "type",
    "disabled",
    "tabIndex",
    "newTab",
    "fullWidth",
    "icon",
    "size",
    "loading"
  ]);
  const [loading, setLoading] = (0, import_react22.useState)(loadingProp);
  (0, import_react22.useEffect)(() => setLoading(loadingProp), [loadingProp]);
  const ElementType = href ? "a" : type ? "button" : "span";
  const dataAttrs = filterDataAttrs(props);
  const el = (0, import_jsx_runtime14.jsxs)(
    ElementType,
    __spreadProps(__spreadValues({
      className: getClassName6({
        primary: variant === "primary",
        secondary: variant === "secondary",
        disabled,
        fullWidth,
        [size]: true
      }),
      onClick: (e2) => {
        if (!onClick) return;
        setLoading(true);
        Promise.resolve(onClick(e2)).then(() => {
          setLoading(false);
        });
      },
      type,
      disabled: disabled || loading,
      tabIndex,
      target: newTab ? "_blank" : void 0,
      rel: newTab ? "noreferrer" : void 0,
      href
    }, dataAttrs), {
      children: [
        icon && (0, import_jsx_runtime14.jsx)("div", { className: getClassName6("icon"), children: icon }),
        children,
        loading && (0, import_jsx_runtime14.jsx)("div", { className: getClassName6("spinner"), children: (0, import_jsx_runtime14.jsx)(Loader, { size: 14 }) })
      ]
    })
  );
  return el;
};
var getClassName7 = get_class_name_factory_default("ExternalInput", styles_module_default4);
var getClassNameModal = get_class_name_factory_default("ExternalInputModal", styles_module_default4);
var dataCache = {};
var ExternalInput = ({
  field,
  onChange,
  value = null,
  name,
  id,
  readOnly
}) => {
  var _a5;
  const {
    mapProp = (val) => val,
    mapRow = (val) => val,
    filterFields
  } = field || {};
  const { enabled: shouldCacheData } = (_a5 = field.cache) != null ? _a5 : { enabled: true };
  const [data, setData] = (0, import_react20.useState)([]);
  const [isOpen, setOpen] = (0, import_react20.useState)(false);
  const [isLoading, setIsLoading] = (0, import_react20.useState)(true);
  const hasFilterFields = !!filterFields;
  const [filters, setFilters] = (0, import_react20.useState)(field.initialFilters || {});
  const [filtersToggled, setFiltersToggled] = (0, import_react20.useState)(hasFilterFields);
  const mappedData = (0, import_react20.useMemo)(() => {
    return data.map(mapRow);
  }, [data]);
  const keys = (0, import_react20.useMemo)(() => {
    const validKeys = /* @__PURE__ */ new Set();
    for (const item of mappedData) {
      for (const key of Object.keys(item)) {
        if (typeof item[key] === "string" || typeof item[key] === "number" || (0, import_react20.isValidElement)(item[key])) {
          validKeys.add(key);
        }
      }
    }
    return Array.from(validKeys);
  }, [mappedData]);
  const [searchQuery, setSearchQuery] = (0, import_react20.useState)(field.initialQuery || "");
  const search = (0, import_react20.useCallback)(
    (query, filters2) => __async(null, null, function* () {
      setIsLoading(true);
      const cacheKey = `${id}-${query}-${JSON.stringify(filters2)}`;
      let listData;
      if (shouldCacheData && dataCache[cacheKey]) {
        listData = dataCache[cacheKey];
      } else {
        listData = yield field.fetchList({ query, filters: filters2 });
      }
      if (listData) {
        setData(listData);
        setIsLoading(false);
        if (shouldCacheData) {
          dataCache[cacheKey] = listData;
        }
      }
    }),
    [id, field]
  );
  const Footer = (0, import_react20.useCallback)(
    (props) => field.renderFooter ? field.renderFooter(props) : (0, import_jsx_runtime15.jsxs)("span", { className: getClassNameModal("footer"), children: [
      props.items.length,
      " result",
      props.items.length === 1 ? "" : "s"
    ] }),
    [field.renderFooter]
  );
  (0, import_react20.useEffect)(() => {
    search(searchQuery, filters);
  }, []);
  return (0, import_jsx_runtime15.jsxs)(
    "div",
    {
      className: getClassName7({
        dataSelected: !!value,
        modalVisible: isOpen,
        readOnly
      }),
      id,
      children: [
        (0, import_jsx_runtime15.jsxs)("div", { className: getClassName7("actions"), children: [
          (0, import_jsx_runtime15.jsx)(
            "button",
            {
              type: "button",
              onClick: () => setOpen(true),
              className: getClassName7("button"),
              disabled: readOnly,
              children: value ? field.getItemSummary ? field.getItemSummary(value) : "External item" : (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, { children: [
                (0, import_jsx_runtime15.jsx)(Link, { size: "16" }),
                (0, import_jsx_runtime15.jsx)("span", { children: field.placeholder })
              ] })
            }
          ),
          value && (0, import_jsx_runtime15.jsx)(
            "button",
            {
              type: "button",
              className: getClassName7("detachButton"),
              onClick: () => {
                onChange(null);
              },
              disabled: readOnly,
              children: (0, import_jsx_runtime15.jsx)(LockOpen, { size: 16 })
            }
          )
        ] }),
        (0, import_jsx_runtime15.jsx)(Modal, { onClose: () => setOpen(false), isOpen, children: (0, import_jsx_runtime15.jsxs)(
          "form",
          {
            className: getClassNameModal({
              isLoading,
              loaded: !isLoading,
              hasData: mappedData.length > 0,
              filtersToggled
            }),
            onSubmit: (e2) => {
              e2.preventDefault();
              e2.stopPropagation();
              search(searchQuery, filters);
            },
            children: [
              (0, import_jsx_runtime15.jsx)("div", { className: getClassNameModal("masthead"), children: field.showSearch ? (0, import_jsx_runtime15.jsxs)("div", { className: getClassNameModal("searchForm"), children: [
                (0, import_jsx_runtime15.jsxs)("label", { className: getClassNameModal("search"), children: [
                  (0, import_jsx_runtime15.jsx)("span", { className: getClassNameModal("searchIconText"), children: "Search" }),
                  (0, import_jsx_runtime15.jsx)("div", { className: getClassNameModal("searchIcon"), children: (0, import_jsx_runtime15.jsx)(Search, { size: "18" }) }),
                  (0, import_jsx_runtime15.jsx)(
                    "input",
                    {
                      className: getClassNameModal("searchInput"),
                      name: "q",
                      type: "search",
                      placeholder: field.placeholder,
                      onChange: (e2) => {
                        setSearchQuery(e2.currentTarget.value);
                      },
                      autoComplete: "off",
                      value: searchQuery
                    }
                  )
                ] }),
                (0, import_jsx_runtime15.jsxs)("div", { className: getClassNameModal("searchActions"), children: [
                  (0, import_jsx_runtime15.jsx)(Button, { type: "submit", loading: isLoading, fullWidth: true, children: "Search" }),
                  hasFilterFields && (0, import_jsx_runtime15.jsx)("div", { className: getClassNameModal("searchActionIcon"), children: (0, import_jsx_runtime15.jsx)(
                    IconButton,
                    {
                      type: "button",
                      title: "Toggle filters",
                      onClick: (e2) => {
                        e2.preventDefault();
                        e2.stopPropagation();
                        setFiltersToggled(!filtersToggled);
                      },
                      children: (0, import_jsx_runtime15.jsx)(SlidersHorizontal, { size: 20 })
                    }
                  ) })
                ] })
              ] }) : (0, import_jsx_runtime15.jsx)(Heading, { rank: "2", size: "xs", children: field.placeholder || "Select data" }) }),
              (0, import_jsx_runtime15.jsxs)("div", { className: getClassNameModal("grid"), children: [
                hasFilterFields && (0, import_jsx_runtime15.jsx)("div", { className: getClassNameModal("filters"), children: hasFilterFields && Object.keys(filterFields).map((fieldName) => {
                  const filterField = filterFields[fieldName];
                  return (0, import_jsx_runtime15.jsx)(
                    "div",
                    {
                      className: getClassNameModal("field"),
                      children: (0, import_jsx_runtime15.jsx)(FieldLabel, { label: filterField.label || fieldName, children: (0, import_jsx_runtime15.jsx)(
                        AutoField,
                        {
                          field: filterField,
                          id: `external_field_${fieldName}_filter`,
                          value: filters[fieldName],
                          onChange: (value2) => {
                            setFilters((filters2) => {
                              const newFilters = __spreadProps(__spreadValues({}, filters2), {
                                [fieldName]: value2
                              });
                              search(searchQuery, newFilters);
                              return newFilters;
                            });
                          }
                        }
                      ) })
                    },
                    fieldName
                  );
                }) }),
                (0, import_jsx_runtime15.jsxs)("div", { className: getClassNameModal("tableWrapper"), children: [
                  (0, import_jsx_runtime15.jsxs)("table", { className: getClassNameModal("table"), children: [
                    (0, import_jsx_runtime15.jsx)("thead", { className: getClassNameModal("thead"), children: (0, import_jsx_runtime15.jsx)("tr", { className: getClassNameModal("tr"), children: keys.map((key) => (0, import_jsx_runtime15.jsx)(
                      "th",
                      {
                        className: getClassNameModal("th"),
                        style: { textAlign: "left" },
                        children: key
                      },
                      key
                    )) }) }),
                    (0, import_jsx_runtime15.jsx)("tbody", { className: getClassNameModal("tbody"), children: mappedData.map((item, i2) => {
                      return (0, import_jsx_runtime15.jsx)(
                        "tr",
                        {
                          style: { whiteSpace: "nowrap" },
                          className: getClassNameModal("tr"),
                          onClick: () => {
                            onChange(mapProp(data[i2]));
                            setOpen(false);
                          },
                          children: keys.map((key) => (0, import_jsx_runtime15.jsx)("td", { className: getClassNameModal("td"), children: item[key] }, key))
                        },
                        i2
                      );
                    }) })
                  ] }),
                  (0, import_jsx_runtime15.jsx)("div", { className: getClassNameModal("loadingBanner"), children: (0, import_jsx_runtime15.jsx)(Loader, { size: 24 }) })
                ] })
              ] }),
              (0, import_jsx_runtime15.jsx)("div", { className: getClassNameModal("footerContainer"), children: (0, import_jsx_runtime15.jsx)(Footer, { items: mappedData }) })
            ]
          }
        ) })
      ]
    }
  );
};
var ExternalField = ({
  field,
  onChange,
  id,
  name = id,
  label,
  labelIcon,
  Label: Label2,
  readOnly
}) => {
  var _a5, _b3, _c4;
  const value = useDeepField(name);
  const validField = field;
  const deprecatedField = field;
  (0, import_react19.useEffect)(() => {
    if (deprecatedField.adaptor) {
      console.error(
        "Warning: The `adaptor` API is deprecated. Please use updated APIs on the `external` field instead. This will be a breaking change in a future release."
      );
    }
  }, []);
  if (field.type !== "external") {
    return null;
  }
  return (0, import_jsx_runtime16.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime16.jsx)(Link, { size: 16 }),
      el: "div",
      children: (0, import_jsx_runtime16.jsx)(
        ExternalInput,
        {
          name,
          field: __spreadProps(__spreadValues({}, validField), {
            // DEPRECATED
            placeholder: ((_a5 = deprecatedField.adaptor) == null ? void 0 : _a5.name) ? `Select from ${deprecatedField.adaptor.name}` : validField.placeholder || "Select data",
            mapProp: ((_b3 = deprecatedField.adaptor) == null ? void 0 : _b3.mapProp) || validField.mapProp,
            mapRow: validField.mapRow,
            fetchList: ((_c4 = deprecatedField.adaptor) == null ? void 0 : _c4.fetchList) ? () => __async(null, null, function* () {
              return yield deprecatedField.adaptor.fetchList(
                deprecatedField.adaptorParams
              );
            }) : validField.fetchList
          }),
          onChange,
          value,
          id,
          readOnly
        }
      )
    }
  );
};
init_react_import();
var getClassName8 = get_class_name_factory_default("Input", styles_module_default2);
var RadioField = ({
  field,
  onChange,
  readOnly,
  id,
  name = id,
  label,
  labelIcon,
  Label: Label2
}) => {
  const value = useDeepField(name);
  if (field.type !== "radio" || !field.options) {
    return null;
  }
  return (0, import_jsx_runtime17.jsx)(
    Label2,
    {
      icon: labelIcon || (0, import_jsx_runtime17.jsx)(CircleCheckBig, { size: 16 }),
      label: label || name,
      readOnly,
      el: "div",
      children: (0, import_jsx_runtime17.jsx)("div", { className: getClassName8("radioGroupItems"), id, children: field.options.map((option) => {
        var _a5;
        return (0, import_jsx_runtime17.jsxs)(
          "label",
          {
            className: getClassName8("radio"),
            children: [
              (0, import_jsx_runtime17.jsx)(
                "input",
                {
                  type: "radio",
                  className: getClassName8("radioInput"),
                  value: JSON.stringify({ value: option.value }),
                  name,
                  onChange: (e2) => {
                    onChange(JSON.parse(e2.target.value).value);
                  },
                  disabled: readOnly,
                  checked: value === option.value
                }
              ),
              (0, import_jsx_runtime17.jsx)("div", { className: getClassName8("radioInner"), children: option.label || ((_a5 = option.value) == null ? void 0 : _a5.toString()) })
            ]
          },
          option.label + option.value
        );
      }) })
    }
  );
};
init_react_import();
var getClassName9 = get_class_name_factory_default("Input", styles_module_default2);
var SelectField = ({
  field,
  onChange,
  label,
  labelIcon,
  Label: Label2,
  id,
  name = id,
  readOnly
}) => {
  const value = useDeepField(name);
  if (field.type !== "select" || !field.options) {
    return null;
  }
  return (0, import_jsx_runtime18.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime18.jsx)(ChevronDown, { size: 16 }),
      readOnly,
      children: (0, import_jsx_runtime18.jsx)(
        "select",
        {
          id,
          title: label || name,
          className: getClassName9("input"),
          disabled: readOnly,
          onChange: (e2) => {
            onChange(JSON.parse(e2.target.value).value);
          },
          value: JSON.stringify({ value }),
          children: field.options.map((option) => (0, import_jsx_runtime18.jsx)(
            "option",
            {
              label: option.label,
              value: JSON.stringify({ value: option.value })
            },
            option.label + JSON.stringify(option.value)
          ))
        }
      )
    }
  );
};
init_react_import();
var getClassName10 = get_class_name_factory_default("Input", styles_module_default2);
var TextareaField = ({
  field,
  onChange,
  readOnly,
  id,
  name = id,
  label,
  labelIcon,
  Label: Label2
}) => {
  const [localValue, onChangeLocal] = useLocalValue(name, onChange);
  return (0, import_jsx_runtime19.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime19.jsx)(Type, { size: 16 }),
      readOnly,
      children: (0, import_jsx_runtime19.jsx)(
        "textarea",
        {
          id,
          className: getClassName10("input"),
          autoComplete: "off",
          name,
          value: typeof localValue === "undefined" ? "" : localValue,
          onChange: (e2) => onChangeLocal(e2.currentTarget.value),
          readOnly,
          tabIndex: readOnly ? -1 : void 0,
          rows: 5,
          placeholder: field.type === "textarea" ? field.placeholder : void 0
        }
      )
    }
  );
};
init_react_import();
init_react_import();
var EditorFallback = (0, import_react24.memo)((props) => {
  var _a5;
  return (0, import_jsx_runtime20.jsx)(
    EditorInner,
    __spreadProps(__spreadValues({}, props), {
      editor: null,
      menu: (0, import_jsx_runtime20.jsx)(
        LoadedRichTextMenuInner,
        {
          field: props.field,
          editor: null,
          editorState: null,
          readOnly: (_a5 = props.readOnly) != null ? _a5 : false
        }
      ),
      children: (0, import_jsx_runtime20.jsx)(
        "div",
        {
          className: "rich-text",
          dangerouslySetInnerHTML: { __html: props.content },
          contentEditable: true
        }
      )
    })
  );
});
EditorFallback.displayName = "EditorFallback";
var Editor = (0, import_react23.lazy)(
  () => import("./Editor-NK3TZSR6-AZMGDXZX.js").then((m2) => ({
    default: m2.Editor
  }))
);
var RichtextField = ({
  onChange,
  readOnly = false,
  id,
  name = id,
  label,
  labelIcon,
  Label: Label2,
  field
}) => {
  const content = useDeepField(name);
  const editorProps = {
    onChange,
    content,
    readOnly,
    field,
    id,
    name
  };
  return (0, import_jsx_runtime21.jsx)(import_jsx_runtime21.Fragment, { children: (0, import_jsx_runtime21.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime21.jsx)(Type, { size: 16 }),
      readOnly,
      el: "div",
      children: (0, import_jsx_runtime21.jsx)(import_react23.Suspense, { fallback: (0, import_jsx_runtime21.jsx)(EditorFallback, __spreadValues({}, editorProps)), children: (0, import_jsx_runtime21.jsx)(Editor, __spreadValues({}, editorProps)) })
    }
  ) });
};
init_react_import();
init_react_import();
var styles_module_default7 = { "ObjectField": "_ObjectField_1ua3y_5", "ObjectField-fieldset": "_ObjectField-fieldset_1ua3y_13" };
var getClassName11 = get_class_name_factory_default("ObjectField", styles_module_default7);
var ObjectField = ({
  field,
  onChange,
  id,
  name = id,
  label,
  labelIcon,
  Label: Label2,
  readOnly
}) => {
  const { localName = name } = useNestedFieldContext();
  const fieldStore = useFieldStoreApi();
  const canEdit = useAppStore(
    (s2) => s2.permissions.getPermissions({ item: s2.selectedItem }).edit
  );
  const getValue = () => {
    var _a5;
    return (_a5 = getDeep(fieldStore.getState(), name)) != null ? _a5 : {};
  };
  if (field.type !== "object" || !field.objectFields) {
    return null;
  }
  return (0, import_jsx_runtime22.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime22.jsx)(EllipsisVertical, { size: 16 }),
      el: "div",
      readOnly,
      children: (0, import_jsx_runtime22.jsx)("div", { className: getClassName11(), children: (0, import_jsx_runtime22.jsx)("fieldset", { className: getClassName11("fieldset"), children: Object.keys(field.objectFields).map((subName) => {
        const subField = field.objectFields[subName];
        const subPath = `${localName}.${subName}`;
        return (0, import_jsx_runtime22.jsx)(
          SubField,
          {
            id: `${id}_${subName}`,
            name,
            subName,
            localName,
            field: subField,
            forceReadOnly: !canEdit,
            onChange: (subValue, ui, subName2) => {
              const value = getValue();
              if (value[subName2] === subValue) {
                return;
              }
              onChange(__spreadProps(__spreadValues({}, value), { [subName2]: subValue }), ui);
            }
          },
          subPath
        );
      }) }) })
    }
  );
};
init_react_import();
var useSafeId = () => {
  if (typeof import_react25.default.useId !== "undefined") {
    return import_react25.default.useId();
  }
  const [id] = (0, import_react25.useState)(generateId());
  return id;
};
init_react_import();
var getClassName12 = get_class_name_factory_default("Input", styles_module_default2);
var FieldLabel = ({
  children,
  icon,
  label,
  el = "label",
  readOnly,
  className
}) => {
  const El = el;
  return (0, import_jsx_runtime23.jsxs)(El, { className, children: [
    (0, import_jsx_runtime23.jsxs)("div", { className: getClassName12("label"), children: [
      icon ? (0, import_jsx_runtime23.jsx)("div", { className: getClassName12("labelIcon"), children: icon }) : (0, import_jsx_runtime23.jsx)(import_jsx_runtime23.Fragment, {}),
      label,
      readOnly && (0, import_jsx_runtime23.jsx)("div", { className: getClassName12("disabledIcon"), title: "Read-only", children: (0, import_jsx_runtime23.jsx)(Lock, { size: "12" }) })
    ] }),
    children
  ] });
};
var FieldLabelInternal = ({
  children,
  icon,
  label,
  el = "label",
  readOnly
}) => {
  const overrides = useAppStore((s2) => s2.overrides);
  const Wrapper = (0, import_react26.useMemo)(
    () => overrides.fieldLabel || FieldLabel,
    [overrides]
  );
  if (!label) {
    return (0, import_jsx_runtime23.jsx)(import_jsx_runtime23.Fragment, { children });
  }
  return (0, import_jsx_runtime23.jsx)(
    Wrapper,
    {
      label,
      icon,
      className: getClassName12({ readOnly }),
      readOnly,
      el,
      children
    }
  );
};
var getClassName13 = get_class_name_factory_default("Input", styles_module_default2);
var getClassNameWrapper = get_class_name_factory_default("InputWrapper", styles_module_default2);
var defaultFields = {
  array: ArrayField,
  external: ExternalField,
  object: ObjectField,
  select: SelectField,
  textarea: TextareaField,
  radio: RadioField,
  text: DefaultField,
  number: DefaultField,
  richtext: RichtextField
};
function AutoFieldInternal(props) {
  var _a5;
  const dispatch = useAppStore((s2) => s2.dispatch);
  const overrides = useAppStore((s2) => s2.overrides);
  const readOnly = useAppStore(useShallow((s2) => {
    var _a23;
    return (_a23 = s2.selectedItem) == null ? void 0 : _a23.readOnly;
  }));
  const nestedFieldContext = (0, import_react9.useContext)(NestedFieldContext);
  const { id, Label: Label2 = FieldLabelInternal } = props;
  const field = props.field;
  const label = field.label;
  const labelIcon = field.labelIcon;
  const defaultId = useSafeId();
  const resolvedId = id || defaultId;
  const render = (0, import_react9.useMemo)(
    () => {
      var _a23, _b3, _c4, _d2, _e, _f, _g, _h, _i, _j;
      return __spreadProps(__spreadValues({}, overrides.fieldTypes), {
        custom: (_a23 = overrides.fieldTypes) == null ? void 0 : _a23.custom,
        array: ((_b3 = overrides.fieldTypes) == null ? void 0 : _b3.array) || defaultFields.array,
        external: ((_c4 = overrides.fieldTypes) == null ? void 0 : _c4.external) || defaultFields.external,
        object: ((_d2 = overrides.fieldTypes) == null ? void 0 : _d2.object) || defaultFields.object,
        select: ((_e = overrides.fieldTypes) == null ? void 0 : _e.select) || defaultFields.select,
        textarea: ((_f = overrides.fieldTypes) == null ? void 0 : _f.textarea) || defaultFields.textarea,
        radio: ((_g = overrides.fieldTypes) == null ? void 0 : _g.radio) || defaultFields.radio,
        text: ((_h = overrides.fieldTypes) == null ? void 0 : _h.text) || defaultFields.text,
        number: ((_i = overrides.fieldTypes) == null ? void 0 : _i.number) || defaultFields.number,
        richtext: ((_j = overrides.fieldTypes) == null ? void 0 : _j.richtext) || defaultFields.richtext
      });
    },
    [overrides]
  );
  const fieldValue = useFieldStore((s2) => {
    var _a23, _b3;
    if (field.type === "custom" || ((_a23 = overrides.fieldTypes) == null ? void 0 : _a23[field.type])) {
      return getDeep(s2, (_b3 = props.name) != null ? _b3 : resolvedId);
    }
  });
  const mergedProps = (0, import_react9.useMemo)(
    () => __spreadProps(__spreadValues({}, props), {
      field,
      label,
      labelIcon,
      Label: Label2,
      id: resolvedId,
      value: fieldValue
    }),
    [props, field, label, labelIcon, Label2, resolvedId, fieldValue]
  );
  const onFocus = (0, import_react9.useCallback)(
    (e2) => {
      if (mergedProps.name && (e2.target.nodeName === "INPUT" || e2.target.nodeName === "TEXTAREA")) {
        e2.stopPropagation();
        dispatch({
          type: "setUi",
          ui: {
            field: { focus: mergedProps.name }
          }
        });
      }
    },
    [mergedProps.name]
  );
  const onBlur = (0, import_react9.useCallback)((e2) => {
    if ("name" in e2.target) {
      dispatch({
        type: "setUi",
        ui: {
          field: { focus: null }
        }
      });
    }
  }, []);
  let Children = (0, import_react9.useMemo)(() => {
    if (field.type !== "custom" && field.type !== "slot") {
      return defaultFields[field.type];
    }
    return (_props) => null;
  }, [field.type]);
  const fieldKey = field.type === "custom" ? field.key : void 0;
  let FieldComponent = (0, import_react9.useMemo)(() => {
    if (field.type === "custom" && !render[field.type]) {
      if (!field.render) {
        return null;
      }
      return field.render;
    } else if (field.type !== "slot") {
      return render[field.type];
    }
  }, [field.type, fieldKey, render]);
  const { visible = true } = props.field;
  if (!visible) {
    return null;
  }
  if (field.type === "slot") {
    return null;
  }
  if (!FieldComponent) {
    throw new Error(`Field type for ${field.type} did not exist.`);
  }
  return (0, import_jsx_runtime24.jsx)(
    NestedFieldContext.Provider,
    {
      value: {
        readOnlyFields: nestedFieldContext.readOnlyFields || readOnly || {},
        localName: (_a5 = nestedFieldContext.localName) != null ? _a5 : mergedProps.name
      },
      children: (0, import_jsx_runtime24.jsx)(
        "div",
        {
          className: getClassNameWrapper(),
          onFocus,
          onBlur,
          onClick: (e2) => {
            e2.stopPropagation();
          },
          children: (0, import_jsx_runtime24.jsx)(FieldComponent, __spreadProps(__spreadValues({}, mergedProps), { children: (0, import_jsx_runtime24.jsx)(Children, __spreadValues({}, mergedProps)) }))
        }
      )
    }
  );
}
function AutoFieldPrivate(props) {
  return (0, import_jsx_runtime24.jsx)(AutoFieldInternal, __spreadValues({}, props));
}
function AutoFieldPublicInternal(_a5) {
  var _b3 = _a5, { value } = _b3, props = __objRest(_b3, ["value"]);
  const DefaultLabel = (0, import_react9.useMemo)(() => {
    const DefaultLabel2 = (labelProps) => (0, import_jsx_runtime24.jsx)(
      "div",
      __spreadProps(__spreadValues({}, labelProps), {
        className: getClassName13({ readOnly: props.readOnly })
      })
    );
    return DefaultLabel2;
  }, [props.readOnly]);
  const fieldStore = useFieldStoreApi();
  const onChange = (0, import_react9.useCallback)(
    (value2) => {
      if (!props.id) return;
      fieldStore.setState({ [props.id]: value2 });
      props.onChange(value2);
    },
    [fieldStore, props.onChange, props.id]
  );
  (0, import_react9.useEffect)(() => {
    if (!props.id) return;
    fieldStore.setState({ [props.id]: value });
  }, [props.id, value, fieldStore]);
  return (0, import_jsx_runtime24.jsx)(
    AutoFieldInternal,
    __spreadProps(__spreadValues({}, props), {
      onChange,
      Label: DefaultLabel
    })
  );
}
function AutoField(props) {
  const id = useSafeId();
  if (props.field.type === "slot") {
    return null;
  }
  return (0, import_jsx_runtime24.jsx)(fieldContextStore.Provider, { value: { [id]: props.value }, children: (0, import_jsx_runtime24.jsx)(AutoFieldPublicInternal, __spreadProps(__spreadValues({}, props), { id })) });
}
init_react_import();
init_react_import();
var styles_module_default8 = { "Drawer": "_Drawer_pl7z0_1", "Drawer-draggable": "_Drawer-draggable_pl7z0_8", "Drawer-draggableBg": "_Drawer-draggableBg_pl7z0_12", "DrawerItem-draggable": "_DrawerItem-draggable_pl7z0_22", "DrawerItem--disabled": "_DrawerItem--disabled_pl7z0_35", "DrawerItem": "_DrawerItem_pl7z0_22", "Drawer--isDraggingFrom": "_Drawer--isDraggingFrom_pl7z0_45", "DrawerItem-name": "_DrawerItem-name_pl7z0_63" };
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var styles_module_default9 = { "DraggableComponent": "_DraggableComponent_1vaqy_1", "DraggableComponent-overlayWrapper": "_DraggableComponent-overlayWrapper_1vaqy_12", "DraggableComponent-overlay": "_DraggableComponent-overlay_1vaqy_12", "DraggableComponent-loadingOverlay": "_DraggableComponent-loadingOverlay_1vaqy_34", "DraggableComponent--hover": "_DraggableComponent--hover_1vaqy_50", "DraggableComponent--isSelected": "_DraggableComponent--isSelected_1vaqy_57", "DraggableComponent-actionsOverlay": "_DraggableComponent-actionsOverlay_1vaqy_71", "DraggableComponent-actions": "_DraggableComponent-actions_1vaqy_71" };
init_react_import();
function getDeepScrollPosition(element) {
  let totalScroll = {
    x: 0,
    y: 0
  };
  let current = element;
  while (current && current !== document.documentElement) {
    const parent = current.parentElement;
    if (parent) {
      totalScroll.x += parent.scrollLeft;
      totalScroll.y += parent.scrollTop;
    }
    current = parent;
  }
  return totalScroll;
}
init_react_import();
var dropZoneContext = (0, import_react32.createContext)(null);
var ZoneStoreContext = (0, import_react32.createContext)(
  createStore(() => ({
    zoneDepthIndex: {},
    nextZoneDepthIndex: {},
    areaDepthIndex: {},
    nextAreaDepthIndex: {},
    draggedItem: null,
    previewIndex: {},
    enabledIndex: {},
    hoveringComponent: null
  }))
);
var ZoneStoreProvider = ({
  children,
  store: store2
}) => {
  return (0, import_jsx_runtime25.jsx)(ZoneStoreContext.Provider, { value: store2, children });
};
var DropZoneProvider = ({
  children,
  value
}) => {
  const dispatch = useAppStore((s2) => s2.dispatch);
  const registerZone = (0, import_react32.useCallback)(
    (zoneCompound) => {
      dispatch({
        type: "registerZone",
        zone: zoneCompound
      });
    },
    [dispatch]
  );
  const memoValue = (0, import_react32.useMemo)(
    () => __spreadValues({
      registerZone
    }, value),
    [value]
  );
  return (0, import_jsx_runtime25.jsx)(import_jsx_runtime25.Fragment, { children: memoValue && (0, import_jsx_runtime25.jsx)(dropZoneContext.Provider, { value: memoValue, children }) });
};
init_react_import();
function accumulateTransform(el) {
  let matrix = new DOMMatrixReadOnly();
  let n2 = el.parentElement;
  while (n2 && n2 !== document.documentElement) {
    const t2 = getComputedStyle(n2).transform;
    if (t2 && t2 !== "none") {
      matrix = new DOMMatrixReadOnly(t2).multiply(matrix);
    }
    n2 = n2.parentElement;
  }
  return { scaleX: matrix.a, scaleY: matrix.d };
}
init_react_import();
var useOnDragFinished = (cb, deps = []) => {
  const appStore = useAppStoreApi();
  return (0, import_react33.useCallback)(() => {
    let dispose = () => {
    };
    const processDragging = (isDragging2) => {
      if (isDragging2) {
        cb(false);
      } else {
        setTimeout(() => {
          cb(true);
        }, 0);
        if (dispose) dispose();
      }
    };
    const isDragging = appStore.getState().state.ui.isDragging;
    processDragging(isDragging);
    if (isDragging) {
      dispose = appStore.subscribe(
        (s2) => s2.state.ui.isDragging,
        (isDragging2) => {
          processDragging(isDragging2);
        }
      );
    }
    return dispose;
  }, [appStore, ...deps]);
};
var getClassName14 = get_class_name_factory_default("DraggableComponent", styles_module_default9);
var DEBUG2 = false;
var space = 8;
var actionsOverlayTop = space * 6.5;
var actionsTop = -(actionsOverlayTop - 8);
var actionsSide = space;
var DefaultActionBar = ({
  label,
  children,
  parentAction
}) => (0, import_jsx_runtime26.jsxs)(ActionBar, { children: [
  (0, import_jsx_runtime26.jsxs)(ActionBar.Group, { children: [
    parentAction,
    label && (0, import_jsx_runtime26.jsx)(ActionBar.Label, { label })
  ] }),
  (0, import_jsx_runtime26.jsx)(ActionBar.Group, { children })
] });
var DefaultOverlay = ({
  children
}) => (0, import_jsx_runtime26.jsx)(import_jsx_runtime26.Fragment, { children });
var DraggableComponent = ({
  children,
  depth,
  componentType,
  id,
  index,
  zoneCompound,
  isLoading = false,
  isSelected = false,
  debug,
  label,
  autoDragAxis,
  userDragAxis,
  inDroppableZone = true
}) => {
  const zoom = useAppStore(
    (s2) => {
      var _a5;
      return ((_a5 = s2.selectedItem) == null ? void 0 : _a5.props.id) === id ? s2.zoomConfig.zoom : 1;
    }
  );
  const overrides = useAppStore((s2) => s2.overrides);
  const dispatch = useAppStore((s2) => s2.dispatch);
  const iframe = useAppStore((s2) => s2.iframe);
  const ctx = (0, import_react31.useContext)(dropZoneContext);
  const [localZones, setLocalZones] = (0, import_react31.useState)({});
  const registerLocalZone = (0, import_react31.useCallback)(
    (zoneCompound2, active) => {
      var _a5;
      (_a5 = ctx == null ? void 0 : ctx.registerLocalZone) == null ? void 0 : _a5.call(ctx, zoneCompound2, active);
      setLocalZones((obj) => __spreadProps(__spreadValues({}, obj), {
        [zoneCompound2]: active
      }));
    },
    [setLocalZones]
  );
  const unregisterLocalZone = (0, import_react31.useCallback)(
    (zoneCompound2) => {
      var _a5;
      (_a5 = ctx == null ? void 0 : ctx.unregisterLocalZone) == null ? void 0 : _a5.call(ctx, zoneCompound2);
      setLocalZones((obj) => {
        const newLocalZones = __spreadValues({}, obj);
        delete newLocalZones[zoneCompound2];
        return newLocalZones;
      });
    },
    [setLocalZones]
  );
  const containsActiveZone = Object.values(localZones).filter(Boolean).length > 0;
  const path = useAppStore(useShallow((s2) => {
    var _a5;
    return (_a5 = s2.state.indexes.nodes[id]) == null ? void 0 : _a5.path;
  }));
  const permissions = useAppStore(
    useShallow((s2) => {
      const item = getItem({ index, zone: zoneCompound }, s2.state);
      return s2.permissions.getPermissions({ item });
    })
  );
  const zoneStore = (0, import_react31.useContext)(ZoneStoreContext);
  const [dragAxis, setDragAxis] = (0, import_react31.useState)(userDragAxis || autoDragAxis);
  const dynamicCollisionDetector = (0, import_react31.useMemo)(
    () => createDynamicCollisionDetector(dragAxis),
    [dragAxis]
  );
  const {
    ref: sortableRef,
    isDragging: thisIsDragging,
    sortable
  } = useSortable({
    id,
    index,
    group: zoneCompound,
    type: "component",
    data: {
      areaId: ctx == null ? void 0 : ctx.areaId,
      zone: zoneCompound,
      index,
      componentType,
      containsActiveZone,
      depth,
      path: path || [],
      inDroppableZone
    },
    collisionPriority: depth,
    collisionDetector: dynamicCollisionDetector,
    // "Out of the way" transition from react-beautiful-dnd
    transition: {
      duration: 200,
      easing: "cubic-bezier(0.2, 0, 0, 1)"
    },
    feedback: "clone"
  });
  (0, import_react31.useEffect)(() => {
    const isEnabled = zoneStore.getState().enabledIndex[zoneCompound];
    sortable.droppable.disabled = !isEnabled;
    sortable.draggable.disabled = !permissions.drag;
    const cleanup = zoneStore.subscribe((s2) => {
      sortable.droppable.disabled = !s2.enabledIndex[zoneCompound];
    });
    if (ref.current && !permissions.drag) {
      ref.current.setAttribute("data-puck-disabled", "");
      return () => {
        var _a5;
        (_a5 = ref.current) == null ? void 0 : _a5.removeAttribute("data-puck-disabled");
        cleanup();
      };
    }
    return cleanup;
  }, [permissions.drag, zoneCompound]);
  const [, setRerender] = (0, import_react31.useState)(0);
  const ref = (0, import_react31.useRef)(null);
  const refSetter = (0, import_react31.useCallback)(
    (el) => {
      sortableRef(el);
      if (ref.current !== el) {
        ref.current = el;
        setRerender((update) => update + 1);
      }
    },
    [sortableRef]
  );
  const [portalEl, setPortalEl] = (0, import_react31.useState)();
  (0, import_react31.useEffect)(() => {
    var _a5, _b3, _c4;
    setPortalEl(
      iframe.enabled ? (_a5 = ref.current) == null ? void 0 : _a5.ownerDocument.body : (_c4 = (_b3 = ref.current) == null ? void 0 : _b3.closest("[data-puck-preview]")) != null ? _c4 : document.body
    );
  }, [iframe.enabled, ref.current]);
  const getStyle = (0, import_react31.useCallback)(() => {
    var _a5, _b3, _c4;
    if (!ref.current) return;
    const rect = ref.current.getBoundingClientRect();
    const deepScrollPosition = getDeepScrollPosition(ref.current);
    const portalContainerEl = iframe.enabled ? null : (_a5 = ref.current) == null ? void 0 : _a5.closest("[data-puck-preview]");
    const portalContainerRect = portalContainerEl == null ? void 0 : portalContainerEl.getBoundingClientRect();
    const portalScroll = portalContainerEl ? getDeepScrollPosition(portalContainerEl) : { x: 0, y: 0 };
    const scroll = {
      x: deepScrollPosition.x - portalScroll.x - ((_b3 = portalContainerRect == null ? void 0 : portalContainerRect.left) != null ? _b3 : 0),
      y: deepScrollPosition.y - portalScroll.y - ((_c4 = portalContainerRect == null ? void 0 : portalContainerRect.top) != null ? _c4 : 0)
    };
    const untransformed = {
      height: ref.current.offsetHeight,
      width: ref.current.offsetWidth
    };
    const transform = accumulateTransform(ref.current);
    const style2 = {
      left: `${(rect.left + scroll.x) / transform.scaleX}px`,
      top: `${(rect.top + scroll.y) / transform.scaleY}px`,
      height: `${untransformed.height}px`,
      width: `${untransformed.width}px`
    };
    return style2;
  }, [ref.current]);
  const [style, setStyle] = (0, import_react31.useState)();
  const sync = (0, import_react31.useCallback)(() => {
    setStyle(getStyle());
  }, [ref.current, iframe]);
  (0, import_react31.useEffect)(() => {
    if (ref.current) {
      const observer = new ResizeObserver(sync);
      observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [ref.current]);
  const registerNode = useAppStore((s2) => s2.nodes.registerNode);
  const hideOverlay = (0, import_react31.useCallback)(() => {
    setIsVisible(false);
  }, []);
  const showOverlay = (0, import_react31.useCallback)(() => {
    setIsVisible(true);
  }, []);
  (0, import_react31.useEffect)(() => {
    var _a5;
    registerNode(id, {
      methods: { sync, showOverlay, hideOverlay },
      element: (_a5 = ref.current) != null ? _a5 : null
    });
    return () => {
      registerNode(id, {
        methods: {
          sync: () => null,
          hideOverlay: () => null,
          showOverlay: () => null
        },
        element: null
      });
    };
  }, [id, zoneCompound, index, componentType, sync]);
  const CustomActionBar = (0, import_react31.useMemo)(
    () => overrides.actionBar || DefaultActionBar,
    [overrides.actionBar]
  );
  const CustomOverlay = (0, import_react31.useMemo)(
    () => overrides.componentOverlay || DefaultOverlay,
    [overrides.componentOverlay]
  );
  const onClick = (0, import_react31.useCallback)(
    (e2) => {
      const el = e2.target;
      if (!el.closest("[data-puck-overlay-portal]")) {
        e2.stopPropagation();
      }
      if (isSelected) {
        dispatch({
          type: "setUi",
          ui: {
            itemSelector: null
          }
        });
      } else {
        dispatch({
          type: "setUi",
          ui: {
            itemSelector: { index, zone: zoneCompound }
          }
        });
      }
    },
    [index, zoneCompound, id, isSelected]
  );
  const appStore = useAppStoreApi();
  const onSelectParent = (0, import_react31.useCallback)(() => {
    const { nodes, zones } = appStore.getState().state.indexes;
    const node = nodes[id];
    const parentNode = (node == null ? void 0 : node.parentId) ? nodes[node == null ? void 0 : node.parentId] : null;
    if (!parentNode || !node.parentId) {
      return;
    }
    const parentZoneCompound = `${parentNode.parentId}:${parentNode.zone}`;
    const parentIndex = zones[parentZoneCompound].contentIds.indexOf(
      node.parentId
    );
    dispatch({
      type: "setUi",
      ui: {
        itemSelector: {
          zone: parentZoneCompound,
          index: parentIndex
        }
      }
    });
  }, [ctx, path]);
  const onDuplicate = (0, import_react31.useCallback)(() => {
    dispatch({
      type: "duplicate",
      sourceIndex: index,
      sourceZone: zoneCompound
    });
  }, [index, zoneCompound]);
  const onDelete = (0, import_react31.useCallback)(() => {
    dispatch({
      type: "remove",
      index,
      zone: zoneCompound
    });
  }, [index, zoneCompound]);
  const [hover, setHover] = (0, import_react31.useState)(false);
  const indicativeHover = useContextStore(
    ZoneStoreContext,
    (s2) => s2.hoveringComponent === id
  );
  (0, import_react31.useEffect)(() => {
    if (!ref.current) {
      return;
    }
    const el = ref.current;
    const _onMouseOver = (e2) => {
      const userIsDragging = !!zoneStore.getState().draggedItem;
      if (userIsDragging) {
        if (thisIsDragging) {
          setHover(true);
        } else {
          setHover(false);
        }
      } else {
        setHover(true);
      }
      e2.stopPropagation();
    };
    const _onMouseOut = (e2) => {
      e2.stopPropagation();
      setHover(false);
    };
    el.setAttribute("data-puck-component", id);
    el.setAttribute("data-puck-dnd", id);
    el.style.position = "relative";
    el.addEventListener("click", onClick);
    el.addEventListener("mouseover", _onMouseOver);
    el.addEventListener("mouseout", _onMouseOut);
    return () => {
      el.removeAttribute("data-puck-component");
      el.removeAttribute("data-puck-dnd");
      el.removeEventListener("click", onClick);
      el.removeEventListener("mouseover", _onMouseOver);
      el.removeEventListener("mouseout", _onMouseOut);
    };
  }, [
    ref.current,
    // Remount attributes if the element changes
    onClick,
    containsActiveZone,
    zoneCompound,
    id,
    thisIsDragging,
    inDroppableZone
  ]);
  const [isVisible2, setIsVisible] = (0, import_react31.useState)(false);
  const [dragFinished, setDragFinished] = (0, import_react31.useState)(true);
  const [_2, startTransition2] = (0, import_react31.useTransition)();
  (0, import_react31.useEffect)(() => {
    startTransition2(() => {
      if (hover || indicativeHover || isSelected) {
        sync();
        setIsVisible(true);
        setThisWasDragging(false);
      } else {
        setIsVisible(false);
      }
    });
  }, [hover, indicativeHover, isSelected, iframe]);
  const [thisWasDragging, setThisWasDragging] = (0, import_react31.useState)(false);
  const onDragFinished = useOnDragFinished((finished) => {
    if (finished) {
      startTransition2(() => {
        sync();
        setDragFinished(true);
      });
    } else {
      setDragFinished(false);
    }
  });
  (0, import_react31.useEffect)(() => {
    if (thisIsDragging) {
      setThisWasDragging(true);
    }
  }, [thisIsDragging]);
  (0, import_react31.useEffect)(() => {
    if (thisWasDragging) return onDragFinished();
  }, [thisWasDragging, onDragFinished]);
  const syncActionsPosition = (0, import_react31.useCallback)(
    (el) => {
      if (el) {
        const view = el.ownerDocument.defaultView;
        if (view) {
          const rect = el.getBoundingClientRect();
          const diffLeft = rect.x;
          const exceedsBoundsLeft = diffLeft < 0;
          const diffTop = rect.y;
          const exceedsBoundsTop = diffTop < 0;
          if (exceedsBoundsLeft) {
            el.style.transformOrigin = "left top";
            el.style.left = "0px";
          }
          if (exceedsBoundsTop) {
            el.style.top = "12px";
            if (!exceedsBoundsLeft) {
              el.style.transformOrigin = "right top";
            }
          }
        }
      }
    },
    [zoom]
  );
  (0, import_react31.useEffect)(() => {
    if (userDragAxis) {
      setDragAxis(userDragAxis);
      return;
    }
    if (ref.current) {
      const computedStyle = window.getComputedStyle(ref.current);
      if (computedStyle.display === "inline" || computedStyle.display === "inline-block") {
        setDragAxis("x");
        return;
      }
    }
    setDragAxis(autoDragAxis);
  }, [ref, userDragAxis, autoDragAxis]);
  const parentAction = (0, import_react31.useMemo)(
    () => (ctx == null ? void 0 : ctx.areaId) && (ctx == null ? void 0 : ctx.areaId) !== "root" && (0, import_jsx_runtime26.jsx)(ActionBar.Action, { onClick: onSelectParent, label: "Select parent", children: (0, import_jsx_runtime26.jsx)(CornerLeftUp, { size: 16 }) }),
    [ctx == null ? void 0 : ctx.areaId]
  );
  const nextContextValue = (0, import_react31.useMemo)(
    () => __spreadProps(__spreadValues({}, ctx), {
      areaId: id,
      zoneCompound,
      index,
      depth: depth + 1,
      registerLocalZone,
      unregisterLocalZone
    }),
    [
      ctx,
      id,
      zoneCompound,
      index,
      depth,
      registerLocalZone,
      unregisterLocalZone
    ]
  );
  const richText = useAppStore(
    (s2) => {
      var _a5;
      return ((_a5 = s2.currentRichText) == null ? void 0 : _a5.inlineComponentId) === id ? s2.currentRichText : null;
    }
  );
  const hasNormalActions = permissions.duplicate || permissions.delete;
  return (0, import_jsx_runtime26.jsxs)(DropZoneProvider, { value: nextContextValue, children: [
    dragFinished && isVisible2 && (0, import_react_dom3.createPortal)(
      (0, import_jsx_runtime26.jsxs)(
        "div",
        {
          className: getClassName14({
            isSelected,
            isDragging: thisIsDragging,
            hover: hover || indicativeHover
          }),
          style: __spreadValues({}, style),
          "data-puck-overlay": true,
          children: [
            debug,
            isLoading && (0, import_jsx_runtime26.jsx)("div", { className: getClassName14("loadingOverlay"), children: (0, import_jsx_runtime26.jsx)(Loader, {}) }),
            (0, import_jsx_runtime26.jsx)(
              "div",
              {
                className: getClassName14("actionsOverlay"),
                style: {
                  top: actionsOverlayTop / zoom
                },
                children: (0, import_jsx_runtime26.jsx)(
                  "div",
                  {
                    className: getClassName14("actions"),
                    style: {
                      transform: `scale(${1 / zoom}`,
                      top: actionsTop / zoom,
                      right: 0,
                      paddingLeft: actionsSide,
                      paddingRight: actionsSide
                    },
                    ref: syncActionsPosition,
                    children: (0, import_jsx_runtime26.jsxs)(
                      CustomActionBar,
                      {
                        parentAction,
                        label: DEBUG2 ? id : label,
                        children: [
                          richText && (0, import_jsx_runtime26.jsxs)(import_jsx_runtime26.Fragment, { children: [
                            (0, import_jsx_runtime26.jsx)(
                              LoadedRichTextMenu,
                              {
                                editor: richText.editor,
                                field: richText.field,
                                inline: true,
                                readOnly: false
                              }
                            ),
                            hasNormalActions && (0, import_jsx_runtime26.jsx)(ActionBar.Separator, {})
                          ] }),
                          permissions.duplicate && (0, import_jsx_runtime26.jsx)(ActionBar.Action, { onClick: onDuplicate, label: "Duplicate", children: (0, import_jsx_runtime26.jsx)(Copy, { size: 16 }) }),
                          permissions.delete && (0, import_jsx_runtime26.jsx)(ActionBar.Action, { onClick: onDelete, label: "Delete", children: (0, import_jsx_runtime26.jsx)(Trash, { size: 16 }) })
                        ]
                      }
                    )
                  }
                )
              }
            ),
            (0, import_jsx_runtime26.jsx)("div", { className: getClassName14("overlayWrapper"), children: (0, import_jsx_runtime26.jsx)(
              CustomOverlay,
              {
                componentId: id,
                componentType,
                hover,
                isSelected,
                children: (0, import_jsx_runtime26.jsx)("div", { className: getClassName14("overlay") })
              }
            ) })
          ]
        }
      ),
      portalEl || document.body
    ),
    children(refSetter)
  ] });
};
init_react_import();
var styles_module_default10 = { "DropZone": "_DropZone_1i2sv_1", "DropZone--hasChildren": "_DropZone--hasChildren_1i2sv_11", "DropZone--isAreaSelected": "_DropZone--isAreaSelected_1i2sv_24", "DropZone--hoveringOverArea": "_DropZone--hoveringOverArea_1i2sv_25", "DropZone--isRootZone": "_DropZone--isRootZone_1i2sv_25", "DropZone--isDestination": "_DropZone--isDestination_1i2sv_35", "DropZone-item": "_DropZone-item_1i2sv_47", "DropZone-hitbox": "_DropZone-hitbox_1i2sv_51", "DropZone--isEnabled": "_DropZone--isEnabled_1i2sv_59", "DropZone--isAnimating": "_DropZone--isAnimating_1i2sv_68" };
init_react_import();
var getNumItems = (appStore, zoneCompound) => appStore.getState().state.indexes.zones[zoneCompound].contentIds.length;
var useMinEmptyHeight = ({
  zoneCompound,
  userMinEmptyHeight,
  ref
}) => {
  const appStore = useAppStoreApi();
  const [prevHeight, setPrevHeight] = (0, import_react35.useState)(0);
  const [isAnimating, setIsAnimating] = (0, import_react35.useState)(false);
  const { draggedItem, isZone } = useContextStore(ZoneStoreContext, (s2) => {
    var _a5, _b3;
    return {
      draggedItem: ((_a5 = s2.draggedItem) == null ? void 0 : _a5.data.zone) === zoneCompound ? s2.draggedItem : null,
      isZone: ((_b3 = s2.draggedItem) == null ? void 0 : _b3.data.zone) === zoneCompound
    };
  });
  const numItems = (0, import_react35.useRef)(0);
  const onDragFinished = useOnDragFinished(
    (finished) => {
      var _a5;
      if (finished) {
        const newNumItems = getNumItems(appStore, zoneCompound);
        setPrevHeight(0);
        if (newNumItems || numItems.current === 0) {
          setIsAnimating(false);
          return;
        }
        const selectedItem = appStore.getState().selectedItem;
        const zones = appStore.getState().state.indexes.zones;
        const nodes = appStore.getState().nodes;
        (_a5 = nodes.nodes[selectedItem == null ? void 0 : selectedItem.props.id]) == null ? void 0 : _a5.methods.hideOverlay();
        setTimeout(() => {
          var _a23;
          const contentIds = ((_a23 = zones[zoneCompound]) == null ? void 0 : _a23.contentIds) || [];
          contentIds.forEach((contentId) => {
            const node = nodes.nodes[contentId];
            node == null ? void 0 : node.methods.sync();
          });
          if (selectedItem) {
            setTimeout(() => {
              var _a33, _b3;
              (_a33 = nodes.nodes[selectedItem.props.id]) == null ? void 0 : _a33.methods.sync();
              (_b3 = nodes.nodes[selectedItem.props.id]) == null ? void 0 : _b3.methods.showOverlay();
            }, 200);
          }
          setIsAnimating(false);
        }, 100);
      }
    },
    [appStore, prevHeight, zoneCompound]
  );
  (0, import_react35.useEffect)(() => {
    if (draggedItem && ref.current) {
      if (isZone) {
        const rect = ref.current.getBoundingClientRect();
        numItems.current = getNumItems(appStore, zoneCompound);
        setPrevHeight(rect.height);
        setIsAnimating(true);
        return onDragFinished();
      }
    }
  }, [ref.current, draggedItem, onDragFinished]);
  const returnedMinHeight = isNaN(Number(userMinEmptyHeight)) ? userMinEmptyHeight : `${userMinEmptyHeight}px`;
  return [prevHeight ? `${prevHeight}px` : returnedMinHeight, isAnimating];
};
init_react_import();
function assignRef(ref, node) {
  if (typeof ref === "function") {
    ref(node);
  } else if (ref && typeof ref === "object" && "current" in ref) {
    ref.current = node;
  }
}
function assignRefs(refs, node) {
  refs.forEach((ref) => {
    assignRef(ref, node);
  });
}
init_react_import();
init_react_import();
function useRenderedCallback(callback, deps) {
  const manager = useDragDropManager();
  return (0, import_react38.useCallback)(
    (...args) => __async(null, null, function* () {
      yield manager == null ? void 0 : manager.renderer.rendering;
      return callback(...args);
    }),
    [...deps, manager]
  );
}
var useContentIdsWithPreview = (contentIds, zoneCompound) => {
  const zoneStore = (0, import_react36.useContext)(ZoneStoreContext);
  const preview = useContextStore(
    ZoneStoreContext,
    (s2) => s2.previewIndex[zoneCompound]
  );
  const isDragging = useAppStore((s2) => s2.state.ui.isDragging);
  const [contentIdsWithPreview, setContentIdsWithPreview] = (0, import_react36.useState)(contentIds);
  const [localPreview, setLocalPreview] = (0, import_react36.useState)(
    preview
  );
  const updateContent = useRenderedCallback(
    (contentIds2, preview2, isDragging2, draggedItemId, previewExists) => {
      if (isDragging2 && !previewExists) {
        return;
      }
      if (preview2) {
        if (preview2.type === "insert") {
          setContentIdsWithPreview(
            insert(
              contentIds2.filter((id) => id !== preview2.props.id),
              preview2.index,
              preview2.props.id
            )
          );
        } else {
          setContentIdsWithPreview(
            insert(
              contentIds2.filter((id) => id !== preview2.props.id),
              preview2.index,
              preview2.props.id
            )
          );
        }
      } else {
        setContentIdsWithPreview(
          previewExists ? contentIds2.filter((id) => id !== draggedItemId) : contentIds2
        );
      }
      setLocalPreview(preview2);
    },
    []
  );
  (0, import_react36.useEffect)(() => {
    var _a5;
    const s2 = zoneStore.getState();
    const draggedItemId = (_a5 = s2.draggedItem) == null ? void 0 : _a5.id;
    const previewExists = Object.keys(s2.previewIndex || {}).length > 0;
    updateContent(
      contentIds,
      preview,
      isDragging,
      draggedItemId,
      previewExists
    );
  }, [contentIds, preview, isDragging]);
  return [contentIdsWithPreview, localPreview];
};
init_react_import();
var GRID_DRAG_AXIS = "dynamic";
var FLEX_ROW_DRAG_AXIS = "x";
var DEFAULT_DRAG_AXIS = "y";
var useDragAxis = (ref, collisionAxis) => {
  const status = useAppStore((s2) => s2.status);
  const [dragAxis, setDragAxis] = (0, import_react39.useState)(
    collisionAxis || DEFAULT_DRAG_AXIS
  );
  const calculateDragAxis = (0, import_react39.useCallback)(() => {
    if (ref.current) {
      const computedStyle = window.getComputedStyle(ref.current);
      if (computedStyle.display === "grid") {
        setDragAxis(GRID_DRAG_AXIS);
      } else if (computedStyle.display === "flex" && computedStyle.flexDirection === "row") {
        setDragAxis(FLEX_ROW_DRAG_AXIS);
      } else {
        setDragAxis(DEFAULT_DRAG_AXIS);
      }
    }
  }, [ref.current]);
  (0, import_react39.useEffect)(() => {
    const onViewportChange = () => {
      calculateDragAxis();
    };
    window.addEventListener("viewportchange", onViewportChange);
    return () => {
      window.removeEventListener("viewportchange", onViewportChange);
    };
  }, []);
  (0, import_react39.useEffect)(calculateDragAxis, [status, collisionAxis]);
  return [dragAxis, calculateDragAxis];
};
init_react_import();
init_react_import();
var ContextSlotRender = ({
  componentId,
  zone
}) => {
  const config = useAppStore((s2) => s2.config);
  const metadata = useAppStore((s2) => s2.metadata);
  const slotContent = useAppStore(
    useShallow((s2) => {
      var _a5, _b3;
      const indexes = s2.state.indexes;
      const contentIds = (_b3 = (_a5 = indexes.zones[`${componentId}:${zone}`]) == null ? void 0 : _a5.contentIds) != null ? _b3 : [];
      return contentIds.map((contentId) => indexes.nodes[contentId].flatData);
    })
  );
  return (0, import_jsx_runtime27.jsx)(
    SlotRenderPure,
    {
      content: slotContent,
      zone,
      config,
      metadata
    }
  );
};
var renderContext = import_react40.default.createContext({
  config: { components: {} },
  data: { root: {}, content: [] },
  metadata: {}
});
function Render({
  config,
  data,
  metadata = {}
}) {
  var _a5, _b3;
  const defaultedData = __spreadProps(__spreadValues({}, data), {
    root: data.root || {},
    content: data.content || []
  });
  const rootProps = "props" in defaultedData.root ? defaultedData.root.props : defaultedData.root;
  const title = (rootProps == null ? void 0 : rootProps.title) || "";
  const pageProps = __spreadProps(__spreadValues({}, rootProps), {
    puck: {
      renderDropZone: DropZonePure,
      isEditing: false,
      dragRef: null,
      metadata
    },
    title,
    editMode: false,
    id: "puck-root"
  });
  const propsWithSlots = useSlots(
    config,
    { type: "root", props: pageProps },
    (props) => (0, import_jsx_runtime28.jsx)(SlotRender, __spreadProps(__spreadValues({}, props), { config, metadata }))
  );
  const richtextProps = useRichtextProps((_a5 = config.root) == null ? void 0 : _a5.fields, pageProps);
  const nextContextValue = (0, import_react40.useMemo)(
    () => ({
      mode: "render",
      depth: 0
    }),
    []
  );
  if ((_b3 = config.root) == null ? void 0 : _b3.render) {
    return (0, import_jsx_runtime28.jsx)(renderContext.Provider, { value: { config, data: defaultedData, metadata }, children: (0, import_jsx_runtime28.jsx)(DropZoneProvider, { value: nextContextValue, children: (0, import_jsx_runtime28.jsx)(config.root.render, __spreadProps(__spreadValues(__spreadValues({}, propsWithSlots), richtextProps), { children: (0, import_jsx_runtime28.jsx)(DropZoneRenderPure, { zone: rootZone }) })) }) });
  }
  return (0, import_jsx_runtime28.jsx)(renderContext.Provider, { value: { config, data: defaultedData, metadata }, children: (0, import_jsx_runtime28.jsx)(DropZoneProvider, { value: nextContextValue, children: (0, import_jsx_runtime28.jsx)(DropZoneRenderPure, { zone: rootZone }) }) });
}
init_react_import();
function useFieldTransformsTracked(config, item, transforms, readOnly, forceReadOnly) {
  const prevProps = (0, import_react41.useRef)(null);
  const prevResult = (0, import_react41.useRef)(item.props);
  const mappers = (0, import_react41.useMemo)(
    () => buildMappers(transforms, readOnly, forceReadOnly),
    [transforms, readOnly, forceReadOnly]
  );
  const transformedProps = (0, import_react41.useMemo)(() => {
    var _a5, _b3, _c4;
    const changedProps = {};
    const componentConfig = item.type === "root" ? config.root : (_a5 = config.components) == null ? void 0 : _a5[item.type];
    let changeIncludesSlot = false;
    for (const fieldName in item.props) {
      const fieldType = (_c4 = (_b3 = componentConfig == null ? void 0 : componentConfig.fields) == null ? void 0 : _b3[fieldName]) == null ? void 0 : _c4.type;
      if (!prevProps.current || item.props[fieldName] !== prevProps.current[fieldName]) {
        changedProps[fieldName] = item.props[fieldName];
        if (fieldType === "slot") {
          changeIncludesSlot = true;
        }
      }
    }
    changedProps.id = item.props.id;
    prevProps.current = item.props;
    const mapped = mapFields(
      __spreadProps(__spreadValues({}, item), { props: changedProps }),
      mappers,
      config,
      false,
      changeIncludesSlot
    ).props;
    prevResult.current = __spreadValues(__spreadValues({}, prevResult.current), mapped);
    return prevResult.current;
  }, [config, item, mappers]);
  const mergedProps = (0, import_react41.useMemo)(
    () => __spreadValues(__spreadValues({}, item.props), transformedProps),
    [item.props, transformedProps]
  );
  return mergedProps;
}
init_react_import();
init_react_import();
init_react_import();
var registerOverlayPortal = (el, opts = {}) => {
  if (!el) return;
  const { disableDrag = false, disableDragOnFocus = true } = opts;
  const stopPropagation = (e2) => {
    e2.stopPropagation();
  };
  el.addEventListener("mouseover", stopPropagation, {
    capture: true
  });
  const onFocus = () => {
    setTimeout(() => {
      el.addEventListener("pointerdown", stopPropagation, {
        capture: true
      });
    }, 200);
  };
  const onBlur = () => {
    el.removeEventListener("pointerdown", stopPropagation, {
      capture: true
    });
  };
  if (disableDrag) {
    el.addEventListener("pointerdown", stopPropagation, {
      capture: true
    });
  } else if (disableDragOnFocus) {
    el.addEventListener("focus", onFocus, { capture: true });
    el.addEventListener("blur", onBlur, { capture: true });
  }
  el.setAttribute("data-puck-overlay-portal", "true");
  return () => {
    el.removeEventListener("mouseover", stopPropagation, {
      capture: true
    });
    if (disableDrag) {
      el.removeEventListener("pointerdown", stopPropagation, {
        capture: true
      });
    } else if (disableDragOnFocus) {
      el.removeEventListener("focus", onFocus, { capture: true });
      el.removeEventListener("blur", onBlur, { capture: true });
    }
    el.removeAttribute("data-puck-overlay-portal");
  };
};
init_react_import();
var styles_module_default11 = { "InlineTextField": "_InlineTextField_104qp_1" };
init_react_import();
function setDeep(node, path, newVal) {
  const parts = path.split(".");
  const newNode = __spreadValues({}, node);
  let cur = newNode;
  for (let i2 = 0; i2 < parts.length; i2++) {
    const [prop, idxStr] = parts[i2].replace("]", "").split("[");
    const isLast = i2 === parts.length - 1;
    if (idxStr !== void 0) {
      if (!Array.isArray(cur[prop])) {
        cur[prop] = [];
      }
      const idx = Number(idxStr);
      if (isLast) {
        cur[prop][idx] = newVal;
        continue;
      }
      if (cur[prop][idx] === void 0) cur[prop][idx] = {};
      cur = cur[prop][idx];
      continue;
    }
    if (isLast) {
      cur[prop] = newVal;
      continue;
    }
    if (cur[prop] === void 0) {
      cur[prop] = {};
    }
    cur = cur[prop];
  }
  return __spreadValues(__spreadValues({}, node), newNode);
}
init_react_import();
var getSelectorForId = (state, id) => {
  const node = state.indexes.nodes[id];
  if (!node) return;
  const zoneCompound = `${node.parentId}:${node.zone}`;
  const index = state.indexes.zones[zoneCompound].contentIds.indexOf(id);
  return { zone: zoneCompound, index };
};
var getClassName15 = get_class_name_factory_default("InlineTextField", styles_module_default11);
var InlineTextFieldInternal = ({
  propPath,
  componentId,
  value,
  isReadOnly,
  opts = {}
}) => {
  var _a5;
  const ref = (0, import_react42.useRef)(null);
  const appStoreApi = useAppStoreApi();
  const disableLineBreaks = (_a5 = opts.disableLineBreaks) != null ? _a5 : false;
  (0, import_react42.useEffect)(() => {
    const appStore = appStoreApi.getState();
    const data = appStore.state.indexes.nodes[componentId].data;
    const componentConfig = appStore.getComponentConfig(data.type);
    if (!componentConfig) {
      throw new Error(
        `InlineTextField Error: No config defined for ${data.type}`
      );
    }
    if (ref.current) {
      if (value !== ref.current.innerText) {
        ref.current.replaceChildren(value);
      }
      const cleanupPortal = registerOverlayPortal(ref.current);
      const handleInput = (e2) => __async(null, null, function* () {
        var _a23;
        const appStore2 = appStoreApi.getState();
        const node = appStore2.state.indexes.nodes[componentId];
        const zoneCompound = `${node.parentId}:${node.zone}`;
        const index = (_a23 = appStore2.state.indexes.zones[zoneCompound]) == null ? void 0 : _a23.contentIds.indexOf(
          componentId
        );
        let value2 = e2.target.innerText;
        if (disableLineBreaks) {
          value2 = value2.replaceAll(/\n/gm, "");
        }
        const newProps = setDeep(node.data.props, propPath, value2);
        const resolvedData = yield appStore2.resolveComponentData(
          __spreadProps(__spreadValues({}, node.data), { props: newProps }),
          "replace"
        );
        appStore2.dispatch({
          type: "replace",
          data: resolvedData.node,
          destinationIndex: index,
          destinationZone: zoneCompound
        });
      });
      ref.current.addEventListener("input", handleInput);
      return () => {
        var _a23;
        (_a23 = ref.current) == null ? void 0 : _a23.removeEventListener("input", handleInput);
        cleanupPortal == null ? void 0 : cleanupPortal();
      };
    }
  }, [appStoreApi, ref.current, value, disableLineBreaks]);
  const [isHovering, setIsHovering] = (0, import_react42.useState)(false);
  const [isFocused, setIsFocused] = (0, import_react42.useState)(false);
  return (0, import_jsx_runtime29.jsx)(
    "span",
    {
      className: getClassName15(),
      ref,
      contentEditable: isHovering || isFocused ? "plaintext-only" : "false",
      onClick: (e2) => {
        e2.preventDefault();
        e2.stopPropagation();
      },
      onClickCapture: (e2) => {
        e2.preventDefault();
        e2.stopPropagation();
        const itemSelector = getSelectorForId(
          appStoreApi.getState().state,
          componentId
        );
        appStoreApi.getState().setUi({ itemSelector });
      },
      onKeyDown: (e2) => {
        e2.stopPropagation();
        if (disableLineBreaks && e2.key === "Enter" || isReadOnly) {
          e2.preventDefault();
        }
      },
      onKeyUp: (e2) => {
        e2.stopPropagation();
        e2.preventDefault();
      },
      onMouseOverCapture: () => setIsHovering(true),
      onMouseOutCapture: () => setIsHovering(false),
      onFocus: () => setIsFocused(true),
      onBlur: () => setIsFocused(false)
    }
  );
};
var InlineTextField = (0, import_react42.memo)(InlineTextFieldInternal);
var getInlineTextTransform = () => ({
  text: ({ value, componentId, field, propPath, isReadOnly }) => {
    if (field.contentEditable) {
      return (0, import_jsx_runtime30.jsx)(
        InlineTextField,
        {
          propPath,
          componentId,
          value,
          opts: { disableLineBreaks: true },
          isReadOnly
        }
      );
    }
    return value;
  },
  textarea: ({ value, componentId, field, propPath, isReadOnly }) => {
    if (field.contentEditable) {
      return (0, import_jsx_runtime30.jsx)(
        InlineTextField,
        {
          propPath,
          componentId,
          value,
          isReadOnly
        }
      );
    }
    return value;
  },
  custom: ({ value, componentId, field, propPath, isReadOnly }) => {
    if (field.contentEditable && typeof value === "string") {
      return (0, import_jsx_runtime30.jsx)(
        InlineTextField,
        {
          propPath,
          componentId,
          value,
          isReadOnly
        }
      );
    }
    return value;
  }
});
init_react_import();
var Editor2 = (0, import_react43.lazy)(
  () => import("./Editor-NK3TZSR6-AZMGDXZX.js").then((m2) => ({
    default: m2.Editor
  }))
);
var RichTextRender = (0, import_react43.lazy)(
  () => import("./Render-CU35UAWV-NF7YNHHV.js").then((m2) => ({
    default: m2.RichTextRender
  }))
);
var InlineEditorWrapper = (0, import_react43.memo)(
  ({
    value,
    componentId,
    propPath,
    field,
    id
  }) => {
    const portalRef = (0, import_react43.useRef)(null);
    const appStoreApi = useAppStoreApi();
    const onClickHandler = (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
    };
    const onClickCaptureHandler = (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
      const itemSelector = getSelectorForId(
        appStoreApi.getState().state,
        componentId
      );
      appStoreApi.getState().setUi({ itemSelector });
    };
    (0, import_react43.useEffect)(() => {
      if (!portalRef.current) return;
      const cleanup = registerOverlayPortal(portalRef.current, {
        disableDragOnFocus: true
      });
      return () => cleanup == null ? void 0 : cleanup();
    }, [portalRef.current]);
    const handleChange = (0, import_react43.useCallback)(
      (content, ui) => __async(null, null, function* () {
        var _a5;
        const appStore = appStoreApi.getState();
        const node = appStore.state.indexes.nodes[componentId];
        const zoneCompound = `${node.parentId}:${node.zone}`;
        const index = (_a5 = appStore.state.indexes.zones[zoneCompound]) == null ? void 0 : _a5.contentIds.indexOf(
          componentId
        );
        const newProps = setDeep(node.data.props, propPath, content);
        const resolvedData = yield appStore.resolveComponentData(
          __spreadProps(__spreadValues({}, node.data), { props: newProps }),
          "replace"
        );
        appStore.dispatch({
          type: "replace",
          data: resolvedData.node,
          destinationIndex: index,
          destinationZone: zoneCompound,
          ui
        });
      }),
      [appStoreApi, componentId, propPath]
    );
    const handleFocus = (0, import_react43.useCallback)(
      (editor) => {
        appStoreApi.setState({
          currentRichText: {
            inlineComponentId: componentId,
            inline: true,
            field,
            editor,
            id
          }
        });
      },
      [field, componentId]
    );
    if (!field.contentEditable)
      return (0, import_jsx_runtime31.jsx)(import_react43.Suspense, { fallback: (0, import_jsx_runtime31.jsx)(RichTextRenderFallback, { content: value }), children: (0, import_jsx_runtime31.jsx)(RichTextRender, { content: value, field }) });
    const editorProps = {
      content: value,
      onChange: handleChange,
      field,
      inline: true,
      onFocus: handleFocus,
      id,
      name: propPath
    };
    return (0, import_jsx_runtime31.jsx)(
      "div",
      {
        ref: portalRef,
        onClick: onClickHandler,
        onClickCapture: onClickCaptureHandler,
        children: (0, import_jsx_runtime31.jsx)(import_react43.Suspense, { fallback: (0, import_jsx_runtime31.jsx)(EditorFallback, __spreadValues({}, editorProps)), children: (0, import_jsx_runtime31.jsx)(Editor2, __spreadValues({}, editorProps)) })
      }
    );
  }
);
InlineEditorWrapper.displayName = "InlineEditorWrapper";
var getRichTextTransform = () => ({
  richtext: ({ value, componentId, field, propPath, isReadOnly }) => {
    const { contentEditable = true, tiptap } = field;
    if (contentEditable === false || isReadOnly) {
      return (0, import_jsx_runtime31.jsx)(RichTextRender, { content: value, field });
    }
    const id = `${componentId}_${field.type}_${propPath}`;
    return (0, import_jsx_runtime31.jsx)(
      InlineEditorWrapper,
      {
        value,
        componentId,
        propPath,
        field,
        id
      },
      id
    );
  }
});
init_react_import();
init_react_import();
function shallowEqual(obj1, obj2, keysToIgnore = []) {
  if (Object.is(obj1, obj2)) return true;
  if (typeof obj1 !== "object" || obj1 === null || typeof obj2 !== "object" || obj2 === null) {
    return false;
  }
  if (Object.getPrototypeOf(obj1) !== Object.getPrototypeOf(obj2)) {
    return false;
  }
  const ignore = new Set(keysToIgnore);
  const keys1 = Object.keys(obj1).filter((k) => !ignore.has(k));
  const keys2 = Object.keys(obj2).filter((k) => !ignore.has(k));
  if (keys1.length !== keys2.length) return false;
  for (let i2 = 0; i2 < keys1.length; i2++) {
    const currKey = keys1[i2];
    if (!Object.prototype.hasOwnProperty.call(obj2, currKey)) return false;
    const val1 = obj1[currKey];
    const val2 = obj2[currKey];
    if (!Object.is(val1, val2)) return false;
  }
  return true;
}
var RenderComponent = ({
  Component,
  componentProps: renderProps
}) => {
  return (0, import_jsx_runtime32.jsx)(Component, __spreadValues({}, renderProps));
};
var MemoizeComponent = (0, import_react44.memo)(RenderComponent, (prev, next) => {
  let puckEquals = true;
  if ("puck" in prev.componentProps && "puck" in next.componentProps) {
    puckEquals = deepEqual(prev.componentProps.puck, next.componentProps.puck);
  }
  return prev.Component === next.Component && shallowEqual(prev.componentProps, next.componentProps, ["puck"]) && puckEquals;
});
var getClassName16 = get_class_name_factory_default("DropZone", styles_module_default10);
var getRandomColor = () => `#${Math.floor(Math.random() * 16777215).toString(16)}`;
var RENDER_DEBUG = false;
var InsertPreview = ({
  element,
  label,
  override
}) => {
  if (element) {
    return (
      // Safe to use this since the HTML is set by the user
      (0, import_jsx_runtime33.jsx)("div", { dangerouslySetInnerHTML: { __html: element.outerHTML } })
    );
  }
  return (0, import_jsx_runtime33.jsx)(DrawerItemInner, { name: label, children: override });
};
var DropZoneEditPure = (props) => (0, import_jsx_runtime33.jsx)(DropZoneEdit, __spreadValues({}, props));
var DropZoneChild = ({
  zoneCompound,
  componentId,
  index,
  dragAxis,
  collisionAxis,
  inDroppableZone
}) => {
  var _a5, _b3;
  const metadata = useAppStore((s2) => s2.metadata);
  const ctx = (0, import_react30.useContext)(dropZoneContext);
  const { depth = 1 } = ctx != null ? ctx : {};
  const zoneStore = (0, import_react30.useContext)(ZoneStoreContext);
  const nodeProps = useAppStore(
    useShallow((s2) => {
      var _a23;
      return (_a23 = s2.state.indexes.nodes[componentId]) == null ? void 0 : _a23.flatData.props;
    })
  );
  const nodeType = useAppStore(
    (s2) => {
      var _a23;
      return (_a23 = s2.state.indexes.nodes[componentId]) == null ? void 0 : _a23.data.type;
    }
  );
  const nodeReadOnly = useAppStore(
    useShallow((s2) => {
      var _a23;
      return (_a23 = s2.state.indexes.nodes[componentId]) == null ? void 0 : _a23.data.readOnly;
    })
  );
  const appStore = useAppStoreApi();
  const item = (0, import_react30.useMemo)(() => {
    if (nodeProps) {
      const expanded = expandNode({
        type: nodeType,
        props: nodeProps
      });
      return expanded;
    }
    const preview = zoneStore.getState().previewIndex[zoneCompound];
    if (componentId === (preview == null ? void 0 : preview.props.id)) {
      return {
        type: preview.componentType,
        props: preview.props,
        previewType: preview.type,
        element: preview.element
      };
    }
    return null;
  }, [appStore, componentId, zoneCompound, nodeType, nodeProps]);
  const componentConfig = useAppStore(
    (s2) => (item == null ? void 0 : item.type) ? s2.config.components[item.type] : null
  );
  const puckProps = (0, import_react30.useMemo)(
    () => ({
      renderDropZone: DropZoneEditPure,
      isEditing: true,
      dragRef: null,
      metadata: __spreadValues(__spreadValues({}, metadata), componentConfig == null ? void 0 : componentConfig.metadata)
    }),
    [metadata, componentConfig == null ? void 0 : componentConfig.metadata]
  );
  const overrides = useAppStore((s2) => s2.overrides);
  const isLoading = useAppStore(
    (s2) => {
      var _a23;
      return ((_a23 = s2.componentState[componentId]) == null ? void 0 : _a23.loadingCount) > 0;
    }
  );
  const isSelected = useAppStore(
    (s2) => {
      var _a23;
      return ((_a23 = s2.selectedItem) == null ? void 0 : _a23.props.id) === componentId || false;
    }
  );
  let label = (_b3 = (_a5 = componentConfig == null ? void 0 : componentConfig.label) != null ? _a5 : item == null ? void 0 : item.type.toString()) != null ? _b3 : "Component";
  const defaultsProps = (0, import_react30.useMemo)(
    () => __spreadProps(__spreadValues(__spreadValues({}, componentConfig == null ? void 0 : componentConfig.defaultProps), item == null ? void 0 : item.props), {
      puck: puckProps,
      editMode: true
      // DEPRECATED
    }),
    [componentConfig == null ? void 0 : componentConfig.defaultProps, item == null ? void 0 : item.props, puckProps]
  );
  const defaultedNode = (0, import_react30.useMemo)(
    () => {
      var _a23;
      return { type: (_a23 = item == null ? void 0 : item.type) != null ? _a23 : nodeType, props: defaultsProps };
    },
    [item == null ? void 0 : item.type, nodeType, defaultsProps]
  );
  const config = useAppStore((s2) => s2.config);
  const plugins = useAppStore((s2) => s2.plugins);
  const userFieldTransforms = useAppStore((s2) => s2.fieldTransforms);
  const combinedFieldTransforms = (0, import_react30.useMemo)(
    () => __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, getSlotTransform(DropZoneEditPure, (slotProps) => (0, import_jsx_runtime33.jsx)(ContextSlotRender, { componentId, zone: slotProps.zone }))), getInlineTextTransform()), getRichTextTransform()), plugins.reduce(
      (acc, plugin) => __spreadValues(__spreadValues({}, acc), plugin.fieldTransforms),
      {}
    )), userFieldTransforms),
    [plugins, userFieldTransforms]
  );
  const transformedProps = useFieldTransformsTracked(
    config,
    defaultedNode,
    combinedFieldTransforms,
    nodeReadOnly,
    isLoading
  );
  if (!item) return;
  const Render2 = componentConfig ? componentConfig.render : () => (0, import_jsx_runtime33.jsxs)("div", { style: { padding: 48, textAlign: "center" }, children: [
    "No configuration for ",
    item.type
  ] });
  let componentType = item.type;
  const isInserting = "previewType" in item ? item.previewType === "insert" : false;
  return (0, import_jsx_runtime33.jsx)(
    DraggableComponent,
    {
      id: componentId,
      componentType,
      zoneCompound,
      depth: depth + 1,
      index,
      isLoading,
      isSelected,
      label,
      autoDragAxis: dragAxis,
      userDragAxis: collisionAxis,
      inDroppableZone,
      children: (dragRef) => {
        var _a23;
        if ((componentConfig == null ? void 0 : componentConfig.inline) && !isInserting) {
          return (0, import_jsx_runtime33.jsx)(
            MemoizeComponent,
            {
              Component: Render2,
              componentProps: __spreadProps(__spreadValues({}, transformedProps), {
                puck: __spreadProps(__spreadValues({}, transformedProps.puck), { dragRef })
              })
            }
          );
        }
        return (0, import_jsx_runtime33.jsx)("div", { ref: dragRef, children: isInserting ? (0, import_jsx_runtime33.jsx)(
          InsertPreview,
          {
            label,
            override: (_a23 = overrides.componentItem) != null ? _a23 : overrides.drawerItem,
            element: "element" in item && item.element ? item.element : void 0
          }
        ) : (0, import_jsx_runtime33.jsx)(
          MemoizeComponent,
          {
            Component: Render2,
            componentProps: transformedProps
          }
        ) });
      }
    }
  );
};
var DropZoneChildMemo = (0, import_react30.memo)(DropZoneChild);
var DropZoneEdit = (0, import_react30.forwardRef)(
  function DropZoneEditInternal({
    zone,
    allow,
    disallow,
    style,
    className,
    minEmptyHeight: userMinEmptyHeight = "128px",
    collisionAxis,
    as
  }, userRef) {
    const ctx = (0, import_react30.useContext)(dropZoneContext);
    const appStoreApi = useAppStoreApi();
    const {
      // These all need setting via context
      areaId,
      depth = 0,
      registerLocalZone,
      unregisterLocalZone
    } = ctx != null ? ctx : {};
    const path = useAppStore(
      useShallow((s2) => {
        var _a5;
        return areaId ? (_a5 = s2.state.indexes.nodes[areaId]) == null ? void 0 : _a5.path : null;
      })
    );
    let zoneCompound = rootDroppableId;
    if (areaId) {
      if (zone !== rootDroppableId) {
        zoneCompound = `${areaId}:${zone}`;
      }
    }
    const isRootZone = zoneCompound === rootDroppableId || zone === rootDroppableId || areaId === "root";
    const inNextDeepestArea = useContextStore(
      ZoneStoreContext,
      (s2) => s2.nextAreaDepthIndex[areaId || ""]
    );
    const zoneContentIds = useAppStore(
      useShallow((s2) => {
        var _a5;
        return (_a5 = s2.state.indexes.zones[zoneCompound]) == null ? void 0 : _a5.contentIds;
      })
    );
    const zoneType = useAppStore(
      useShallow((s2) => {
        var _a5;
        return (_a5 = s2.state.indexes.zones[zoneCompound]) == null ? void 0 : _a5.type;
      })
    );
    (0, import_react30.useEffect)(() => {
      if (!zoneType || zoneType === "dropzone") {
        if (ctx == null ? void 0 : ctx.registerZone) {
          ctx == null ? void 0 : ctx.registerZone(zoneCompound);
        }
      }
    }, [zoneType, appStoreApi]);
    (0, import_react30.useEffect)(() => {
      if (zoneType === "dropzone") {
        if (zoneCompound !== rootDroppableId) {
          console.warn(
            "DropZones have been deprecated in favor of slot fields and will be removed in a future version of Puck. Please see the migration guide: https://www.puckeditor.com/docs/guides/migrations/dropzones-to-slots"
          );
        }
      }
    }, [zoneType]);
    const contentIds = (0, import_react30.useMemo)(() => {
      return zoneContentIds || [];
    }, [zoneContentIds]);
    const ref = (0, import_react30.useRef)(null);
    const acceptsTarget = (0, import_react30.useCallback)(
      (componentType) => {
        if (!componentType) {
          return true;
        }
        if (disallow) {
          const defaultedAllow = allow || [];
          const filteredDisallow = (disallow || []).filter(
            (item) => defaultedAllow.indexOf(item) === -1
          );
          if (filteredDisallow.indexOf(componentType) !== -1) {
            return false;
          }
        } else if (allow) {
          if (allow.indexOf(componentType) === -1) {
            return false;
          }
        }
        return true;
      },
      [allow, disallow]
    );
    const targetAccepted = useContextStore(ZoneStoreContext, (s2) => {
      var _a5;
      const draggedComponentType = (_a5 = s2.draggedItem) == null ? void 0 : _a5.data.componentType;
      return acceptsTarget(draggedComponentType);
    });
    const hoveringOverArea = inNextDeepestArea || isRootZone;
    const isEnabled = useContextStore(ZoneStoreContext, (s2) => {
      var _a5;
      let _isEnabled = true;
      const isDeepestZone = (_a5 = s2.zoneDepthIndex[zoneCompound]) != null ? _a5 : false;
      _isEnabled = isDeepestZone;
      if (_isEnabled) {
        _isEnabled = targetAccepted;
      }
      return _isEnabled;
    });
    (0, import_react30.useEffect)(() => {
      if (registerLocalZone) {
        registerLocalZone(zoneCompound, targetAccepted || isEnabled);
      }
      return () => {
        if (unregisterLocalZone) {
          unregisterLocalZone(zoneCompound);
        }
      };
    }, [targetAccepted, isEnabled, zoneCompound]);
    const [contentIdsWithPreview, preview] = useContentIdsWithPreview(
      contentIds,
      zoneCompound
    );
    const isDropEnabled = isEnabled && (preview ? contentIdsWithPreview.length === 1 : contentIdsWithPreview.length === 0);
    const zoneStore = (0, import_react30.useContext)(ZoneStoreContext);
    (0, import_react30.useEffect)(() => {
      const { enabledIndex } = zoneStore.getState();
      zoneStore.setState({
        enabledIndex: __spreadProps(__spreadValues({}, enabledIndex), { [zoneCompound]: isEnabled })
      });
    }, [isEnabled, zoneStore, zoneCompound]);
    const droppableConfig = {
      id: zoneCompound,
      collisionPriority: isEnabled ? depth : 0,
      disabled: !isDropEnabled,
      collisionDetector: pointerIntersection3,
      type: "dropzone",
      data: {
        areaId,
        depth,
        isDroppableTarget: targetAccepted,
        path: path || []
      }
    };
    const { ref: dropRef } = useDroppable(droppableConfig);
    const isAreaSelected = useAppStore(
      (s2) => (s2 == null ? void 0 : s2.selectedItem) && areaId === (s2 == null ? void 0 : s2.selectedItem.props.id)
    );
    const [dragAxis] = useDragAxis(ref, collisionAxis);
    const [minEmptyHeight, isAnimating] = useMinEmptyHeight({
      zoneCompound,
      userMinEmptyHeight,
      ref
    });
    const setRefs = (0, import_react30.useCallback)(
      (node) => {
        assignRefs([ref, dropRef, userRef], node);
      },
      [dropRef]
    );
    const El = as != null ? as : "div";
    return (0, import_jsx_runtime33.jsx)(
      El,
      {
        className: `${getClassName16({
          isRootZone,
          hoveringOverArea,
          isEnabled,
          isAreaSelected,
          hasChildren: contentIds.length > 0,
          isAnimating
        })}${className ? ` ${className}` : ""}`,
        ref: setRefs,
        "data-testid": `dropzone:${zoneCompound}`,
        "data-puck-dropzone": zoneCompound,
        style: __spreadProps(__spreadValues({}, style), {
          "--min-empty-height": minEmptyHeight,
          backgroundColor: RENDER_DEBUG ? getRandomColor() : style == null ? void 0 : style.backgroundColor
        }),
        children: contentIdsWithPreview.map((componentId, i2) => {
          return (0, import_jsx_runtime33.jsx)(
            DropZoneChildMemo,
            {
              zoneCompound,
              componentId,
              dragAxis,
              index: i2,
              collisionAxis,
              inDroppableZone: targetAccepted
            },
            componentId
          );
        })
      }
    );
  }
);
var DropZoneRenderItem = ({
  config,
  item,
  metadata
}) => {
  const Component = config.components[item.type];
  const props = useSlots(config, item, (slotProps) => (0, import_jsx_runtime33.jsx)(SlotRenderPure, __spreadProps(__spreadValues({}, slotProps), { config, metadata })));
  const nextContextValue = (0, import_react30.useMemo)(
    () => ({
      areaId: props.id,
      depth: 1
    }),
    [props]
  );
  const richtextProps = useRichtextProps(Component.fields, props);
  return (0, import_jsx_runtime33.jsx)(DropZoneProvider, { value: nextContextValue, children: (0, import_jsx_runtime33.jsx)(
    Component.render,
    __spreadProps(__spreadValues(__spreadValues({}, props), richtextProps), {
      puck: __spreadProps(__spreadValues({}, props.puck), {
        renderDropZone: DropZoneRenderPure,
        metadata: __spreadValues(__spreadValues({}, metadata), Component.metadata)
      })
    })
  ) }, props.id);
};
var DropZoneRenderPure = (props) => (0, import_jsx_runtime33.jsx)(DropZoneRender, __spreadValues({}, props));
var DropZoneRender = (0, import_react30.forwardRef)(
  function DropZoneRenderInternal({ className, style, zone, as }, ref) {
    const ctx = (0, import_react30.useContext)(dropZoneContext);
    const { areaId = "root" } = ctx || {};
    const { config, data, metadata } = (0, import_react30.useContext)(renderContext);
    let zoneCompound = `${areaId}:${zone}`;
    let content = (data == null ? void 0 : data.content) || [];
    (0, import_react30.useEffect)(() => {
      if (!content) {
        if (ctx == null ? void 0 : ctx.registerZone) {
          ctx == null ? void 0 : ctx.registerZone(zoneCompound);
        }
      }
    }, [content]);
    const El = as != null ? as : "div";
    if (!data || !config) {
      return null;
    }
    if (zoneCompound !== rootDroppableId) {
      content = setupZone(data, zoneCompound).zones[zoneCompound];
    }
    return (0, import_jsx_runtime33.jsx)(El, { className, style, ref, children: content.map((item) => {
      const Component = config.components[item.type];
      if (Component) {
        return (0, import_jsx_runtime33.jsx)(
          DropZoneRenderItem,
          {
            config,
            item,
            metadata
          },
          item.props.id
        );
      }
      return null;
    }) });
  }
);
var DropZonePure = (props) => (0, import_jsx_runtime33.jsx)(DropZone, __spreadValues({}, props));
var DropZone = (0, import_react30.forwardRef)(
  function DropZone2(props, ref) {
    const ctx = (0, import_react30.useContext)(dropZoneContext);
    if ((ctx == null ? void 0 : ctx.mode) === "edit") {
      return (0, import_jsx_runtime33.jsx)(import_jsx_runtime33.Fragment, { children: (0, import_jsx_runtime33.jsx)(DropZoneEdit, __spreadProps(__spreadValues({}, props), { ref })) });
    }
    return (0, import_jsx_runtime33.jsx)(import_jsx_runtime33.Fragment, { children: (0, import_jsx_runtime33.jsx)(DropZoneRender, __spreadProps(__spreadValues({}, props), { ref })) });
  }
);
init_react_import();
init_react_import();
function timeout22(callback, duration) {
  const id = setTimeout(callback, duration);
  return () => clearTimeout(id);
}
function throttle2(func, limit) {
  const time = () => performance.now();
  let cancel;
  let lastRan = 0;
  return function(...args) {
    const now = time();
    const context = this;
    if (now - lastRan >= limit) {
      func.apply(context, args);
      lastRan = now;
    } else {
      cancel == null ? void 0 : cancel();
      cancel = timeout22(() => {
        func.apply(context, args);
        lastRan = time();
      }, limit - (now - lastRan));
    }
  };
}
init_react_import();
var getFrame = () => {
  if (typeof window === "undefined") return;
  let frameEl = document.querySelector("#preview-frame");
  if ((frameEl == null ? void 0 : frameEl.tagName) === "IFRAME") {
    return frameEl.contentDocument || document;
  }
  return (frameEl == null ? void 0 : frameEl.ownerDocument) || document;
};
init_react_import();
var GlobalPosition = class {
  constructor(target, original) {
    this.scaleFactor = 1;
    this.frameEl = null;
    this.frameRect = null;
    var _a5;
    this.target = target;
    this.original = original;
    this.frameEl = document.querySelector("iframe#preview-frame");
    if (this.frameEl) {
      this.frameRect = this.frameEl.getBoundingClientRect();
      this.scaleFactor = this.frameRect.width / (((_a5 = this.frameEl.contentWindow) == null ? void 0 : _a5.innerWidth) || 1);
    }
  }
  get x() {
    return this.original.x;
  }
  get y() {
    return this.original.y;
  }
  get global() {
    if (document !== this.target.ownerDocument && this.frameRect) {
      return {
        x: this.x * this.scaleFactor + this.frameRect.left,
        y: this.y * this.scaleFactor + this.frameRect.top
      };
    }
    return this.original;
  }
  get frame() {
    if (document === this.target.ownerDocument && this.frameRect) {
      return {
        x: (this.x - this.frameRect.left) / this.scaleFactor,
        y: (this.y - this.frameRect.top) / this.scaleFactor
      };
    }
    return this.original;
  }
};
init_react_import();
var BaseEvent = typeof PointerEvent !== "undefined" ? PointerEvent : Event;
var BubbledPointerEvent = class extends BaseEvent {
  constructor(type, data) {
    super(type, data);
    this._originalTarget = null;
    this.originalTarget = data.originalTarget;
  }
  // Necessary for Firefox
  set originalTarget(target) {
    this._originalTarget = target;
  }
  // Necessary for Firefox
  get originalTarget() {
    return this._originalTarget;
  }
};
var depthSort = (candidates) => {
  return candidates.sort((a2, b2) => {
    const aData = a2.data;
    const bData = b2.data;
    if (aData.depth > bData.depth) {
      return 1;
    }
    if (bData.depth > aData.depth) {
      return -1;
    }
    return 0;
  });
};
var getZoneId2 = (candidate) => {
  let id = candidate == null ? void 0 : candidate.id;
  if (!candidate) return null;
  if (candidate.type === "component") {
    const data = candidate.data;
    if (data.containsActiveZone) {
      id = null;
    } else {
      id = data.zone;
    }
  } else if (candidate.type === "void") {
    return "void";
  }
  return id;
};
var BUFFER = 6;
var getPointerCollisions = (position, manager) => {
  const candidates = [];
  let elements = position.target.ownerDocument.elementsFromPoint(
    position.x,
    position.y
  );
  const previewFrame = elements.find(
    (el) => el.getAttribute("data-puck-preview")
  );
  const drawer = elements.find((el) => el.getAttribute("data-puck-drawer"));
  if (drawer) {
    elements = [drawer];
  }
  if (previewFrame) {
    const frame = getFrame();
    if (frame) {
      elements = frame.elementsFromPoint(position.frame.x, position.frame.y);
    }
  }
  if (elements) {
    for (let i2 = 0; i2 < elements.length; i2++) {
      const element = elements[i2];
      const dropzoneId = element.getAttribute("data-puck-dropzone");
      const id = element.getAttribute("data-puck-dnd");
      const isVoid = element.hasAttribute("data-puck-dnd-void");
      if (BUFFER && (dropzoneId || id) && !isVoid) {
        const box = element.getBoundingClientRect();
        const contractedBox = {
          left: box.left + BUFFER,
          right: box.right - BUFFER,
          top: box.top + BUFFER,
          bottom: box.bottom - BUFFER
        };
        if (position.frame.x < contractedBox.left || position.frame.x > contractedBox.right || position.frame.y > contractedBox.bottom || position.frame.y < contractedBox.top) {
          continue;
        }
      }
      if (dropzoneId) {
        const droppable = manager.registry.droppables.get(dropzoneId);
        if (droppable) {
          candidates.push(droppable);
        }
      }
      if (id) {
        const droppable = manager.registry.droppables.get(id);
        if (droppable) {
          candidates.push(droppable);
        }
      }
    }
  }
  return candidates;
};
var findDeepestCandidate = (position, manager) => {
  var _a5;
  const candidates = getPointerCollisions(position, manager);
  if (candidates.length > 0) {
    const sortedCandidates = depthSort(candidates);
    const draggable = manager.dragOperation.source;
    const draggedCandidateIndex = sortedCandidates.findIndex(
      (candidate) => candidate.id === (draggable == null ? void 0 : draggable.id)
    );
    const draggedCandidateId = draggable == null ? void 0 : draggable.id;
    let filteredCandidates = [...sortedCandidates];
    if (draggedCandidateId && draggedCandidateIndex > -1) {
      filteredCandidates.splice(draggedCandidateIndex, 1);
    }
    filteredCandidates = filteredCandidates.filter((candidate) => {
      const candidateData = candidate.data;
      if (draggedCandidateId && draggedCandidateIndex > -1) {
        if (candidateData.path.indexOf(draggedCandidateId) > -1) {
          return false;
        }
      }
      if (candidate.type === "dropzone") {
        const candidateData2 = candidate.data;
        if (!candidateData2.isDroppableTarget) {
          return false;
        }
        if (candidateData2.areaId === draggedCandidateId) {
          return false;
        }
      } else if (candidate.type === "component") {
        const candidateData2 = candidate.data;
        if (!candidateData2.inDroppableZone) {
          return false;
        }
      }
      return true;
    });
    filteredCandidates.reverse();
    const primaryCandidate = filteredCandidates[0];
    if (!primaryCandidate) return { zone: null, area: null };
    const primaryCandidateData = primaryCandidate.data;
    const primaryCandidateIsComponent = "containsActiveZone" in primaryCandidateData;
    const zone = getZoneId2(primaryCandidate);
    const area = primaryCandidateIsComponent && primaryCandidateData.containsActiveZone ? filteredCandidates[0].id : (_a5 = filteredCandidates[0]) == null ? void 0 : _a5.data.areaId;
    return { zone, area };
  }
  return {
    zone: rootDroppableId,
    area: rootAreaId
  };
};
var createNestedDroppablePlugin = ({ onChange }, id) => class NestedDroppablePlugin extends Plugin {
  constructor(manager, options2) {
    super(manager);
    if (typeof window === "undefined") {
      return;
    }
    this.registerEffect(() => {
      const handleMove = (event) => {
        const target = event instanceof BubbledPointerEvent ? event.originalTarget || event.target : event.target;
        const position = new GlobalPosition(target, {
          x: event.clientX,
          y: event.clientY
        });
        const elements = document.elementsFromPoint(
          position.global.x,
          position.global.y
        );
        const overEl = elements.some((el) => el.id === id);
        if (overEl) {
          onChange(findDeepestCandidate(position, manager), manager);
        }
      };
      const handleMoveThrottled = throttle2(handleMove, 50);
      const handlePointerMove = (event) => {
        handleMoveThrottled(event);
      };
      document.body.addEventListener("pointermove", handlePointerMove, {
        capture: true
        // dndkit's PointerSensor prevents propagation during drag
      });
      const cleanup = () => {
        document.body.removeEventListener("pointermove", handlePointerMove, {
          capture: true
        });
      };
      return cleanup;
    });
  }
};
init_react_import();
var insertComponent = (componentType, zone, index, appStore) => __async(null, null, function* () {
  const { getState } = appStore;
  const id = generateId(componentType);
  const insertActionData = {
    type: "insert",
    componentType,
    destinationIndex: index,
    destinationZone: zone,
    id
  };
  const stateBefore = getState().state;
  const insertedState = insertAction(stateBefore, insertActionData, getState());
  const dispatch = getState().dispatch;
  dispatch(__spreadProps(__spreadValues({}, insertActionData), {
    // Dispatch insert rather set, as user's may rely on this via onAction
    // We must always record history here so the insert is added to user history
    // If the user has defined a resolveData method, they will end up with 2 history
    // entries on insert - one for the initial insert, and one when the data resolves
    recordHistory: true
  }));
  const itemSelector = { index, zone };
  dispatch({ type: "setUi", ui: { itemSelector } });
  const itemData = getItem(itemSelector, insertedState);
  if (!itemData) return;
  const resolveComponentData2 = getState().resolveComponentData;
  const resolved = yield resolveComponentData2(itemData, "insert");
  if (!resolved.didChange) return;
  const latestItemSelector = getSelectorForId(getState().state, id);
  if (!latestItemSelector) return;
  dispatch({
    type: "replace",
    destinationZone: latestItemSelector.zone,
    destinationIndex: latestItemSelector.index,
    data: resolved.node
  });
});
init_react_import();
var moveComponent = (id, sourceSelector, destinationSelector, appStore) => __async(null, null, function* () {
  var _a5, _b3, _c4, _d2;
  const dispatch = appStore.getState().dispatch;
  dispatch({
    type: "move",
    sourceIndex: sourceSelector.index,
    sourceZone: (_a5 = sourceSelector.zone) != null ? _a5 : rootDroppableId,
    destinationIndex: destinationSelector.index,
    destinationZone: (_b3 = destinationSelector.zone) != null ? _b3 : rootDroppableId,
    recordHistory: false
  });
  const componentData = (_c4 = appStore.getState().state.indexes.nodes[id]) == null ? void 0 : _c4.data;
  if (!componentData) return;
  const resolveComponentData2 = appStore.getState().resolveComponentData;
  const resolvedData = yield resolveComponentData2(componentData, "move");
  const latestItemSelector = getSelectorForId(
    appStore.getState().state,
    componentData.props.id
  );
  if (!latestItemSelector) return;
  if (resolvedData.didChange)
    dispatch({
      type: "replace",
      data: resolvedData.node,
      destinationIndex: latestItemSelector.index,
      destinationZone: (_d2 = latestItemSelector.zone) != null ? _d2 : rootDroppableId
    });
});
init_react_import();
function getDeepDir(el) {
  function findDir(node) {
    if (!node) return "ltr";
    const d2 = node.getAttribute("dir");
    return d2 || findDir(node.parentElement);
  }
  return el ? findDir(el) : "ltr";
}
var DEBUG3 = false;
var dragListenerContext = (0, import_react29.createContext)({
  dragListeners: {}
});
function useDragListener(type, fn, deps = []) {
  const { setDragListeners } = (0, import_react29.useContext)(dragListenerContext);
  (0, import_react29.useEffect)(() => {
    if (setDragListeners) {
      setDragListeners((old) => __spreadProps(__spreadValues({}, old), {
        [type]: [...old[type] || [], fn]
      }));
    }
  }, deps);
}
var AREA_CHANGE_DEBOUNCE_MS = 100;
var useTempDisableFallback = (timeout3) => {
  const lastFallbackDisable = (0, import_react29.useRef)(null);
  return (0, import_react29.useCallback)((manager) => {
    collisionStore.setState({ fallbackEnabled: false });
    const fallbackId = generateId();
    lastFallbackDisable.current = fallbackId;
    setTimeout(() => {
      if (lastFallbackDisable.current === fallbackId) {
        collisionStore.setState({ fallbackEnabled: true });
        manager.collisionObserver.forceUpdate(true);
      }
    }, timeout3);
  }, []);
};
var DragDropContextClient = ({
  children,
  disableAutoScroll
}) => {
  const dispatch = useAppStore((s2) => s2.dispatch);
  const instanceId = useAppStore((s2) => s2.instanceId);
  const appStore = useAppStoreApi();
  const debouncedParamsRef = (0, import_react29.useRef)(null);
  const tempDisableFallback = useTempDisableFallback(100);
  const [zoneStore] = (0, import_react29.useState)(
    () => createStore(() => ({
      zoneDepthIndex: {},
      nextZoneDepthIndex: {},
      areaDepthIndex: {},
      nextAreaDepthIndex: {},
      draggedItem: null,
      previewIndex: {},
      enabledIndex: {},
      hoveringComponent: null
    }))
  );
  const getChanged = (0, import_react29.useCallback)(
    (params) => {
      const { zoneDepthIndex = {}, areaDepthIndex = {} } = zoneStore.getState() || {};
      const stateHasZone = Object.keys(zoneDepthIndex).length > 0;
      const stateHasArea = Object.keys(areaDepthIndex).length > 0;
      let zoneChanged = false;
      let areaChanged = false;
      if (params.zone && !zoneDepthIndex[params.zone]) {
        zoneChanged = true;
      } else if (!params.zone && stateHasZone) {
        zoneChanged = true;
      }
      if (params.area && !areaDepthIndex[params.area]) {
        areaChanged = true;
      } else if (!params.area && stateHasArea) {
        areaChanged = true;
      }
      return { zoneChanged, areaChanged };
    },
    [zoneStore]
  );
  const setDeepestAndCollide = (0, import_react29.useCallback)(
    (params, manager) => {
      const { zoneChanged, areaChanged } = getChanged(params);
      if (!zoneChanged && !areaChanged) return;
      zoneStore.setState({
        zoneDepthIndex: params.zone ? { [params.zone]: true } : {},
        areaDepthIndex: params.area ? { [params.area]: true } : {}
      });
      tempDisableFallback(manager);
      setTimeout(() => {
        manager.collisionObserver.forceUpdate(true);
      }, 50);
      debouncedParamsRef.current = null;
    },
    [zoneStore]
  );
  const setDeepestDb = c(
    setDeepestAndCollide,
    AREA_CHANGE_DEBOUNCE_MS
  );
  const cancelDb = () => {
    setDeepestDb.cancel();
    debouncedParamsRef.current = null;
  };
  (0, import_react29.useEffect)(() => {
    if (DEBUG3) {
      zoneStore.subscribe(
        (s2) => {
          var _a5, _b3;
          return console.log(
            s2.previewIndex,
            (_a5 = Object.entries(s2.zoneDepthIndex || {})[0]) == null ? void 0 : _a5[0],
            (_b3 = Object.entries(s2.areaDepthIndex || {})[0]) == null ? void 0 : _b3[0]
          );
        }
      );
    }
  }, []);
  const [plugins] = (0, import_react29.useState)(() => [
    ...disableAutoScroll ? defaultPreset.plugins.filter((plugin) => plugin !== AutoScroller) : defaultPreset.plugins,
    createNestedDroppablePlugin(
      {
        onChange: (params, manager) => {
          const state = zoneStore.getState();
          const { zoneChanged, areaChanged } = getChanged(params);
          const isDragging = manager.dragOperation.status.dragging;
          if (areaChanged || zoneChanged) {
            let nextZoneDepthIndex = {};
            let nextAreaDepthIndex = {};
            if (params.zone) {
              nextZoneDepthIndex = { [params.zone]: true };
            }
            if (params.area) {
              nextAreaDepthIndex = { [params.area]: true };
            }
            zoneStore.setState({ nextZoneDepthIndex, nextAreaDepthIndex });
          }
          if (params.zone !== "void" && (state == null ? void 0 : state.zoneDepthIndex["void"])) {
            setDeepestAndCollide(params, manager);
            return;
          }
          if (areaChanged) {
            if (isDragging) {
              const debouncedParams = debouncedParamsRef.current;
              const isSameParams = debouncedParams && debouncedParams.area === params.area && debouncedParams.zone === params.zone;
              if (!isSameParams) {
                cancelDb();
                setDeepestDb(params, manager);
                debouncedParamsRef.current = params;
              }
            } else {
              cancelDb();
              setDeepestAndCollide(params, manager);
            }
            return;
          }
          if (zoneChanged) {
            setDeepestAndCollide(params, manager);
          }
          cancelDb();
        }
      },
      instanceId
    )
  ]);
  const sensors = useSensors();
  const [dragListeners, setDragListeners] = (0, import_react29.useState)({});
  const dragMode = (0, import_react29.useRef)(null);
  const initialSelector = (0, import_react29.useRef)(void 0);
  const nextContextValue = (0, import_react29.useMemo)(
    () => ({
      mode: "edit",
      areaId: "root",
      depth: 0
    }),
    []
  );
  return (0, import_jsx_runtime34.jsx)(
    dragListenerContext.Provider,
    {
      value: {
        dragListeners,
        setDragListeners
      },
      children: (0, import_jsx_runtime34.jsx)(
        DragDropProvider,
        {
          plugins,
          sensors,
          onDragEnd: (event, manager) => {
            var _a5, _b3;
            const entryEl = (_a5 = getFrame()) == null ? void 0 : _a5.querySelector("[data-puck-entry]");
            entryEl == null ? void 0 : entryEl.removeAttribute("data-puck-dragging");
            const { source, target } = event.operation;
            if (!source) {
              zoneStore.setState({ draggedItem: null });
              return;
            }
            const { zone, index } = source.data;
            const { previewIndex = {} } = zoneStore.getState() || {};
            const thisPreview = ((_b3 = previewIndex[zone]) == null ? void 0 : _b3.props.id) === source.id ? previewIndex[zone] : null;
            const onAnimationEnd = () => {
              var _a23, _b22;
              zoneStore.setState({ draggedItem: null });
              if (event.canceled || (target == null ? void 0 : target.type) === "void") {
                zoneStore.setState({ previewIndex: {} });
                if (thisPreview) {
                  zoneStore.setState({ previewIndex: {} });
                  if (thisPreview.type === "insert") {
                    insertComponent(
                      thisPreview.componentType,
                      thisPreview.zone,
                      thisPreview.index,
                      appStore
                    );
                  } else if (initialSelector.current) {
                    moveComponent(
                      thisPreview.props.id,
                      initialSelector.current,
                      thisPreview,
                      appStore
                    );
                  }
                }
                dispatch({
                  type: "setUi",
                  ui: {
                    itemSelector: null,
                    isDragging: false
                  }
                });
                (_a23 = dragListeners.dragend) == null ? void 0 : _a23.forEach((fn) => {
                  fn(event, manager);
                });
                return;
              }
              if (thisPreview) {
                zoneStore.setState({ previewIndex: {} });
                if (thisPreview.type === "insert") {
                  insertComponent(
                    thisPreview.componentType,
                    thisPreview.zone,
                    thisPreview.index,
                    appStore
                  );
                } else if (initialSelector.current) {
                  dispatch({
                    type: "move",
                    sourceIndex: initialSelector.current.index,
                    sourceZone: initialSelector.current.zone,
                    destinationIndex: thisPreview.index,
                    destinationZone: thisPreview.zone,
                    recordHistory: false
                  });
                }
              }
              dispatch({
                type: "setUi",
                ui: {
                  itemSelector: { index, zone },
                  isDragging: false
                },
                recordHistory: true
              });
              (_b22 = dragListeners.dragend) == null ? void 0 : _b22.forEach((fn) => {
                fn(event, manager);
              });
            };
            let dispose;
            dispose = m(() => {
              if (source.status === "idle") {
                onAnimationEnd();
                dispose == null ? void 0 : dispose();
              }
            });
          },
          onDragOver: (event, manager) => {
            var _a5, _b3, _c4, _d2;
            event.preventDefault();
            const draggedItem = (_a5 = zoneStore.getState()) == null ? void 0 : _a5.draggedItem;
            if (!draggedItem) return;
            cancelDb();
            const { source, target } = event.operation;
            if (!target || !source || target.type === "void") return;
            const [sourceId] = source.id.split(":");
            const [targetId] = target.id.split(":");
            const sourceData = source.data;
            let sourceZone = sourceData.zone;
            let sourceIndex = sourceData.index;
            let targetZone = "";
            let targetIndex = 0;
            if (target.type === "component") {
              const targetData = target.data;
              targetZone = targetData.zone;
              targetIndex = targetData.index;
              const collisionData = (_b3 = manager.collisionObserver.collisions[0]) == null ? void 0 : _b3.data;
              const dir = getDeepDir(target.element);
              const collisionPosition = (collisionData == null ? void 0 : collisionData.direction) === "up" || dir === "ltr" && (collisionData == null ? void 0 : collisionData.direction) === "left" || dir === "rtl" && (collisionData == null ? void 0 : collisionData.direction) === "right" ? "before" : "after";
              if (targetIndex >= sourceIndex && sourceZone === targetZone) {
                targetIndex = targetIndex - 1;
              }
              if (collisionPosition === "after") {
                targetIndex = targetIndex + 1;
              }
            } else {
              targetZone = target.id.toString();
              targetIndex = 0;
            }
            const path = ((_c4 = appStore.getState().state.indexes.nodes[target.id]) == null ? void 0 : _c4.path) || [];
            if (targetId === sourceId || path.find((path2) => {
              const [pathId] = path2.split(":");
              return pathId === sourceId;
            })) {
              return;
            }
            if (dragMode.current === "new") {
              zoneStore.setState({
                previewIndex: {
                  [targetZone]: {
                    componentType: sourceData.componentType,
                    type: "insert",
                    index: targetIndex,
                    zone: targetZone,
                    element: source.element,
                    props: {
                      id: source.id.toString()
                    }
                  }
                }
              });
            } else {
              if (!initialSelector.current) {
                initialSelector.current = {
                  zone: sourceData.zone,
                  index: sourceData.index
                };
              }
              const item = getItem(
                initialSelector.current,
                appStore.getState().state
              );
              if (item) {
                zoneStore.setState({
                  previewIndex: {
                    [targetZone]: {
                      componentType: sourceData.componentType,
                      type: "move",
                      index: targetIndex,
                      zone: targetZone,
                      props: item.props,
                      element: source.element
                    }
                  }
                });
              }
            }
            (_d2 = dragListeners.dragover) == null ? void 0 : _d2.forEach((fn) => {
              fn(event, manager);
            });
          },
          onDragStart: (event, manager) => {
            var _a5;
            const { source } = event.operation;
            if (source && source.type !== "void") {
              const sourceData = source.data;
              const item = getItem(
                {
                  zone: sourceData.zone,
                  index: sourceData.index
                },
                appStore.getState().state
              );
              if (item) {
                zoneStore.setState({
                  previewIndex: {
                    [sourceData.zone]: {
                      componentType: sourceData.componentType,
                      type: "move",
                      index: sourceData.index,
                      zone: sourceData.zone,
                      props: item.props,
                      element: source.element
                    }
                  }
                });
              }
            }
            (_a5 = dragListeners.dragstart) == null ? void 0 : _a5.forEach((fn) => {
              fn(event, manager);
            });
          },
          onBeforeDragStart: (event) => {
            var _a5, _b3, _c4, _d2;
            const isNewComponent = ((_a5 = event.operation.source) == null ? void 0 : _a5.type) === "drawer";
            dragMode.current = isNewComponent ? "new" : "existing";
            initialSelector.current = void 0;
            zoneStore.setState({ draggedItem: event.operation.source });
            if (((_b3 = appStore.getState().selectedItem) == null ? void 0 : _b3.props.id) !== ((_c4 = event.operation.source) == null ? void 0 : _c4.id)) {
              dispatch({
                type: "setUi",
                ui: {
                  itemSelector: null,
                  isDragging: true
                },
                recordHistory: false
              });
            } else {
              dispatch({
                type: "setUi",
                ui: {
                  isDragging: true
                },
                recordHistory: false
              });
            }
            const entryEl = (_d2 = getFrame()) == null ? void 0 : _d2.querySelector("[data-puck-entry]");
            entryEl == null ? void 0 : entryEl.setAttribute("data-puck-dragging", "true");
          },
          children: (0, import_jsx_runtime34.jsx)(ZoneStoreProvider, { store: zoneStore, children: (0, import_jsx_runtime34.jsx)(DropZoneProvider, { value: nextContextValue, children }) })
        }
      )
    }
  );
};
var DragDropContext2 = ({
  children,
  disableAutoScroll
}) => {
  const status = useAppStore((s2) => s2.status);
  if (status === "LOADING") {
    return children;
  }
  return (0, import_jsx_runtime34.jsx)(DragDropContextClient, { disableAutoScroll, children });
};
var getClassName17 = get_class_name_factory_default("Drawer", styles_module_default8);
var getClassNameItem2 = get_class_name_factory_default("DrawerItem", styles_module_default8);
var DrawerItemInner = ({
  children,
  name,
  label,
  dragRef,
  isDragDisabled
}) => {
  const CustomInner = (0, import_react27.useMemo)(
    () => children || (({ children: children2 }) => (0, import_jsx_runtime35.jsx)("div", { className: getClassNameItem2("default"), children: children2 })),
    [children]
  );
  return (0, import_jsx_runtime35.jsx)(
    "div",
    {
      className: getClassNameItem2({ disabled: isDragDisabled }),
      ref: dragRef,
      onMouseDown: (e2) => e2.preventDefault(),
      "data-testid": dragRef ? `drawer-item:${name}` : "",
      "data-puck-drawer-item": true,
      children: (0, import_jsx_runtime35.jsx)(CustomInner, { name, children: (0, import_jsx_runtime35.jsx)("div", { className: getClassNameItem2("draggableWrapper"), children: (0, import_jsx_runtime35.jsxs)("div", { className: getClassNameItem2("draggable"), children: [
        (0, import_jsx_runtime35.jsx)("div", { className: getClassNameItem2("name"), children: label != null ? label : name }),
        (0, import_jsx_runtime35.jsx)("div", { className: getClassNameItem2("icon"), children: (0, import_jsx_runtime35.jsx)(DragIcon, {}) })
      ] }) }) })
    }
  );
};
var DrawerItemDraggable = ({
  children,
  name,
  label,
  id,
  isDragDisabled
}) => {
  const { ref } = useDraggable({
    id,
    data: { componentType: name },
    disabled: isDragDisabled,
    type: "drawer"
  });
  return (0, import_jsx_runtime35.jsxs)("div", { className: getClassName17("draggable"), children: [
    (0, import_jsx_runtime35.jsx)("div", { className: getClassName17("draggableBg"), children: (0, import_jsx_runtime35.jsx)(DrawerItemInner, { name, label, children }) }),
    (0, import_jsx_runtime35.jsx)("div", { className: getClassName17("draggableFg"), children: (0, import_jsx_runtime35.jsx)(
      DrawerItemInner,
      {
        name,
        label,
        dragRef: ref,
        isDragDisabled,
        children
      }
    ) })
  ] });
};
var DrawerItem = ({
  name,
  children,
  id,
  label,
  index,
  isDragDisabled
}) => {
  const resolvedId = id || name;
  const [dynamicId, setDynamicId] = (0, import_react27.useState)(generateId(resolvedId));
  if (typeof index !== "undefined") {
    console.error(
      "Warning: The `index` prop on Drawer.Item is deprecated and no longer required."
    );
  }
  useDragListener(
    "dragend",
    () => {
      setDynamicId(generateId(resolvedId));
    },
    [resolvedId]
  );
  return (0, import_jsx_runtime35.jsx)("div", { children: (0, import_jsx_runtime35.jsx)(
    DrawerItemDraggable,
    {
      name,
      label,
      id: dynamicId,
      isDragDisabled,
      children
    }
  ) }, dynamicId);
};
var Drawer = ({
  children,
  droppableId,
  direction
}) => {
  if (droppableId) {
    console.error(
      "Warning: The `droppableId` prop on Drawer is deprecated and no longer required."
    );
  }
  if (direction) {
    console.error(
      "Warning: The `direction` prop on Drawer is deprecated and no longer required to achieve multi-directional dragging."
    );
  }
  const id = useSafeId();
  const { ref } = useDroppable({
    id,
    type: "void",
    collisionPriority: 0
    // Never collide with this, but we use it so NestedDroppablePlugin respects the Drawer
  });
  return (0, import_jsx_runtime35.jsx)(
    "div",
    {
      className: getClassName17(),
      ref,
      "data-puck-dnd": id,
      "data-puck-drawer": true,
      "data-puck-dnd-void": true,
      children
    }
  );
};
Drawer.Item = DrawerItem;
init_react_import();
init_react_import();
init_react_import();
var styles_module_default12 = { "PuckFields": "_PuckFields_10bh7_1", "PuckFields--isLoading": "_PuckFields--isLoading_10bh7_6", "PuckFields-loadingOverlay": "_PuckFields-loadingOverlay_10bh7_10", "PuckFields-loadingOverlayInner": "_PuckFields-loadingOverlayInner_10bh7_25", "PuckFields-field": "_PuckFields-field_10bh7_32", "PuckFields--wrapFields": "_PuckFields--wrapFields_10bh7_36" };
var getClassName18 = get_class_name_factory_default("PuckFields", styles_module_default12);
var DefaultFields = ({
  children
}) => {
  return (0, import_jsx_runtime36.jsx)(import_jsx_runtime36.Fragment, { children });
};
var createOnChange = (fieldName, appStore) => (value, updatedUi) => __async(null, null, function* () {
  const { dispatch, state, selectedItem, resolveComponentData: resolveComponentData2 } = appStore.getState();
  const { data, ui } = state;
  const { itemSelector } = ui;
  const rootProps = data.root.props || data.root;
  const currentProps = selectedItem ? selectedItem.props : rootProps;
  const newProps = __spreadProps(__spreadValues({}, currentProps), { [fieldName]: value });
  if (selectedItem && itemSelector) {
    const resolved = yield resolveComponentData2(
      __spreadProps(__spreadValues({}, selectedItem), { props: newProps }),
      "replace"
    );
    const latestSelector = getSelectorForId(
      appStore.getState().state,
      selectedItem.props.id
    );
    if (!latestSelector) return;
    dispatch({
      type: "replace",
      destinationIndex: latestSelector.index,
      destinationZone: latestSelector.zone || rootDroppableId,
      data: resolved.node,
      ui: updatedUi
    });
    return;
  }
  if (data.root.props) {
    dispatch({
      type: "replaceRoot",
      root: (yield resolveComponentData2(
        __spreadProps(__spreadValues({}, data.root), { props: newProps }),
        "replace"
      )).node,
      ui: __spreadValues(__spreadValues({}, ui), updatedUi),
      recordHistory: true
    });
    return;
  }
  dispatch({
    type: "setData",
    data: { root: newProps }
  });
});
var FieldsChildInner = ({ fieldName }) => {
  const field = useAppStore((s2) => s2.fields.fields[fieldName]);
  const isReadOnly = useAppStore(
    (s2) => ((s2.selectedItem ? s2.selectedItem.readOnly : s2.state.data.root.readOnly) || {})[fieldName]
  );
  const id = useAppStore((s2) => {
    if (!field) return null;
    return s2.selectedItem ? `${s2.selectedItem.props.id}_${field.type}_${fieldName}` : `root_${field.type}_${fieldName}`;
  });
  const permissions = useAppStore(
    useShallow((s2) => {
      const { selectedItem, permissions: permissions2 } = s2;
      return selectedItem ? permissions2.getPermissions({ item: selectedItem }) : permissions2.getPermissions({ root: true });
    })
  );
  const appStore = useAppStoreApi();
  const onChange = (0, import_react47.useCallback)(createOnChange(fieldName, appStore), [
    fieldName
  ]);
  const { visible = true } = field != null ? field : {};
  const fieldStore = (0, import_react47.useContext)(fieldContextStore.ctx);
  (0, import_react47.useEffect)(() => {
    return appStore.subscribe(
      (s2) => {
        var _a5;
        const data = s2.getCurrentData();
        return (_a5 = data.props) == null ? void 0 : _a5[fieldName];
      },
      (value) => {
        fieldStore.setState({ [fieldName]: value });
      }
    );
  }, [appStore, fieldStore]);
  if (!field || !id || !visible) return null;
  if (field.type === "slot") return null;
  return (0, import_jsx_runtime36.jsx)("div", { className: getClassName18("field"), children: (0, import_jsx_runtime36.jsx)(
    AutoFieldPrivate,
    {
      field,
      name: fieldName,
      id,
      readOnly: !permissions.edit || isReadOnly,
      onChange
    }
  ) }, id);
};
var FieldsChild = ({ fieldName }) => {
  const appStore = useAppStoreApi();
  const initialValue = (0, import_react47.useMemo)(() => {
    var _a5;
    const value = (_a5 = appStore.getState().getCurrentData().props) == null ? void 0 : _a5[fieldName];
    return { [fieldName]: value };
  }, []);
  return (0, import_jsx_runtime36.jsx)(fieldContextStore.Provider, { value: initialValue, children: (0, import_jsx_runtime36.jsx)(FieldsChildInner, { fieldName }) });
};
var FieldsChildMemo = (0, import_react47.memo)(FieldsChild);
var FieldsInternal = ({ wrapFields = true }) => {
  const overrides = useAppStore((s2) => s2.overrides);
  const componentResolving = useAppStore((s2) => {
    var _a5, _b3;
    const loadingCount = s2.selectedItem ? (_a5 = s2.componentState[s2.selectedItem.props.id]) == null ? void 0 : _a5.loadingCount : (_b3 = s2.componentState["root"]) == null ? void 0 : _b3.loadingCount;
    return (loadingCount != null ? loadingCount : 0) > 0;
  });
  const itemSelector = useAppStore(useShallow((s2) => s2.state.ui.itemSelector));
  const id = useAppStore((s2) => {
    var _a5;
    return (_a5 = s2.selectedItem) == null ? void 0 : _a5.props.id;
  });
  const appStore = useAppStoreApi();
  useRegisterFieldsSlice(appStore, id);
  const fieldsLoading = useAppStore((s2) => s2.fields.loading);
  const fieldNames = useAppStore(
    useShallow((s2) => {
      if (s2.fields.id === id) {
        return Object.keys(s2.fields.fields);
      }
      return [];
    })
  );
  const isLoading = fieldsLoading || componentResolving;
  const Wrapper = (0, import_react47.useMemo)(() => overrides.fields || DefaultFields, [overrides]);
  return (0, import_jsx_runtime36.jsxs)(
    "form",
    {
      className: getClassName18({ wrapFields }),
      onSubmit: (e2) => {
        e2.preventDefault();
      },
      children: [
        (0, import_jsx_runtime36.jsx)(Wrapper, { isLoading, itemSelector, children: fieldNames.map((fieldName) => (0, import_jsx_runtime36.jsx)(FieldsChildMemo, { fieldName }, fieldName)) }),
        isLoading && (0, import_jsx_runtime36.jsx)("div", { className: getClassName18("loadingOverlay"), children: (0, import_jsx_runtime36.jsx)("div", { className: getClassName18("loadingOverlayInner"), children: (0, import_jsx_runtime36.jsx)(Loader, { size: 16 }) }) })
      ]
    }
  );
};
var Fields = (0, import_react47.memo)(FieldsInternal);
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var styles_module_default13 = { "ComponentList": "_ComponentList_1rrlt_1", "ComponentList--isExpanded": "_ComponentList--isExpanded_1rrlt_5", "ComponentList-content": "_ComponentList-content_1rrlt_9", "ComponentList-title": "_ComponentList-title_1rrlt_17", "ComponentList-titleIcon": "_ComponentList-titleIcon_1rrlt_53" };
var getClassName19 = get_class_name_factory_default("ComponentList", styles_module_default13);
var ComponentListItem = ({
  name,
  label
}) => {
  var _a5;
  const overrides = useAppStore((s2) => s2.overrides);
  const canInsert = useAppStore(
    (s2) => s2.permissions.getPermissions({
      type: name
    }).insert
  );
  (0, import_react49.useEffect)(() => {
    if (overrides.componentItem) {
      console.warn(
        "The `componentItem` override has been deprecated and renamed to `drawerItem`"
      );
    }
  }, [overrides]);
  return (0, import_jsx_runtime37.jsx)(Drawer.Item, { label, name, isDragDisabled: !canInsert, children: (_a5 = overrides.componentItem) != null ? _a5 : overrides.drawerItem });
};
var ComponentList = ({
  children,
  title,
  id
}) => {
  const config = useAppStore((s2) => s2.config);
  const setUi = useAppStore((s2) => s2.setUi);
  const componentList = useAppStore((s2) => s2.state.ui.componentList);
  const { expanded = true } = componentList[id] || {};
  return (0, import_jsx_runtime37.jsxs)("div", { className: getClassName19({ isExpanded: expanded }), children: [
    title && (0, import_jsx_runtime37.jsxs)(
      "button",
      {
        type: "button",
        className: getClassName19("title"),
        onClick: () => setUi({
          componentList: __spreadProps(__spreadValues({}, componentList), {
            [id]: __spreadProps(__spreadValues({}, componentList[id]), {
              expanded: !expanded
            })
          })
        }),
        title: expanded ? `Collapse${title ? ` ${title}` : ""}` : `Expand${title ? ` ${title}` : ""}`,
        children: [
          (0, import_jsx_runtime37.jsx)("div", { children: title }),
          (0, import_jsx_runtime37.jsx)("div", { className: getClassName19("titleIcon"), children: expanded ? (0, import_jsx_runtime37.jsx)(ChevronUp, { size: 12 }) : (0, import_jsx_runtime37.jsx)(ChevronDown, { size: 12 }) })
        ]
      }
    ),
    (0, import_jsx_runtime37.jsx)("div", { className: getClassName19("content"), children: (0, import_jsx_runtime37.jsx)(Drawer, { children: children || Object.keys(config.components).map((componentKey) => {
      var _a5;
      return (0, import_jsx_runtime37.jsx)(
        ComponentListItem,
        {
          label: (_a5 = config.components[componentKey]["label"]) != null ? _a5 : componentKey,
          name: componentKey
        },
        componentKey
      );
    }) }) })
  ] });
};
ComponentList.Item = ComponentListItem;
var useComponentList = () => {
  const [componentList, setComponentList] = (0, import_react48.useState)();
  const config = useAppStore((s2) => s2.config);
  const uiComponentList = useAppStore((s2) => s2.state.ui.componentList);
  (0, import_react48.useEffect)(() => {
    var _a5, _b3, _c4;
    if (Object.keys(uiComponentList).length > 0) {
      const matchedComponents = [];
      let _componentList;
      _componentList = Object.entries(uiComponentList).map(
        ([categoryKey, category]) => {
          if (!category.components) {
            return null;
          }
          category.components.forEach((componentName) => {
            matchedComponents.push(componentName);
          });
          if (category.visible === false) {
            return null;
          }
          return (0, import_jsx_runtime38.jsx)(
            ComponentList,
            {
              id: categoryKey,
              title: category.title || categoryKey,
              children: category.components.map((componentName, i2) => {
                var _a23;
                const componentConf = config.components[componentName] || {};
                return (0, import_jsx_runtime38.jsx)(
                  ComponentList.Item,
                  {
                    label: (_a23 = componentConf["label"]) != null ? _a23 : componentName,
                    name: componentName,
                    index: i2
                  },
                  componentName
                );
              })
            },
            categoryKey
          );
        }
      );
      const remainingComponents = Object.keys(config.components).filter(
        (component) => matchedComponents.indexOf(component) === -1
      );
      if (remainingComponents.length > 0 && !((_a5 = uiComponentList.other) == null ? void 0 : _a5.components) && ((_b3 = uiComponentList.other) == null ? void 0 : _b3.visible) !== false) {
        _componentList.push(
          (0, import_jsx_runtime38.jsx)(
            ComponentList,
            {
              id: "other",
              title: ((_c4 = uiComponentList.other) == null ? void 0 : _c4.title) || "Other",
              children: remainingComponents.map((componentName, i2) => {
                var _a23;
                const componentConf = config.components[componentName] || {};
                return (0, import_jsx_runtime38.jsx)(
                  ComponentList.Item,
                  {
                    name: componentName,
                    label: (_a23 = componentConf["label"]) != null ? _a23 : componentName,
                    index: i2
                  },
                  componentName
                );
              })
            },
            "other"
          )
        );
      }
      setComponentList(_componentList);
    }
  }, [config.categories, config.components, uiComponentList]);
  return componentList;
};
var Components = () => {
  const overrides = useAppStore((s2) => s2.overrides);
  const componentList = useComponentList();
  const Wrapper = (0, import_react50.useMemo)(() => {
    if (overrides.components) {
      console.warn(
        "The `components` override has been deprecated and renamed to `drawer`"
      );
    }
    return overrides.components || overrides.drawer || "div";
  }, [overrides]);
  return (0, import_jsx_runtime39.jsx)(Wrapper, { children: componentList ? componentList : (0, import_jsx_runtime39.jsx)(ComponentList, { id: "all" }) });
};
init_react_import();
init_react_import();
var styleSelector = 'style, link[rel="stylesheet"]';
var collectStyles = (doc) => {
  const collected = [];
  doc.querySelectorAll(styleSelector).forEach((style) => {
    if (style.tagName === "STYLE") {
      const hasContent = !!style.innerHTML.trim();
      if (hasContent) {
        collected.push(style);
      }
    } else {
      collected.push(style);
    }
  });
  return collected;
};
var getStyleSheet = (el) => {
  return Array.from(document.styleSheets).find((ss) => {
    const ownerNode = ss.ownerNode;
    return ownerNode.href === el.href;
  });
};
var getStyles = (styleSheet) => {
  if (styleSheet) {
    try {
      return Array.from(styleSheet.cssRules).map((rule) => rule.cssText).join("");
    } catch (e2) {
      console.warn(
        "Access to stylesheet %s is denied. Ignoring",
        styleSheet.href
      );
    }
  }
  return "";
};
var syncAttributes = (sourceElement, targetElement) => {
  const attributes = sourceElement.attributes;
  if ((attributes == null ? void 0 : attributes.length) > 0) {
    Array.from(attributes).forEach((attribute) => {
      targetElement.setAttribute(attribute.name, attribute.value);
    });
  }
};
var defer = (fn) => setTimeout(fn, 0);
var CopyHostStyles = ({
  children,
  debug = false,
  onStylesLoaded = () => null
}) => {
  const { document: doc, window: win } = useFrame();
  (0, import_react52.useEffect)(() => {
    if (!win || !doc) {
      return () => {
      };
    }
    let elements = [];
    const hashes = {};
    const lookupEl = (el) => elements.findIndex((elementMap) => elementMap.original === el);
    const mirrorEl = (el, inlineStyles = false) => __async(null, null, function* () {
      let mirror;
      if (el.nodeName === "LINK" && inlineStyles) {
        mirror = document.createElement("style");
        mirror.type = "text/css";
        let styleSheet = getStyleSheet(el);
        if (!styleSheet) {
          yield new Promise((resolve) => {
            const fn = () => {
              resolve();
              el.removeEventListener("load", fn);
            };
            el.addEventListener("load", fn);
          });
          styleSheet = getStyleSheet(el);
        }
        const styles2 = getStyles(styleSheet);
        if (!styles2) {
          if (debug) {
            console.warn(
              `Tried to load styles for link element, but couldn't find them. Skipping...`
            );
          }
          return;
        }
        mirror.innerHTML = styles2;
        mirror.setAttribute("data-href", el.getAttribute("href"));
      } else {
        mirror = el.cloneNode(true);
      }
      return mirror;
    });
    const addEl = (el) => __async(null, null, function* () {
      const index = lookupEl(el);
      if (index > -1) {
        if (debug)
          console.log(
            `Tried to add an element that was already mirrored. Updating instead...`
          );
        elements[index].mirror.innerText = el.innerText;
        return;
      }
      const mirror = yield mirrorEl(el);
      if (!mirror) {
        return;
      }
      const elHash = (0, import_object_hash.default)(mirror.outerHTML);
      if (hashes[elHash]) {
        if (debug)
          console.log(
            `iframe already contains element that is being mirrored. Skipping...`
          );
        return;
      }
      hashes[elHash] = true;
      doc.head.append(mirror);
      elements.push({ original: el, mirror });
      if (debug) console.log(`Added style node ${el.outerHTML}`);
    });
    const removeEl = (el) => {
      var _a5, _b3;
      const index = lookupEl(el);
      if (index === -1) {
        if (debug)
          console.log(
            `Tried to remove an element that did not exist. Skipping...`
          );
        return;
      }
      const elHash = (0, import_object_hash.default)(el.outerHTML);
      (_b3 = (_a5 = elements[index]) == null ? void 0 : _a5.mirror) == null ? void 0 : _b3.remove();
      delete hashes[elHash];
      if (debug) console.log(`Removed style node ${el.outerHTML}`);
    };
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList") {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE) {
              const el = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
              if (el && el.matches(styleSelector)) {
                defer(() => addEl(el));
              }
            }
          });
          mutation.removedNodes.forEach((node) => {
            if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE) {
              const el = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
              if (el && el.matches(styleSelector)) {
                defer(() => removeEl(el));
              }
            }
          });
        }
      });
    });
    const parentDocument = win.parent.document;
    const collectedStyles = collectStyles(parentDocument);
    const hrefs = [];
    let stylesLoaded = 0;
    const parentHtml = parentDocument.getElementsByTagName("html")[0];
    syncAttributes(parentHtml, doc.documentElement);
    const parentBody = parentDocument.getElementsByTagName("body")[0];
    syncAttributes(parentBody, doc.body);
    Promise.all(
      collectedStyles.map((styleNode, i2) => __async(null, null, function* () {
        if (styleNode.nodeName === "LINK") {
          const linkHref = styleNode.href;
          if (hrefs.indexOf(linkHref) > -1) {
            return;
          }
          hrefs.push(linkHref);
        }
        const mirror = yield mirrorEl(styleNode);
        if (!mirror) return;
        elements.push({ original: styleNode, mirror });
        return mirror;
      }))
    ).then((mirrorStyles) => {
      const filtered = mirrorStyles.filter(
        (el) => typeof el !== "undefined"
      );
      filtered.forEach((mirror) => {
        mirror.onload = () => {
          stylesLoaded = stylesLoaded + 1;
          if (stylesLoaded >= elements.length) {
            onStylesLoaded();
          }
        };
        mirror.onerror = () => {
          console.warn(`AutoFrame couldn't load a stylesheet`);
          stylesLoaded = stylesLoaded + 1;
          if (stylesLoaded >= elements.length) {
            onStylesLoaded();
          }
        };
      });
      doc.head.innerHTML = "";
      doc.head.append(...filtered);
      observer.observe(parentDocument.head, { childList: true, subtree: true });
      filtered.forEach((el) => {
        const elHash = (0, import_object_hash.default)(el.outerHTML);
        hashes[elHash] = true;
      });
    });
    return () => {
      observer.disconnect();
    };
  }, []);
  return (0, import_jsx_runtime40.jsx)(import_jsx_runtime40.Fragment, { children });
};
var autoFrameContext = (0, import_react52.createContext)({});
var useFrame = () => (0, import_react52.useContext)(autoFrameContext);
function AutoFrame(_a5) {
  var _b3 = _a5, {
    children,
    className,
    debug,
    id,
    onReady = () => {
    },
    onNotReady = () => {
    },
    frameRef
  } = _b3, props = __objRest(_b3, [
    "children",
    "className",
    "debug",
    "id",
    "onReady",
    "onNotReady",
    "frameRef"
  ]);
  const [loaded, setLoaded] = (0, import_react52.useState)(false);
  const [ctx, setCtx] = (0, import_react52.useState)({});
  const [mountTarget, setMountTarget] = (0, import_react52.useState)();
  const [stylesLoaded, setStylesLoaded] = (0, import_react52.useState)(false);
  (0, import_react52.useEffect)(() => {
    var _a23;
    if (frameRef.current) {
      const doc = frameRef.current.contentDocument;
      const win = frameRef.current.contentWindow;
      setCtx({
        document: doc || void 0,
        window: win || void 0
      });
      setMountTarget(
        (_a23 = frameRef.current.contentDocument) == null ? void 0 : _a23.getElementById("frame-root")
      );
      if (doc && win && stylesLoaded) {
        onReady();
      } else {
        onNotReady();
      }
    }
  }, [frameRef, loaded, stylesLoaded]);
  return (0, import_jsx_runtime40.jsx)(
    "iframe",
    __spreadProps(__spreadValues({}, props), {
      className,
      id,
      srcDoc: '<!DOCTYPE html><html><head></head><body><div id="frame-root" data-puck-entry></div></body></html>',
      ref: frameRef,
      onLoad: () => {
        setLoaded(true);
      },
      children: (0, import_jsx_runtime40.jsx)(autoFrameContext.Provider, { value: ctx, children: loaded && mountTarget && (0, import_jsx_runtime40.jsx)(
        CopyHostStyles,
        {
          debug,
          onStylesLoaded: () => setStylesLoaded(true),
          children: (0, import_react_dom4.createPortal)(children, mountTarget)
        }
      ) })
    })
  );
}
AutoFrame.displayName = "AutoFrame";
var AutoFrame_default = AutoFrame;
init_react_import();
var styles_module_default14 = { "PuckPreview": "_PuckPreview_z2rgu_1", "PuckPreview-frame": "_PuckPreview-frame_z2rgu_6" };
var getClassName20 = get_class_name_factory_default("PuckPreview", styles_module_default14);
var useBubbleIframeEvents = (ref) => {
  const status = useAppStore((s2) => s2.status);
  (0, import_react51.useEffect)(() => {
    if (ref.current && status === "READY") {
      const iframe = ref.current;
      const handlePointerMove = (event) => {
        const evt = new BubbledPointerEvent("pointermove", __spreadProps(__spreadValues({}, event), {
          bubbles: true,
          cancelable: false,
          clientX: event.clientX,
          clientY: event.clientY,
          originalTarget: event.target
        }));
        iframe.dispatchEvent(evt);
      };
      const register = () => {
        var _a5;
        unregister();
        (_a5 = iframe.contentDocument) == null ? void 0 : _a5.addEventListener(
          "pointermove",
          handlePointerMove,
          {
            capture: true
          }
        );
      };
      const unregister = () => {
        var _a5;
        (_a5 = iframe.contentDocument) == null ? void 0 : _a5.removeEventListener(
          "pointermove",
          handlePointerMove
        );
      };
      register();
      return () => {
        unregister();
      };
    }
  }, [status]);
};
var Preview2 = ({ id = "puck-preview" }) => {
  const dispatch = useAppStore((s2) => s2.dispatch);
  const root = useAppStore((s2) => s2.state.data.root);
  const config = useAppStore((s2) => s2.config);
  const setStatus = useAppStore((s2) => s2.setStatus);
  const iframe = useAppStore((s2) => s2.iframe);
  const overrides = useAppStore((s2) => s2.overrides);
  const metadata = useAppStore((s2) => s2.metadata);
  const renderData = useAppStore(
    (s2) => s2.state.ui.previewMode === "edit" ? null : s2.state.data
  );
  const Page = (0, import_react51.useCallback)(
    (pageProps) => {
      var _a5, _b3, _c4, _d2;
      const propsWithSlots = useSlots(
        config,
        { type: "root", props: pageProps },
        DropZoneEditPure
      );
      const richtextProps = useRichtextProps(
        (_b3 = (_a5 = config.root) == null ? void 0 : _a5.fields) != null ? _b3 : {},
        pageProps
      );
      return ((_c4 = config.root) == null ? void 0 : _c4.render) ? (_d2 = config.root) == null ? void 0 : _d2.render(__spreadValues(__spreadValues({
        id: "puck-root"
      }, propsWithSlots), richtextProps)) : (0, import_jsx_runtime41.jsx)(import_jsx_runtime41.Fragment, { children: propsWithSlots.children });
    },
    [config]
  );
  const Frame = (0, import_react51.useMemo)(() => overrides.iframe, [overrides]);
  const rootProps = root.props || root;
  const ref = (0, import_react51.useRef)(null);
  useBubbleIframeEvents(ref);
  const inner = !renderData ? (0, import_jsx_runtime41.jsx)(
    Page,
    __spreadProps(__spreadValues({}, rootProps), {
      puck: {
        renderDropZone: DropZonePure,
        isEditing: true,
        dragRef: null,
        metadata
      },
      editMode: true,
      children: (0, import_jsx_runtime41.jsx)(DropZonePure, { zone: rootDroppableId })
    })
  ) : (0, import_jsx_runtime41.jsx)(Render, { data: renderData, config, metadata });
  (0, import_react51.useEffect)(() => {
    if (!iframe.enabled) {
      setStatus("READY");
    }
  }, [iframe.enabled]);
  return (0, import_jsx_runtime41.jsx)(
    "div",
    {
      className: getClassName20(),
      id,
      "data-puck-preview": true,
      onClick: (e2) => {
        const el = e2.target;
        if (!el.hasAttribute("data-puck-component") && !el.hasAttribute("data-puck-dropzone")) {
          dispatch({ type: "setUi", ui: { itemSelector: null } });
        }
      },
      children: iframe.enabled ? (0, import_jsx_runtime41.jsx)(
        AutoFrame_default,
        {
          id: "preview-frame",
          className: getClassName20("frame"),
          "data-rfd-iframe": true,
          onReady: () => {
            setStatus("READY");
          },
          onNotReady: () => {
            setStatus("MOUNTED");
          },
          frameRef: ref,
          children: (0, import_jsx_runtime41.jsx)(autoFrameContext.Consumer, { children: ({ document: document2 }) => {
            if (Frame) {
              return (0, import_jsx_runtime41.jsx)(Frame, { document: document2, children: inner });
            }
            return inner;
          } })
        }
      ) : (0, import_jsx_runtime41.jsx)(
        "div",
        {
          id: "preview-frame",
          className: getClassName20("frame"),
          ref,
          "data-puck-entry": true,
          children: inner
        }
      )
    }
  );
};
init_react_import();
init_react_import();
init_react_import();
var styles_module_default15 = { "LayerTree": "_LayerTree_7rx04_1", "LayerTree-zoneTitle": "_LayerTree-zoneTitle_7rx04_11", "LayerTree-helper": "_LayerTree-helper_7rx04_17", "Layer": "_Layer_7rx04_1", "Layer-inner": "_Layer-inner_7rx04_29", "Layer--containsZone": "_Layer--containsZone_7rx04_35", "Layer-clickable": "_Layer-clickable_7rx04_39", "Layer--isSelected": "_Layer--isSelected_7rx04_61", "Layer-chevron": "_Layer-chevron_7rx04_77", "Layer--childIsSelected": "_Layer--childIsSelected_7rx04_78", "Layer-zones": "_Layer-zones_7rx04_82", "Layer-title": "_Layer-title_7rx04_96", "Layer-name": "_Layer-name_7rx04_105", "Layer-icon": "_Layer-icon_7rx04_111", "Layer-zoneIcon": "_Layer-zoneIcon_7rx04_116" };
init_react_import();
var scrollIntoView = (el) => {
  const oldStyle = __spreadValues({}, el.style);
  el.style.scrollMargin = "256px";
  if (el) {
    el == null ? void 0 : el.scrollIntoView({ behavior: "smooth" });
    el.style.scrollMargin = oldStyle.scrollMargin || "";
  }
};
init_react_import();
var onScrollEnd = (frame, cb) => {
  let scrollTimeout;
  const callback = function() {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(function() {
      cb();
      frame == null ? void 0 : frame.removeEventListener("scroll", callback);
    }, 50);
  };
  frame == null ? void 0 : frame.addEventListener("scroll", callback);
  setTimeout(() => {
    if (!scrollTimeout) {
      cb();
    }
  }, 50);
};
var getClassName21 = get_class_name_factory_default("LayerTree", styles_module_default15);
var getClassNameLayer = get_class_name_factory_default("Layer", styles_module_default15);
var Layer = ({
  index,
  itemId,
  zoneCompound
}) => {
  var _a5;
  const config = useAppStore((s2) => s2.config);
  const itemSelector = useAppStore((s2) => s2.state.ui.itemSelector);
  const dispatch = useAppStore((s2) => s2.dispatch);
  const setItemSelector = (0, import_react53.useCallback)(
    (itemSelector2) => {
      dispatch({ type: "setUi", ui: { itemSelector: itemSelector2 } });
    },
    [dispatch]
  );
  const selecedItemId = useAppStore((s2) => {
    var _a23;
    return (_a23 = s2.selectedItem) == null ? void 0 : _a23.props.id;
  });
  const isSelected = selecedItemId === itemId || itemSelector && itemSelector.zone === rootDroppableId && !zoneCompound;
  const nodeData = useAppStore((s2) => s2.state.indexes.nodes[itemId]);
  const zonesForItem = useAppStore(
    useShallow(
      (s2) => Object.keys(s2.state.indexes.zones).filter(
        (z) => z.split(":")[0] === itemId
      )
    )
  );
  const containsZone = zonesForItem.length > 0;
  const zoneStore = (0, import_react53.useContext)(ZoneStoreContext);
  const isHovering = useContextStore(
    ZoneStoreContext,
    (s2) => s2.hoveringComponent === itemId
  );
  const childIsSelected = useAppStore((s2) => {
    var _a23, _b3;
    const selectedData = s2.state.indexes.nodes[(_a23 = s2.selectedItem) == null ? void 0 : _a23.props.id];
    return (_b3 = selectedData == null ? void 0 : selectedData.path.some((candidate) => {
      const [candidateId] = candidate.split(":");
      return candidateId === itemId;
    })) != null ? _b3 : false;
  });
  const componentConfig = config.components[nodeData.data.type];
  const label = (_a5 = componentConfig == null ? void 0 : componentConfig["label"]) != null ? _a5 : nodeData.data.type.toString();
  return (0, import_jsx_runtime42.jsxs)(
    "li",
    {
      className: getClassNameLayer({
        isSelected,
        isHovering,
        containsZone,
        childIsSelected
      }),
      children: [
        (0, import_jsx_runtime42.jsx)("div", { className: getClassNameLayer("inner"), children: (0, import_jsx_runtime42.jsxs)(
          "button",
          {
            type: "button",
            className: getClassNameLayer("clickable"),
            onClick: () => {
              if (isSelected) {
                setItemSelector(null);
                return;
              }
              const frame = getFrame();
              const el = frame == null ? void 0 : frame.querySelector(
                `[data-puck-component="${itemId}"]`
              );
              if (!el) {
                setItemSelector({
                  index,
                  zone: zoneCompound
                });
                return;
              }
              scrollIntoView(el);
              onScrollEnd(frame, () => {
                setItemSelector({
                  index,
                  zone: zoneCompound
                });
              });
            },
            onMouseEnter: (e2) => {
              e2.stopPropagation();
              zoneStore.setState({ hoveringComponent: itemId });
            },
            onMouseLeave: (e2) => {
              e2.stopPropagation();
              zoneStore.setState({ hoveringComponent: null });
            },
            children: [
              containsZone && (0, import_jsx_runtime42.jsx)(
                "div",
                {
                  className: getClassNameLayer("chevron"),
                  title: isSelected ? "Collapse" : "Expand",
                  children: (0, import_jsx_runtime42.jsx)(ChevronDown, { size: "12" })
                }
              ),
              (0, import_jsx_runtime42.jsxs)("div", { className: getClassNameLayer("title"), children: [
                (0, import_jsx_runtime42.jsx)("div", { className: getClassNameLayer("icon"), children: nodeData.data.type === "Text" || nodeData.data.type === "Heading" ? (0, import_jsx_runtime42.jsx)(Type, { size: "16" }) : (0, import_jsx_runtime42.jsx)(LayoutGrid, { size: "16" }) }),
                (0, import_jsx_runtime42.jsx)("div", { className: getClassNameLayer("name"), children: label })
              ] })
            ]
          }
        ) }),
        containsZone && zonesForItem.map((subzone) => (0, import_jsx_runtime42.jsx)("div", { className: getClassNameLayer("zones"), children: (0, import_jsx_runtime42.jsx)(LayerTree, { zoneCompound: subzone }) }, subzone))
      ]
    }
  );
};
var LayerTree = ({
  label: _label,
  zoneCompound
}) => {
  const label = useAppStore((s2) => {
    var _a5, _b3, _c4, _d2;
    if (_label) return _label;
    if (zoneCompound === rootDroppableId) return;
    const [componentId, slotId] = zoneCompound.split(":");
    const componentType = (_a5 = s2.state.indexes.nodes[componentId]) == null ? void 0 : _a5.data.type;
    const configForComponent = componentType && componentType !== rootAreaId ? s2.config.components[componentType] : s2.config.root;
    return (_d2 = (_c4 = (_b3 = configForComponent == null ? void 0 : configForComponent.fields) == null ? void 0 : _b3[slotId]) == null ? void 0 : _c4.label) != null ? _d2 : slotId;
  });
  const contentIds = useAppStore(
    useShallow(
      (s2) => {
        var _a5, _b3;
        return zoneCompound ? (_b3 = (_a5 = s2.state.indexes.zones[zoneCompound]) == null ? void 0 : _a5.contentIds) != null ? _b3 : [] : [];
      }
    )
  );
  return (0, import_jsx_runtime42.jsxs)(import_jsx_runtime42.Fragment, { children: [
    label && (0, import_jsx_runtime42.jsxs)("div", { className: getClassName21("zoneTitle"), children: [
      (0, import_jsx_runtime42.jsx)("div", { className: getClassName21("zoneIcon"), children: (0, import_jsx_runtime42.jsx)(Layers, { size: "16" }) }),
      label
    ] }),
    (0, import_jsx_runtime42.jsxs)("ul", { className: getClassName21(), children: [
      contentIds.length === 0 && (0, import_jsx_runtime42.jsx)("div", { className: getClassName21("helper"), children: "No items" }),
      contentIds.map((itemId, i2) => {
        return (0, import_jsx_runtime42.jsx)(
          Layer,
          {
            index: i2,
            itemId,
            zoneCompound
          },
          itemId
        );
      })
    ] })
  ] });
};
init_react_import();
var findZonesForArea = (state, area) => {
  return Object.keys(state.indexes.zones).filter(
    (zone) => zone.split(":")[0] === area
  );
};
var Outline = () => {
  const outlineOverride = useAppStore((s2) => s2.overrides.outline);
  const rootZones = useAppStore(
    useShallow((s2) => findZonesForArea(s2.state, "root"))
  );
  const Wrapper = (0, import_react54.useMemo)(() => outlineOverride || "div", [outlineOverride]);
  return (0, import_jsx_runtime43.jsx)(Wrapper, { children: rootZones.map((zoneCompound) => (0, import_jsx_runtime43.jsx)(
    LayerTree,
    {
      label: rootZones.length === 1 ? "" : zoneCompound.split(":")[1],
      zoneCompound
    },
    zoneCompound
  )) });
};
init_react_import();
init_react_import();
var loadOverrides = ({
  overrides,
  plugins
}) => {
  const collected = __spreadValues({}, overrides);
  plugins == null ? void 0 : plugins.forEach((plugin) => {
    if (!plugin.overrides) return;
    Object.keys(plugin.overrides).forEach((_overridesType) => {
      var _a5;
      const overridesType = _overridesType;
      if (!((_a5 = plugin.overrides) == null ? void 0 : _a5[overridesType])) return;
      if (overridesType === "fieldTypes") {
        const fieldTypes = plugin.overrides.fieldTypes;
        Object.keys(fieldTypes).forEach((fieldType) => {
          collected.fieldTypes = collected.fieldTypes || {};
          const childNode2 = collected.fieldTypes[fieldType];
          const Comp2 = (props) => fieldTypes[fieldType](__spreadProps(__spreadValues({}, props), {
            children: childNode2 ? childNode2(props) : props.children
          }));
          collected.fieldTypes[fieldType] = Comp2;
        });
        return;
      }
      const childNode = collected[overridesType];
      const Comp = (props) => plugin.overrides[overridesType](__spreadProps(__spreadValues({}, props), {
        children: childNode ? childNode(props) : props.children
      }));
      collected[overridesType] = Comp;
    });
  });
  return collected;
};
var useLoadedOverrides = ({
  overrides,
  plugins
}) => {
  return (0, import_react55.useMemo)(() => {
    return loadOverrides({ overrides, plugins });
  }, [plugins, overrides]);
};
init_react_import();
init_react_import();
init_react_import();
function resolveAndReplaceData(currentData, getState, trigger = "force") {
  return __async(this, null, function* () {
    const resolvedResult = yield getState().resolveComponentData(
      currentData,
      trigger
    );
    if (!resolvedResult.didChange) return;
    const itemSelector = getSelectorForId(
      getState().state,
      resolvedResult.node.props.id
    );
    if (!itemSelector) {
      console.warn(
        `Warning: Could not find component with id "${currentData.props.id}" to resolve its data. Component may have been removed or the id is invalid.`
      );
      return;
    }
    getState().dispatch({
      type: "replace",
      data: toComponent(resolvedResult.node),
      destinationIndex: itemSelector.index,
      destinationZone: itemSelector.zone
    });
  });
}
function resolveDataById(id, getState, trigger) {
  return __async(this, null, function* () {
    const node = getState().state.indexes.nodes[id];
    if (!node) {
      console.warn(
        `Warning: Could not find component with id "${id}" to resolve its data. Component may have been removed or the id is invalid.`
      );
      return;
    }
    yield resolveAndReplaceData(node.data, getState, trigger);
  });
}
init_react_import();
function resolveDataBySelector(selector, getState, trigger) {
  return __async(this, null, function* () {
    const item = getItem(selector, getState().state);
    if (!item) {
      console.warn(
        `Warning: Could not find component for selector "${JSON.stringify(
          selector
        )}" to resolve its data. Component may have been removed or the selector is invalid.`
      );
      return;
    }
    const itemAsComponent = toComponent(item);
    yield resolveAndReplaceData(itemAsComponent, getState, trigger);
  });
}
var generateUsePuck = (store2, getState) => {
  const history = {
    back: store2.history.back,
    forward: store2.history.forward,
    setHistories: store2.history.setHistories,
    setHistoryIndex: store2.history.setHistoryIndex,
    hasPast: store2.history.hasPast(),
    hasFuture: store2.history.hasFuture(),
    histories: store2.history.histories,
    index: store2.history.index
  };
  const storeData = {
    appState: makeStatePublic(store2.state),
    config: store2.config,
    dispatch: store2.dispatch,
    getPermissions: store2.permissions.getPermissions,
    refreshPermissions: store2.permissions.refreshPermissions,
    resolveDataById: (id, trigger) => resolveDataById(id, getState, trigger),
    resolveDataBySelector: (selector, trigger) => resolveDataBySelector(selector, getState, trigger),
    history,
    selectedItem: store2.selectedItem || null,
    getItemBySelector: (selector) => getItem(selector, store2.state),
    getItemById: (id) => store2.state.indexes.nodes[id].data,
    getSelectorForId: (id) => getSelectorForId(store2.state, id),
    getParentById: (id) => {
      const node = store2.state.indexes.nodes[id];
      const parentId = node.parentId;
      if (parentId === null) return;
      const parentNode = store2.state.indexes.nodes[parentId];
      if (!parentNode) return;
      return parentNode.data;
    }
  };
  storeData.__private = {
    appState: store2.state
  };
  return storeData;
};
var UsePuckStoreContext = (0, import_react56.createContext)(
  null
);
var convertToPickedStore = (store2) => {
  return {
    state: store2.state,
    config: store2.config,
    dispatch: store2.dispatch,
    permissions: store2.permissions,
    history: store2.history,
    selectedItem: store2.selectedItem
  };
};
var useRegisterUsePuckStore = (appStore) => {
  const [usePuckStore] = (0, import_react56.useState)(
    () => createStore(
      () => generateUsePuck(
        convertToPickedStore(appStore.getState()),
        appStore.getState
      )
    )
  );
  (0, import_react56.useEffect)(() => {
    return appStore.subscribe(
      (store2) => convertToPickedStore(store2),
      (pickedStore) => {
        usePuckStore.setState(generateUsePuck(pickedStore, appStore.getState));
      }
    );
  }, []);
  return usePuckStore;
};
function createUsePuck() {
  return function usePuck2(selector) {
    const usePuckApi = (0, import_react56.useContext)(UsePuckStoreContext);
    if (!usePuckApi) {
      throw new Error("usePuck must be used inside <Puck>.");
    }
    const result = useStore(
      usePuckApi,
      selector != null ? selector : ((s2) => s2)
    );
    return result;
  };
}
function usePuck() {
  (0, import_react56.useEffect)(() => {
    console.warn(
      "You're using the `usePuck` method without a selector, which may cause unnecessary re-renders. Replace with `createUsePuck` and provide a selector for improved performance."
    );
  }, []);
  return createUsePuck()((s2) => s2);
}
function useGetPuck() {
  const usePuckApi = (0, import_react56.useContext)(UsePuckStoreContext);
  if (!usePuckApi) {
    throw new Error("usePuckGet must be used inside <Puck>.");
  }
  return usePuckApi.getState;
}
init_react_import();
init_react_import();
var styles_module_default16 = { "Puck": "_Puck_1dd16_19", "Puck-portal": "_Puck-portal_1dd16_31", "PuckLayout": "_PuckLayout_1dd16_36", "PuckLayout-inner": "_PuckLayout-inner_1dd16_40", "Puck--hidePlugins": "_Puck--hidePlugins_1dd16_72", "PuckLayout--mounted": "_PuckLayout--mounted_1dd16_77", "PuckLayout--mobilePanelHeightToggle": "_PuckLayout--mobilePanelHeightToggle_1dd16_81", "PuckLayout--leftSideBarVisible": "_PuckLayout--leftSideBarVisible_1dd16_81", "PuckLayout--isExpanded": "_PuckLayout--isExpanded_1dd16_87", "PuckLayout--mobilePanelHeightMinContent": "_PuckLayout--mobilePanelHeightMinContent_1dd16_105", "PuckLayout--rightSideBarVisible": "_PuckLayout--rightSideBarVisible_1dd16_132", "PuckLayout-mounted": "_PuckLayout-mounted_1dd16_151", "PuckLayout-nav": "_PuckLayout-nav_1dd16_192", "PuckLayout-header": "_PuckLayout-header_1dd16_208", "PuckPluginTab": "_PuckPluginTab_1dd16_222", "PuckPluginTab--visible": "_PuckPluginTab--visible_1dd16_228", "PuckPluginTab-body": "_PuckPluginTab-body_1dd16_233" };
init_react_import();
var styles = ``;
var useInjectStyleSheet = (initialStyles, iframeEnabled) => {
  const [el, setEl] = (0, import_react58.useState)();
  (0, import_react58.useEffect)(() => {
    setEl(document.createElement("style"));
  }, []);
  (0, import_react58.useEffect)(() => {
    var _a5;
    if (!el || typeof window === "undefined") {
      return;
    }
    el.innerHTML = initialStyles;
    if (iframeEnabled) {
      const frame = getFrame();
      (_a5 = frame == null ? void 0 : frame.head) == null ? void 0 : _a5.appendChild(el);
    }
    document.head.appendChild(el);
  }, [iframeEnabled, el]);
  return el;
};
var useInjectGlobalCss = (iframeEnabled) => {
  return useInjectStyleSheet(styles, iframeEnabled);
};
init_react_import();
var DefaultOverride = ({ children }) => (0, import_jsx_runtime44.jsx)(import_jsx_runtime44.Fragment, { children });
init_react_import();
var usePreviewModeHotkeys = () => {
  const appStore = useAppStoreApi();
  const toggleInteractive = (0, import_react59.useCallback)(() => {
    const dispatch = appStore.getState().dispatch;
    dispatch({
      type: "setUi",
      ui: (ui) => ({
        previewMode: ui.previewMode === "edit" ? "interactive" : "edit"
      })
    });
  }, [appStore]);
  useHotkey({ meta: true, i: true }, toggleInteractive);
  useHotkey({ ctrl: true, i: true }, toggleInteractive);
};
init_react_import();
init_react_import();
init_react_import();
var styles_module_default17 = { "MenuBar": "_MenuBar_8pf8c_1", "MenuBar--menuOpen": "_MenuBar--menuOpen_8pf8c_14", "MenuBar-inner": "_MenuBar-inner_8pf8c_29", "MenuBar-history": "_MenuBar-history_8pf8c_45" };
var getClassName222 = get_class_name_factory_default("MenuBar", styles_module_default17);
function MenuBar({
  menuOpen = false,
  renderHeaderActions,
  setMenuOpen
}) {
  const back = useAppStore((s2) => s2.history.back);
  const forward = useAppStore((s2) => s2.history.forward);
  const hasFuture = useAppStore((s2) => s2.history.hasFuture());
  const hasPast = useAppStore((s2) => s2.history.hasPast());
  return (0, import_jsx_runtime45.jsx)(
    "div",
    {
      className: getClassName222({ menuOpen }),
      onClick: (event) => {
        var _a5;
        const element = event.target;
        if (window.matchMedia("(min-width: 638px)").matches) {
          return;
        }
        if (element.tagName === "A" && ((_a5 = element.getAttribute("href")) == null ? void 0 : _a5.startsWith("#"))) {
          setMenuOpen(false);
        }
      },
      children: (0, import_jsx_runtime45.jsxs)("div", { className: getClassName222("inner"), children: [
        (0, import_jsx_runtime45.jsxs)("div", { className: getClassName222("history"), children: [
          (0, import_jsx_runtime45.jsx)(
            IconButton,
            {
              type: "button",
              title: "undo",
              disabled: !hasPast,
              onClick: back,
              children: (0, import_jsx_runtime45.jsx)(Undo2, { size: 21 })
            }
          ),
          (0, import_jsx_runtime45.jsx)(
            IconButton,
            {
              type: "button",
              title: "redo",
              disabled: !hasFuture,
              onClick: forward,
              children: (0, import_jsx_runtime45.jsx)(Redo2, { size: 21 })
            }
          )
        ] }),
        (0, import_jsx_runtime45.jsx)(import_jsx_runtime45.Fragment, { children: renderHeaderActions && renderHeaderActions() })
      ] })
    }
  );
}
init_react_import();
var styles_module_default18 = { "PuckHeader": "_PuckHeader_63pti_1", "PuckHeader--hidePlugins": "_PuckHeader--hidePlugins_63pti_15", "PuckHeader-inner": "_PuckHeader-inner_63pti_20", "PuckHeader-toggle": "_PuckHeader-toggle_63pti_40", "PuckHeader--rightSideBarVisible": "_PuckHeader--rightSideBarVisible_63pti_47", "PuckHeader-rightSideBarToggle": "_PuckHeader-rightSideBarToggle_63pti_47", "PuckHeader--leftSideBarVisible": "_PuckHeader--leftSideBarVisible_63pti_48", "PuckHeader-leftSideBarToggle": "_PuckHeader-leftSideBarToggle_63pti_48", "PuckHeader-title": "_PuckHeader-title_63pti_64", "PuckHeader-path": "_PuckHeader-path_63pti_68", "PuckHeader-tools": "_PuckHeader-tools_63pti_75", "PuckHeader-menuButton": "_PuckHeader-menuButton_63pti_81", "PuckHeader--menuOpen": "_PuckHeader--menuOpen_63pti_86" };
var getClassName23 = get_class_name_factory_default("PuckHeader", styles_module_default18);
var HeaderInner = ({
  hidePlugins
}) => {
  const {
    onPublish,
    renderHeader,
    renderHeaderActions,
    headerTitle,
    headerPath,
    iframe: _iframe
  } = usePropsContext();
  const dispatch = useAppStore((s2) => s2.dispatch);
  const appStore = useAppStoreApi();
  const defaultHeaderRender = (0, import_react60.useMemo)(() => {
    if (renderHeader) {
      console.warn(
        "`renderHeader` is deprecated. Please use `overrides.header` and the `usePuck` hook instead"
      );
      const RenderHeader = (_a5) => {
        var _b3 = _a5, { actions } = _b3, props = __objRest(_b3, ["actions"]);
        const Comp = renderHeader;
        const appState = useAppStore((s2) => s2.state);
        return (0, import_jsx_runtime46.jsx)(Comp, __spreadProps(__spreadValues({}, props), { dispatch, state: appState, children: actions }));
      };
      return RenderHeader;
    }
    return DefaultOverride;
  }, [renderHeader]);
  const defaultHeaderActionsRender = (0, import_react60.useMemo)(() => {
    if (renderHeaderActions) {
      console.warn(
        "`renderHeaderActions` is deprecated. Please use `overrides.headerActions` and the `usePuck` hook instead."
      );
      const RenderHeader = (props) => {
        const Comp = renderHeaderActions;
        const appState = useAppStore((s2) => s2.state);
        return (0, import_jsx_runtime46.jsx)(Comp, __spreadProps(__spreadValues({}, props), { dispatch, state: appState }));
      };
      return RenderHeader;
    }
    return DefaultOverride;
  }, [renderHeaderActions]);
  const CustomHeader = useAppStore(
    (s2) => s2.overrides.header || defaultHeaderRender
  );
  const CustomHeaderActions = useAppStore(
    (s2) => s2.overrides.headerActions || defaultHeaderActionsRender
  );
  const [menuOpen, setMenuOpen] = (0, import_react60.useState)(false);
  const rootTitle = useAppStore((s2) => {
    var _a5, _b3;
    const rootData = (_a5 = s2.state.indexes.nodes["root"]) == null ? void 0 : _a5.data;
    return (_b3 = rootData.props.title) != null ? _b3 : "";
  });
  const leftSideBarVisible = useAppStore((s2) => s2.state.ui.leftSideBarVisible);
  const rightSideBarVisible = useAppStore(
    (s2) => s2.state.ui.rightSideBarVisible
  );
  const toggleSidebars = (0, import_react60.useCallback)(
    (sidebar) => {
      const widerViewport = window.matchMedia("(min-width: 638px)").matches;
      const sideBarVisible = sidebar === "left" ? leftSideBarVisible : rightSideBarVisible;
      const oppositeSideBar = sidebar === "left" ? "rightSideBarVisible" : "leftSideBarVisible";
      dispatch({
        type: "setUi",
        ui: __spreadValues({
          [`${sidebar}SideBarVisible`]: !sideBarVisible
        }, !widerViewport ? { [oppositeSideBar]: false } : {})
      });
    },
    [dispatch, leftSideBarVisible, rightSideBarVisible]
  );
  return (0, import_jsx_runtime46.jsx)(
    CustomHeader,
    {
      actions: (0, import_jsx_runtime46.jsx)(import_jsx_runtime46.Fragment, { children: (0, import_jsx_runtime46.jsx)(CustomHeaderActions, { children: (0, import_jsx_runtime46.jsx)(
        Button,
        {
          onClick: () => {
            const data = appStore.getState().state.data;
            onPublish && onPublish(data);
          },
          icon: (0, import_jsx_runtime46.jsx)(Globe, { size: "14px" }),
          children: "Publish"
        }
      ) }) }),
      children: (0, import_jsx_runtime46.jsx)(
        "header",
        {
          className: getClassName23({
            leftSideBarVisible,
            rightSideBarVisible,
            hidePlugins
          }),
          children: (0, import_jsx_runtime46.jsxs)("div", { className: getClassName23("inner"), children: [
            (0, import_jsx_runtime46.jsxs)("div", { className: getClassName23("toggle"), children: [
              (0, import_jsx_runtime46.jsx)("div", { className: getClassName23("leftSideBarToggle"), children: (0, import_jsx_runtime46.jsx)(
                IconButton,
                {
                  type: "button",
                  onClick: () => {
                    toggleSidebars("left");
                  },
                  title: "Toggle left sidebar",
                  children: (0, import_jsx_runtime46.jsx)(PanelLeft, { focusable: "false" })
                }
              ) }),
              (0, import_jsx_runtime46.jsx)("div", { className: getClassName23("rightSideBarToggle"), children: (0, import_jsx_runtime46.jsx)(
                IconButton,
                {
                  type: "button",
                  onClick: () => {
                    toggleSidebars("right");
                  },
                  title: "Toggle right sidebar",
                  children: (0, import_jsx_runtime46.jsx)(PanelRight, { focusable: "false" })
                }
              ) })
            ] }),
            (0, import_jsx_runtime46.jsx)("div", { className: getClassName23("title"), children: (0, import_jsx_runtime46.jsxs)(Heading, { rank: "2", size: "xs", children: [
              headerTitle || rootTitle || "Page",
              headerPath && (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [
                " ",
                (0, import_jsx_runtime46.jsx)("code", { className: getClassName23("path"), children: headerPath })
              ] })
            ] }) }),
            (0, import_jsx_runtime46.jsxs)("div", { className: getClassName23("tools"), children: [
              (0, import_jsx_runtime46.jsx)("div", { className: getClassName23("menuButton"), children: (0, import_jsx_runtime46.jsx)(
                IconButton,
                {
                  type: "button",
                  onClick: () => {
                    return setMenuOpen(!menuOpen);
                  },
                  title: "Toggle menu bar",
                  children: menuOpen ? (0, import_jsx_runtime46.jsx)(ChevronUp, { focusable: "false" }) : (0, import_jsx_runtime46.jsx)(ChevronDown, { focusable: "false" })
                }
              ) }),
              (0, import_jsx_runtime46.jsx)(
                MenuBar,
                {
                  dispatch,
                  onPublish,
                  menuOpen,
                  renderHeaderActions: () => (0, import_jsx_runtime46.jsx)(CustomHeaderActions, { children: (0, import_jsx_runtime46.jsx)(
                    Button,
                    {
                      onClick: () => {
                        const data = appStore.getState().state.data;
                        onPublish && onPublish(data);
                      },
                      icon: (0, import_jsx_runtime46.jsx)(Globe, { size: "14px" }),
                      children: "Publish"
                    }
                  ) }),
                  setMenuOpen
                }
              )
            ] })
          ] })
        }
      )
    }
  );
};
var Header = (0, import_react60.memo)(HeaderInner);
init_react_import();
init_react_import();
var styles_module_default19 = { "SidebarSection": "_SidebarSection_5otpt_1", "SidebarSection-title": "_SidebarSection-title_5otpt_12", "SidebarSection--noBorderTop": "_SidebarSection--noBorderTop_5otpt_20", "SidebarSection-content": "_SidebarSection-content_5otpt_24", "SidebarSection-breadcrumbLabel": "_SidebarSection-breadcrumbLabel_5otpt_33", "SidebarSection-breadcrumbs": "_SidebarSection-breadcrumbs_5otpt_62", "SidebarSection-breadcrumb": "_SidebarSection-breadcrumb_5otpt_33", "SidebarSection-heading": "_SidebarSection-heading_5otpt_74", "SidebarSection-loadingOverlay": "_SidebarSection-loadingOverlay_5otpt_78" };
init_react_import();
init_react_import();
var styles_module_default20 = { "Breadcrumbs": "_Breadcrumbs_1c9yh_1", "Breadcrumbs-breadcrumbLabel": "_Breadcrumbs-breadcrumbLabel_1c9yh_7", "Breadcrumbs-breadcrumb": "_Breadcrumbs-breadcrumb_1c9yh_7" };
init_react_import();
var useBreadcrumbs = (renderCount) => {
  const selectedId = useAppStore((s2) => {
    var _a5;
    return (_a5 = s2.selectedItem) == null ? void 0 : _a5.props.id;
  });
  const config = useAppStore((s2) => s2.config);
  const path = useAppStore((s2) => {
    var _a5;
    return (_a5 = s2.state.indexes.nodes[selectedId]) == null ? void 0 : _a5.path;
  });
  const appStore = useAppStoreApi();
  return (0, import_react61.useMemo)(() => {
    const breadcrumbs = (path == null ? void 0 : path.map((zoneCompound) => {
      var _a5, _b3, _c4, _d2;
      const [componentId] = zoneCompound.split(":");
      if (componentId === "root") {
        return {
          label: ((_a5 = config == null ? void 0 : config.root) == null ? void 0 : _a5.label) || "Page",
          selector: null
        };
      }
      const node = appStore.getState().state.indexes.nodes[componentId];
      const parentId = node.path[node.path.length - 1];
      const contentIds = ((_b3 = appStore.getState().state.indexes.zones[parentId]) == null ? void 0 : _b3.contentIds) || [];
      const index = contentIds.indexOf(componentId);
      const label = node ? (_d2 = (_c4 = config.components[node.data.type]) == null ? void 0 : _c4.label) != null ? _d2 : node.data.type : "Component";
      return {
        label,
        selector: node ? {
          index,
          zone: node.path[node.path.length - 1]
        } : null
      };
    })) || [];
    if (renderCount) {
      return breadcrumbs.slice(breadcrumbs.length - renderCount);
    }
    return breadcrumbs;
  }, [path, renderCount]);
};
var getClassName24 = get_class_name_factory_default("Breadcrumbs", styles_module_default20);
var Breadcrumbs = ({
  children,
  numParents = 1
}) => {
  const setUi = useAppStore((s2) => s2.setUi);
  const breadcrumbs = useBreadcrumbs(numParents);
  return (0, import_jsx_runtime47.jsxs)("div", { className: getClassName24(), children: [
    breadcrumbs.map((breadcrumb, i2) => (0, import_jsx_runtime47.jsxs)("div", { className: getClassName24("breadcrumb"), children: [
      (0, import_jsx_runtime47.jsx)(
        "button",
        {
          type: "button",
          className: getClassName24("breadcrumbLabel"),
          onClick: () => setUi({ itemSelector: breadcrumb.selector }),
          children: breadcrumb.label
        }
      ),
      (0, import_jsx_runtime47.jsx)(ChevronRight, { size: 16 })
    ] }, i2)),
    children
  ] });
};
var getClassName25 = get_class_name_factory_default("SidebarSection", styles_module_default19);
var SidebarSection = ({
  children,
  title,
  background,
  showBreadcrumbs,
  noBorderTop,
  isLoading
}) => {
  return (0, import_jsx_runtime48.jsxs)("div", { className: getClassName25({ noBorderTop }), style: { background }, children: [
    (0, import_jsx_runtime48.jsx)("div", { className: getClassName25("title"), children: (0, import_jsx_runtime48.jsxs)("div", { className: getClassName25("breadcrumbs"), children: [
      showBreadcrumbs && (0, import_jsx_runtime48.jsx)(Breadcrumbs, {}),
      (0, import_jsx_runtime48.jsx)("div", { className: getClassName25("heading"), children: (0, import_jsx_runtime48.jsx)(Heading, { rank: "2", size: "xs", children: title }) })
    ] }) }),
    (0, import_jsx_runtime48.jsx)("div", { className: getClassName25("content"), children }),
    isLoading && (0, import_jsx_runtime48.jsx)("div", { className: getClassName25("loadingOverlay"), children: (0, import_jsx_runtime48.jsx)(Loader, { size: 32 }) })
  ] });
};
init_react_import();
init_react_import();
init_react_import();
var styles_module_default21 = { "ViewportControls": "_ViewportControls_e3unb_1", "ViewportControls--fullScreen": "_ViewportControls--fullScreen_e3unb_5", "ViewportControls-toggleButton": "_ViewportControls-toggleButton_e3unb_14", "ViewportControls--isExpanded": "_ViewportControls--isExpanded_e3unb_38", "ViewportControls-actions": "_ViewportControls-actions_e3unb_42", "ViewportControls-actionsInner": "_ViewportControls-actionsInner_e3unb_46", "ViewportControls-divider": "_ViewportControls-divider_e3unb_75", "ViewportControls-zoomSelect": "_ViewportControls-zoomSelect_e3unb_81", "ViewportControls-zoom": "_ViewportControls-zoom_e3unb_81", "ViewportButton-inner": "_ViewportButton-inner_e3unb_111", "ViewportButton--isActive": "_ViewportButton--isActive_e3unb_119" };
var icons = {
  Smartphone: (0, import_jsx_runtime49.jsx)(Smartphone, { size: 16 }),
  Tablet: (0, import_jsx_runtime49.jsx)(Tablet, { size: 16 }),
  Monitor: (0, import_jsx_runtime49.jsx)(Monitor, { size: 16 }),
  FullWidth: (0, import_jsx_runtime49.jsx)(Expand, { size: 16 })
};
var getClassName26 = get_class_name_factory_default("ViewportControls", styles_module_default21);
var getClassNameButton = get_class_name_factory_default("ViewportButton", styles_module_default21);
var ActionButton = ({
  children,
  title,
  onClick,
  isActive,
  disabled
}) => {
  return (0, import_jsx_runtime49.jsx)("span", { className: getClassNameButton({ isActive }), suppressHydrationWarning: true, children: (0, import_jsx_runtime49.jsx)(
    IconButton,
    {
      type: "button",
      title,
      disabled: disabled || isActive,
      onClick,
      suppressHydrationWarning: true,
      children: (0, import_jsx_runtime49.jsx)("span", { className: getClassNameButton("inner"), children })
    }
  ) });
};
var defaultZoomOptions = [
  { label: "25%", value: 0.25 },
  { label: "50%", value: 0.5 },
  { label: "75%", value: 0.75 },
  { label: "100%", value: 1 },
  { label: "125%", value: 1.25 },
  { label: "150%", value: 1.5 },
  { label: "200%", value: 2 }
];
var ViewportControls = ({
  autoZoom,
  zoom,
  onViewportChange,
  onZoom,
  fullScreen
}) => {
  var _a5, _b3;
  const viewports = useAppStore((s2) => s2.viewports);
  const uiViewports = useAppStore((s2) => s2.state.ui.viewports);
  const defaultsContainAutoZoom = defaultZoomOptions.find(
    (option) => option.value === autoZoom
  );
  const zoomOptions = (0, import_react63.useMemo)(
    () => [
      ...defaultZoomOptions,
      ...defaultsContainAutoZoom ? [] : [
        {
          value: autoZoom,
          label: `${(autoZoom * 100).toFixed(0)}% (Auto)`
        }
      ]
    ].filter((a2) => a2.value <= autoZoom).sort((a2, b2) => a2.value > b2.value ? 1 : -1),
    [autoZoom]
  );
  const [activeViewport, setActiveViewport] = (0, import_react63.useState)(
    uiViewports.current.width
  );
  (0, import_react63.useEffect)(() => {
    setActiveViewport(uiViewports.current.width);
  }, [uiViewports.current]);
  const [isExpanded, setIsExpanded] = (0, import_react63.useState)(false);
  return (0, import_jsx_runtime49.jsxs)(
    "div",
    {
      className: getClassName26({ isExpanded, fullScreen }),
      suppressHydrationWarning: true,
      children: [
        (0, import_jsx_runtime49.jsx)("div", { className: getClassName26("actions"), children: (0, import_jsx_runtime49.jsxs)("div", { className: getClassName26("actionsInner"), children: [
          viewports.map((viewport, i2) => (0, import_jsx_runtime49.jsx)(
            ActionButton,
            {
              title: viewport.label ? `Switch to ${viewport.label} viewport` : "Switch viewport",
              onClick: () => {
                setActiveViewport(viewport.width);
                onViewportChange(viewport);
              },
              isActive: activeViewport === viewport.width,
              children: typeof viewport.icon === "string" ? icons[viewport.icon] || viewport.icon : viewport.icon || icons.Smartphone
            },
            i2
          )),
          (0, import_jsx_runtime49.jsx)("div", { className: getClassName26("divider") }),
          (0, import_jsx_runtime49.jsx)(
            ActionButton,
            {
              title: "Zoom viewport out",
              disabled: zoom <= ((_a5 = zoomOptions[0]) == null ? void 0 : _a5.value),
              onClick: (e2) => {
                e2.stopPropagation();
                onZoom(
                  zoomOptions[Math.max(
                    zoomOptions.findIndex((option) => option.value === zoom) - 1,
                    0
                  )].value
                );
              },
              children: (0, import_jsx_runtime49.jsx)(ZoomOut, { size: 16 })
            }
          ),
          (0, import_jsx_runtime49.jsx)(
            ActionButton,
            {
              title: "Zoom viewport in",
              disabled: zoom >= ((_b3 = zoomOptions[zoomOptions.length - 1]) == null ? void 0 : _b3.value),
              onClick: (e2) => {
                e2.stopPropagation();
                onZoom(
                  zoomOptions[Math.min(
                    zoomOptions.findIndex((option) => option.value === zoom) + 1,
                    zoomOptions.length - 1
                  )].value
                );
              },
              children: (0, import_jsx_runtime49.jsx)(ZoomIn, { size: 16 })
            }
          ),
          (0, import_jsx_runtime49.jsxs)("div", { className: getClassName26("zoom"), children: [
            (0, import_jsx_runtime49.jsx)("div", { className: getClassName26("divider") }),
            (0, import_jsx_runtime49.jsx)(
              "select",
              {
                className: getClassName26("zoomSelect"),
                value: zoom.toString(),
                onClick: (e2) => {
                  e2.stopPropagation();
                },
                onChange: (e2) => {
                  onZoom(parseFloat(e2.currentTarget.value));
                },
                children: zoomOptions.map((option) => (0, import_jsx_runtime49.jsx)(
                  "option",
                  {
                    value: option.value,
                    label: option.label
                  },
                  option.label
                ))
              }
            )
          ] })
        ] }) }),
        (0, import_jsx_runtime49.jsx)(
          "button",
          {
            className: getClassName26("toggleButton"),
            title: "Toggle viewport menu",
            onClick: () => setIsExpanded((s2) => !s2),
            children: isExpanded ? (0, import_jsx_runtime49.jsx)(X, { size: 16 }) : (0, import_jsx_runtime49.jsx)(Monitor, { size: 16 })
          }
        )
      ]
    }
  );
};
init_react_import();
var styles_module_default222 = { "PuckCanvas": "_PuckCanvas_t6s9b_1", "PuckCanvas-controls": "_PuckCanvas-controls_t6s9b_17", "PuckCanvas--fullScreen": "_PuckCanvas--fullScreen_t6s9b_22", "PuckCanvas-inner": "_PuckCanvas-inner_t6s9b_33", "PuckCanvas-root": "_PuckCanvas-root_t6s9b_42", "PuckCanvas--ready": "_PuckCanvas--ready_t6s9b_67", "PuckCanvas-loader": "_PuckCanvas-loader_t6s9b_72", "PuckCanvas--showLoader": "_PuckCanvas--showLoader_t6s9b_82" };
init_react_import();
var FrameContext = (0, import_react64.createContext)(null);
var FrameProvider = ({
  children
}) => {
  const frameRef = (0, import_react64.useRef)(null);
  const value = (0, import_react64.useMemo)(
    () => ({
      frameRef
    }),
    []
  );
  return (0, import_jsx_runtime50.jsx)(FrameContext.Provider, { value, children });
};
var useCanvasFrame = () => {
  const context = (0, import_react64.useContext)(FrameContext);
  if (context === null) {
    throw new Error("useCanvasFrame must be used within a FrameProvider");
  }
  return context;
};
var getClassName27 = get_class_name_factory_default("PuckCanvas", styles_module_default222);
var ZOOM_ON_CHANGE = true;
var TRANSITION_DURATION = 150;
var Canvas = () => {
  const { frameRef } = useCanvasFrame();
  const resetAutoZoom = useResetAutoZoom(frameRef);
  const {
    _experimentalFullScreenCanvas,
    viewports: viewportOptions = defaultViewports
  } = usePropsContext();
  const {
    dispatch,
    overrides,
    setUi,
    zoomConfig,
    setZoomConfig,
    status,
    iframe
  } = useAppStore(
    useShallow((s2) => ({
      dispatch: s2.dispatch,
      overrides: s2.overrides,
      setUi: s2.setUi,
      zoomConfig: s2.zoomConfig,
      setZoomConfig: s2.setZoomConfig,
      status: s2.status,
      iframe: s2.iframe
    }))
  );
  const {
    leftSideBarVisible,
    rightSideBarVisible,
    leftSideBarWidth,
    rightSideBarWidth,
    viewports
  } = useAppStore(
    useShallow((s2) => ({
      leftSideBarVisible: s2.state.ui.leftSideBarVisible,
      rightSideBarVisible: s2.state.ui.rightSideBarVisible,
      leftSideBarWidth: s2.state.ui.leftSideBarWidth,
      rightSideBarWidth: s2.state.ui.rightSideBarWidth,
      viewports: s2.state.ui.viewports
    }))
  );
  const [showTransition, setShowTransition] = (0, import_react62.useState)(false);
  const isResizingRef = (0, import_react62.useRef)(false);
  const defaultRender = (0, import_react62.useMemo)(() => {
    const PuckDefault = ({ children }) => (0, import_jsx_runtime51.jsx)(import_jsx_runtime51.Fragment, { children });
    return PuckDefault;
  }, []);
  const CustomPreview = (0, import_react62.useMemo)(
    () => overrides.preview || defaultRender,
    [overrides]
  );
  const getFrameDimensions = (0, import_react62.useCallback)(() => {
    if (frameRef.current) {
      const frame = frameRef.current;
      const box = getBox(frame);
      return { width: box.contentBox.width, height: box.contentBox.height };
    }
    return { width: 0, height: 0 };
  }, [frameRef]);
  (0, import_react62.useEffect)(() => {
    resetAutoZoom();
  }, [
    frameRef,
    leftSideBarVisible,
    rightSideBarVisible,
    leftSideBarWidth,
    rightSideBarWidth,
    viewports
  ]);
  (0, import_react62.useEffect)(() => {
    const { height: frameHeight } = getFrameDimensions();
    if (viewports.current.height === "auto") {
      setZoomConfig(__spreadProps(__spreadValues({}, zoomConfig), {
        rootHeight: frameHeight / zoomConfig.zoom
      }));
    }
  }, [zoomConfig.zoom, getFrameDimensions, setZoomConfig]);
  (0, import_react62.useEffect)(() => {
    if (ZOOM_ON_CHANGE) {
      resetAutoZoom();
    }
  }, [viewports.current.width, viewports]);
  (0, import_react62.useEffect)(() => {
    if (!frameRef.current) return;
    const resizeObserver = new ResizeObserver(() => {
      if (!isResizingRef.current) {
        resetAutoZoom();
      }
    });
    resizeObserver.observe(frameRef.current);
    return () => {
      resizeObserver.disconnect();
    };
  }, [frameRef.current]);
  const [showLoader, setShowLoader] = (0, import_react62.useState)(false);
  (0, import_react62.useEffect)(() => {
    setTimeout(() => {
      setShowLoader(true);
    }, 500);
  }, []);
  const appStoreApi = useAppStoreApi();
  (0, import_react62.useEffect)(() => {
    var _a5;
    if (typeof window === "undefined") return;
    const viewportWidth = window.innerWidth;
    const frameWidth = (_a5 = frameRef.current) == null ? void 0 : _a5.getBoundingClientRect().width;
    if (!viewportWidth) return;
    if (!frameWidth) return;
    if (viewportOptions.length === 0) return;
    const fullWidthViewport = Object.values(viewportOptions).find(
      (v2) => v2.width === "100%"
    );
    const containsFullWidthViewport = !!fullWidthViewport;
    const viewportDifferences = Object.entries(viewportOptions).filter(([_2, value]) => value.width !== "100%").map(([key, value]) => ({
      key,
      diff: Math.abs(
        viewportWidth - (typeof value.width === "string" ? viewportWidth : value.width)
      ),
      value
    })).sort((a2, b2) => a2.diff > b2.diff ? 1 : -1);
    let closestViewport = viewportDifferences[0].value;
    if (closestViewport.width < frameWidth && containsFullWidthViewport) {
      closestViewport = fullWidthViewport;
    }
    if (iframe.enabled) {
      const s2 = appStoreApi.getState();
      const appState = {
        state: __spreadProps(__spreadValues({}, s2.state), {
          ui: __spreadProps(__spreadValues({}, s2.state.ui), {
            viewports: __spreadProps(__spreadValues({}, s2.state.ui.viewports), {
              current: __spreadProps(__spreadValues({}, s2.state.ui.viewports.current), {
                height: (closestViewport == null ? void 0 : closestViewport.height) || "auto",
                width: closestViewport == null ? void 0 : closestViewport.width
              })
            })
          })
        })
      };
      let history = s2.history;
      if (s2.history.histories.length === 1) {
        history = __spreadProps(__spreadValues({}, history), { histories: [appState] });
      }
      appStoreApi.setState(__spreadProps(__spreadValues({}, appState), { history }));
    }
  }, [viewportOptions, frameRef.current, iframe, appStoreApi]);
  return (0, import_jsx_runtime51.jsxs)(
    "div",
    {
      className: getClassName27({
        ready: status === "READY" || !iframe.enabled || !iframe.waitForStyles,
        showLoader,
        fullScreen: _experimentalFullScreenCanvas
      }),
      onClick: (e2) => {
        const el = e2.target;
        if (!el.hasAttribute("data-puck-component") && !el.hasAttribute("data-puck-dropzone")) {
          dispatch({
            type: "setUi",
            ui: { itemSelector: null },
            recordHistory: true
          });
        }
      },
      children: [
        viewports.controlsVisible && iframe.enabled && (0, import_jsx_runtime51.jsx)("div", { className: getClassName27("controls"), children: (0, import_jsx_runtime51.jsx)(
          ViewportControls,
          {
            fullScreen: _experimentalFullScreenCanvas,
            autoZoom: zoomConfig.autoZoom,
            zoom: zoomConfig.zoom,
            onViewportChange: (viewport) => {
              setShowTransition(true);
              isResizingRef.current = true;
              const uiViewport = __spreadProps(__spreadValues({}, viewport), {
                height: viewport.height || "auto",
                zoom: zoomConfig.zoom
              });
              const newUi = {
                viewports: __spreadProps(__spreadValues({}, viewports), { current: uiViewport })
              };
              setUi(newUi);
              if (ZOOM_ON_CHANGE) {
                resetAutoZoom({
                  viewports: __spreadProps(__spreadValues({}, viewports), { current: uiViewport })
                });
              }
            },
            onZoom: (zoom) => {
              setShowTransition(true);
              isResizingRef.current = true;
              setZoomConfig(__spreadProps(__spreadValues({}, zoomConfig), { zoom }));
            }
          }
        ) }),
        (0, import_jsx_runtime51.jsxs)("div", { className: getClassName27("inner"), ref: frameRef, children: [
          (0, import_jsx_runtime51.jsx)(
            "div",
            {
              className: getClassName27("root"),
              style: {
                width: iframe.enabled ? viewports.current.width : "100%",
                height: zoomConfig.rootHeight,
                transform: iframe.enabled ? `scale(${zoomConfig.zoom})` : void 0,
                transition: showTransition ? `width ${TRANSITION_DURATION}ms ease-out, height ${TRANSITION_DURATION}ms ease-out, transform ${TRANSITION_DURATION}ms ease-out` : "",
                overflow: iframe.enabled ? void 0 : "auto"
              },
              suppressHydrationWarning: true,
              id: "puck-canvas-root",
              onTransitionEnd: () => {
                setShowTransition(false);
                isResizingRef.current = false;
              },
              children: (0, import_jsx_runtime51.jsx)(CustomPreview, { children: (0, import_jsx_runtime51.jsx)(Preview2, {}) })
            }
          ),
          (0, import_jsx_runtime51.jsx)("div", { className: getClassName27("loader"), children: (0, import_jsx_runtime51.jsx)(Loader, { size: 24 }) })
        ] })
      ]
    }
  );
};
init_react_import();
function useSidebarResize(position, dispatch) {
  const [width, setWidth] = (0, import_react65.useState)(null);
  const sidebarRef = (0, import_react65.useRef)(null);
  const storeWidth = useAppStore(
    (s2) => position === "left" ? s2.state.ui.leftSideBarWidth : s2.state.ui.rightSideBarWidth
  );
  (0, import_react65.useEffect)(() => {
    if (typeof window !== "undefined" && !storeWidth) {
      try {
        const savedWidths = localStorage.getItem("puck-sidebar-widths");
        if (savedWidths) {
          const widths = JSON.parse(savedWidths);
          const savedWidth = widths[position];
          const key = position === "left" ? "leftSideBarWidth" : "rightSideBarWidth";
          if (savedWidth) {
            dispatch({
              type: "setUi",
              ui: {
                [key]: savedWidth
              }
            });
          }
        }
      } catch (error) {
        console.error(
          `Failed to load ${position} sidebar width from localStorage`,
          error
        );
      }
    }
  }, [dispatch, position, storeWidth]);
  (0, import_react65.useEffect)(() => {
    if (storeWidth !== void 0) {
      setWidth(storeWidth);
    }
  }, [storeWidth]);
  const handleResizeEnd = (0, import_react65.useCallback)(
    (width2) => {
      dispatch({
        type: "setUi",
        ui: {
          [position === "left" ? "leftSideBarWidth" : "rightSideBarWidth"]: width2
        }
      });
      let widths = {};
      try {
        const savedWidths = localStorage.getItem("puck-sidebar-widths");
        widths = savedWidths ? JSON.parse(savedWidths) : {};
      } catch (error) {
        console.error(
          `Failed to save ${position} sidebar width to localStorage`,
          error
        );
      } finally {
        localStorage.setItem(
          "puck-sidebar-widths",
          JSON.stringify(__spreadProps(__spreadValues({}, widths), {
            [position]: width2
          }))
        );
      }
      window.dispatchEvent(
        new CustomEvent("viewportchange", {
          bubbles: true,
          cancelable: false
        })
      );
    },
    [dispatch, position]
  );
  return {
    width,
    setWidth,
    sidebarRef,
    handleResizeEnd
  };
}
init_react_import();
init_react_import();
init_react_import();
var styles_module_default23 = { "ResizeHandle": "_ResizeHandle_144bf_2", "ResizeHandle--left": "_ResizeHandle--left_144bf_16", "ResizeHandle--right": "_ResizeHandle--right_144bf_20" };
var getClassName28 = get_class_name_factory_default("ResizeHandle", styles_module_default23);
var ResizeHandle = ({
  position,
  sidebarRef,
  onResize,
  onResizeEnd
}) => {
  const { frameRef } = useCanvasFrame();
  const resetAutoZoom = useResetAutoZoom(frameRef);
  const handleRef = (0, import_react66.useRef)(null);
  const isDragging = (0, import_react66.useRef)(false);
  const startX = (0, import_react66.useRef)(0);
  const startWidth = (0, import_react66.useRef)(0);
  const handleMouseMove = (0, import_react66.useCallback)(
    (e2) => {
      if (!isDragging.current) return;
      const delta = e2.clientX - startX.current;
      const newWidth = position === "left" ? startWidth.current + delta : startWidth.current - delta;
      const width = Math.max(192, newWidth);
      onResize(width);
      e2.preventDefault();
    },
    [onResize, position]
  );
  const handleMouseUp = (0, import_react66.useCallback)(() => {
    var _a5;
    if (!isDragging.current) return;
    isDragging.current = false;
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
    const overlay = document.getElementById("resize-overlay");
    if (overlay) {
      document.body.removeChild(overlay);
    }
    document.removeEventListener("mousemove", handleMouseMove);
    document.removeEventListener("mouseup", handleMouseUp);
    const finalWidth = ((_a5 = sidebarRef.current) == null ? void 0 : _a5.getBoundingClientRect().width) || 0;
    onResizeEnd(finalWidth);
    resetAutoZoom();
  }, [onResizeEnd]);
  const handleMouseDown = (0, import_react66.useCallback)(
    (e2) => {
      var _a5;
      isDragging.current = true;
      startX.current = e2.clientX;
      startWidth.current = ((_a5 = sidebarRef.current) == null ? void 0 : _a5.getBoundingClientRect().width) || 0;
      document.body.style.cursor = "col-resize";
      document.body.style.userSelect = "none";
      const overlay = document.createElement("div");
      overlay.id = "resize-overlay";
      overlay.setAttribute("data-resize-overlay", "");
      document.body.appendChild(overlay);
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      e2.preventDefault();
    },
    [position, handleMouseMove, handleMouseUp]
  );
  return (0, import_jsx_runtime52.jsx)(
    "div",
    {
      ref: handleRef,
      className: getClassName28({ [position]: true }),
      onMouseDown: handleMouseDown
    }
  );
};
init_react_import();
var styles_module_default24 = { "Sidebar": "_Sidebar_o396p_1", "Sidebar--isVisible": "_Sidebar--isVisible_o396p_9", "Sidebar--left": "_Sidebar--left_o396p_13", "Sidebar--right": "_Sidebar--right_o396p_25", "Sidebar-resizeHandle": "_Sidebar-resizeHandle_o396p_37" };
var getClassName29 = get_class_name_factory_default("Sidebar", styles_module_default24);
var Sidebar = ({
  position,
  sidebarRef,
  isVisible: isVisible2,
  onResize,
  onResizeEnd,
  children
}) => {
  return (0, import_jsx_runtime53.jsxs)(import_jsx_runtime53.Fragment, { children: [
    (0, import_jsx_runtime53.jsx)(
      "div",
      {
        ref: sidebarRef,
        className: getClassName29({ [position]: true, isVisible: isVisible2 }),
        children
      }
    ),
    (0, import_jsx_runtime53.jsx)("div", { className: `${getClassName29("resizeHandle")}`, children: (0, import_jsx_runtime53.jsx)(
      ResizeHandle,
      {
        position,
        sidebarRef,
        onResize,
        onResizeEnd
      }
    ) })
  ] });
};
init_react_import();
var isElementVisible = (element) => {
  let current = element;
  while (current && current !== document.body) {
    const style = window.getComputedStyle(current);
    if (style.display === "none" || style.visibility === "hidden" || style.opacity === "0" || current.getAttribute("aria-hidden") === "true" || current.hasAttribute("hidden")) {
      return false;
    }
    current = current.parentElement;
  }
  return true;
};
var shouldBlockDeleteHotkey = (e2) => {
  var _a5;
  if (e2 == null ? void 0 : e2.defaultPrevented) return true;
  const origin = ((_a5 = e2 == null ? void 0 : e2.composedPath) == null ? void 0 : _a5.call(e2)[0]) || (e2 == null ? void 0 : e2.target) || document.activeElement;
  if (origin instanceof HTMLElement) {
    const tag = origin.tagName.toLowerCase();
    if (tag === "input" || tag === "textarea" || tag === "select") return true;
    if (origin.isContentEditable) return true;
    const role = origin.getAttribute("role");
    if (role === "textbox" || role === "combobox" || role === "searchbox" || role === "listbox" || role === "grid") {
      return true;
    }
  }
  const modal = document.querySelector(
    'dialog[open], [aria-modal="true"], [role="dialog"], [role="alertdialog"]'
  );
  if (modal && isElementVisible(modal)) {
    return true;
  }
  return false;
};
var useDeleteHotkeys = () => {
  const appStore = useAppStoreApi();
  const deleteSelectedComponent = (0, import_react67.useCallback)(
    (e2) => {
      var _a5;
      if (shouldBlockDeleteHotkey(e2)) {
        return false;
      }
      const { state, dispatch, permissions, selectedItem } = appStore.getState();
      const sel = (_a5 = state.ui) == null ? void 0 : _a5.itemSelector;
      if (!(sel == null ? void 0 : sel.zone) || !selectedItem) return true;
      if (!permissions.getPermissions({ item: selectedItem }).delete)
        return true;
      dispatch({
        type: "remove",
        index: sel.index,
        zone: sel.zone
      });
      return true;
    },
    [appStore]
  );
  useHotkey({ delete: true }, deleteSelectedComponent);
  useHotkey({ backspace: true }, deleteSelectedComponent);
};
init_react_import();
init_react_import();
var styles_module_default25 = { "Nav": "_Nav_1tvxq_1", "Nav-list": "_Nav-list_1tvxq_5", "Nav-mobileActions": "_Nav-mobileActions_1tvxq_23", "NavItem-link": "_NavItem-link_1tvxq_38", "NavItem": "_NavItem_1tvxq_38", "NavItem-linkIcon": "_NavItem-linkIcon_1tvxq_89", "NavItem--active": "_NavItem--active_1tvxq_94", "NavItem--mobileOnly": "_NavItem--mobileOnly_1tvxq_121", "NavItem--desktopOnly": "_NavItem--desktopOnly_1tvxq_126" };
var getClassName30 = get_class_name_factory_default("Nav", styles_module_default25);
var getClassNameItem3 = get_class_name_factory_default("NavItem", styles_module_default25);
var MenuItem = ({
  label,
  icon,
  onClick,
  isActive,
  mobileOnly,
  desktopOnly
}) => {
  return (0, import_jsx_runtime54.jsx)(
    "li",
    {
      className: getClassNameItem3({
        active: isActive,
        mobileOnly,
        desktopOnly
      }),
      children: onClick && (0, import_jsx_runtime54.jsxs)("div", { className: getClassNameItem3("link"), onClick, children: [
        icon && (0, import_jsx_runtime54.jsx)("span", { className: getClassNameItem3("linkIcon"), children: icon }),
        (0, import_jsx_runtime54.jsx)("span", { className: getClassNameItem3("linkLabel"), children: label })
      ] })
    }
  );
};
var Nav = ({
  items,
  mobileActions
}) => {
  return (0, import_jsx_runtime54.jsxs)("nav", { className: getClassName30(), children: [
    (0, import_jsx_runtime54.jsx)("ul", { className: getClassName30("list"), children: Object.entries(items).map(([key, item]) => (0, import_jsx_runtime54.jsx)(MenuItem, __spreadValues({}, item), key)) }),
    mobileActions && (0, import_jsx_runtime54.jsx)("div", { className: getClassName30("mobileActions"), children: mobileActions })
  ] });
};
init_react_import();
init_react_import();
var styles_module_default26 = { "BlocksPlugin": "_BlocksPlugin_1ey1i_1" };
var getClassName31 = get_class_name_factory_default("BlocksPlugin", styles_module_default26);
var blocksPlugin = () => ({
  name: "blocks",
  label: "Blocks",
  render: () => (0, import_jsx_runtime55.jsx)("div", { className: getClassName31(), children: (0, import_jsx_runtime55.jsx)(Components, {}) }),
  icon: (0, import_jsx_runtime55.jsx)(Hammer, {})
});
init_react_import();
init_react_import();
var styles_module_default27 = { "OutlinePlugin": "_OutlinePlugin_q92j6_1" };
var getClassName32 = get_class_name_factory_default("OutlinePlugin", styles_module_default27);
var outlinePlugin = () => ({
  name: "outline",
  label: "Outline",
  render: () => (0, import_jsx_runtime56.jsx)("div", { className: getClassName32(), children: (0, import_jsx_runtime56.jsx)(Outline, {}) }),
  icon: (0, import_jsx_runtime56.jsx)(Layers, {})
});
init_react_import();
init_react_import();
var styles_module_default28 = { "FieldsPlugin": "_FieldsPlugin_nd930_1", "FieldsPlugin-header": "_FieldsPlugin-header_nd930_7" };
var getClassName33 = get_class_name_factory_default("FieldsPlugin", styles_module_default28);
var CurrentTitle = () => {
  const label = useAppStore((s2) => {
    var _a5, _b3;
    const selectedItem = s2.selectedItem;
    return selectedItem ? (_b3 = (_a5 = s2.config.components[selectedItem.type]) == null ? void 0 : _a5.label) != null ? _b3 : selectedItem.type : "Page";
  });
  return label;
};
var fieldsPlugin = ({ desktopSideBar = "right" } = {}) => ({
  name: "fields",
  label: "Fields",
  render: () => (0, import_jsx_runtime57.jsxs)("div", { className: getClassName33(), children: [
    (0, import_jsx_runtime57.jsx)("div", { className: getClassName33("header"), children: (0, import_jsx_runtime57.jsx)(Breadcrumbs, { numParents: 2, children: (0, import_jsx_runtime57.jsx)(CurrentTitle, {}) }) }),
    (0, import_jsx_runtime57.jsx)(Fields, {})
  ] }),
  icon: (0, import_jsx_runtime57.jsx)(RectangleEllipsis, {}),
  mobileOnly: desktopSideBar === "right"
});
var getClassName34 = get_class_name_factory_default("Puck", styles_module_default16);
var getLayoutClassName = get_class_name_factory_default("PuckLayout", styles_module_default16);
var getPluginTabClassName = get_class_name_factory_default("PuckPluginTab", styles_module_default16);
var FieldSideBar = () => {
  const title = useAppStore(
    (s2) => {
      var _a5, _b3, _c4;
      return s2.selectedItem ? (_b3 = (_a5 = s2.config.components[s2.selectedItem.type]) == null ? void 0 : _a5["label"]) != null ? _b3 : s2.selectedItem.type.toString() : ((_c4 = s2.config.root) == null ? void 0 : _c4.label) || "Page";
    }
  );
  return (0, import_jsx_runtime58.jsx)(SidebarSection, { noBorderTop: true, showBreadcrumbs: true, title, children: (0, import_jsx_runtime58.jsx)(Fields, {}) });
};
var PluginTab = ({
  children,
  visible,
  mobileOnly
}) => {
  return (0, import_jsx_runtime58.jsx)("div", { className: getPluginTabClassName({ visible, mobileOnly }), children: (0, import_jsx_runtime58.jsx)("div", { className: getPluginTabClassName("body"), children }) });
};
var Layout = ({ children }) => {
  const {
    iframe: _iframe,
    dnd,
    initialHistory: _initialHistory,
    plugins,
    height
  } = usePropsContext();
  const iframe = (0, import_react57.useMemo)(
    () => __spreadValues({
      enabled: true,
      waitForStyles: true
    }, _iframe),
    [_iframe]
  );
  useInjectGlobalCss(iframe.enabled);
  const dispatch = useAppStore((s2) => s2.dispatch);
  const leftSideBarVisible = useAppStore((s2) => s2.state.ui.leftSideBarVisible);
  const rightSideBarVisible = useAppStore(
    (s2) => s2.state.ui.rightSideBarVisible
  );
  const instanceId = useAppStore((s2) => s2.instanceId);
  const {
    width: leftWidth,
    setWidth: setLeftWidth,
    sidebarRef: leftSidebarRef,
    handleResizeEnd: handleLeftSidebarResizeEnd
  } = useSidebarResize("left", dispatch);
  const {
    width: rightWidth,
    setWidth: setRightWidth,
    sidebarRef: rightSidebarRef,
    handleResizeEnd: handleRightSidebarResizeEnd
  } = useSidebarResize("right", dispatch);
  (0, import_react57.useEffect)(() => {
    if (!window.matchMedia("(min-width: 638px)").matches) {
      dispatch({
        type: "setUi",
        ui: {
          leftSideBarVisible: false,
          rightSideBarVisible: false
        }
      });
    }
    const handleResize = () => {
      if (!window.matchMedia("(min-width: 638px)").matches) {
        dispatch({
          type: "setUi",
          ui: (ui) => __spreadValues(__spreadValues({}, ui), ui.rightSideBarVisible ? { leftSideBarVisible: false } : {})
        });
      }
    };
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  const overrides = useAppStore((s2) => s2.overrides);
  const CustomPuck = (0, import_react57.useMemo)(
    () => overrides.puck || DefaultOverride,
    [overrides]
  );
  const [mounted, setMounted] = (0, import_react57.useState)(false);
  (0, import_react57.useEffect)(() => {
    setMounted(true);
  }, []);
  const ready = useAppStore((s2) => s2.status === "READY");
  useMonitorHotkeys();
  (0, import_react57.useEffect)(() => {
    if (ready && iframe.enabled) {
      const frameDoc = getFrame();
      if (frameDoc) {
        return monitorHotkeys(frameDoc);
      }
    }
  }, [ready, iframe.enabled]);
  usePreviewModeHotkeys();
  useDeleteHotkeys();
  const layoutOptions = {};
  if (leftWidth) {
    layoutOptions["--puck-user-left-side-bar-width"] = `${leftWidth}px`;
  }
  if (rightWidth) {
    layoutOptions["--puck-user-right-side-bar-width"] = `${rightWidth}px`;
  }
  const setUi = useAppStore((s2) => s2.setUi);
  const currentPlugin = useAppStore((s2) => {
    var _a5;
    return (_a5 = s2.state.ui.plugin) == null ? void 0 : _a5.current;
  });
  const appStoreApi = useAppStoreApi();
  const [mobilePanelHeightMode, setMobilePanelHeightMode] = (0, import_react57.useState)("toggle");
  const hasLegacySideBarPlugin = (0, import_react57.useMemo)(
    () => !!(plugins == null ? void 0 : plugins.find((p2) => p2.name === "legacy-side-bar")),
    [plugins]
  );
  const pluginItems = (0, import_react57.useMemo)(() => {
    const details = {};
    const defaultPlugins2 = [blocksPlugin(), outlinePlugin()];
    const isLegacy = (plugin) => plugin.name === "legacy-side-bar" ? -1 : 0;
    const combinedPlugins = [
      ...defaultPlugins2,
      ...plugins != null ? plugins : []
    ].sort((a2, b2) => isLegacy(a2) - isLegacy(b2));
    if (!(plugins == null ? void 0 : plugins.some((p2) => p2.name === "fields"))) {
      combinedPlugins.push(fieldsPlugin());
    }
    combinedPlugins == null ? void 0 : combinedPlugins.forEach((plugin) => {
      var _a5, _b3;
      if (plugin.name && plugin.render) {
        if (details[plugin.name]) {
          delete details[plugin.name];
        }
        details[plugin.name] = {
          label: (_a5 = plugin.label) != null ? _a5 : plugin.name,
          icon: (_b3 = plugin.icon) != null ? _b3 : (0, import_jsx_runtime58.jsx)(ToyBrick, {}),
          onClick: () => {
            var _a23;
            setMobilePanelHeightMode((_a23 = plugin.mobilePanelHeight) != null ? _a23 : "toggle");
            if (plugin.name === currentPlugin) {
              if (leftSideBarVisible) {
                setUi({ leftSideBarVisible: false });
              } else {
                setUi({ leftSideBarVisible: true });
              }
            } else {
              if (plugin.name) {
                setUi({
                  plugin: { current: plugin.name },
                  leftSideBarVisible: true
                });
              }
            }
          },
          isActive: leftSideBarVisible && currentPlugin === plugin.name,
          render: plugin.render,
          mobileOnly: hasLegacySideBarPlugin || plugin.mobileOnly,
          desktopOnly: plugin.name === "legacy-side-bar" || plugin.desktopOnly
        };
      }
    });
    return details;
  }, [plugins, currentPlugin, appStoreApi, leftSideBarVisible]);
  (0, import_react57.useEffect)(() => {
    if (!currentPlugin) {
      const names = Object.keys(pluginItems);
      setUi({ plugin: { current: names[0] } });
    }
  }, [pluginItems, currentPlugin]);
  const hasDesktopFieldsPlugin = pluginItems["fields"] && pluginItems["fields"].mobileOnly === false;
  const mobilePanelExpanded = useAppStore(
    (s2) => {
      var _a5;
      return (_a5 = s2.state.ui.mobilePanelExpanded) != null ? _a5 : false;
    }
  );
  return (0, import_jsx_runtime58.jsxs)(
    "div",
    {
      className: `Puck ${getClassName34({
        hidePlugins: hasLegacySideBarPlugin
      })}`,
      id: instanceId,
      style: { height },
      children: [
        (0, import_jsx_runtime58.jsx)(DragDropContext2, { disableAutoScroll: dnd == null ? void 0 : dnd.disableAutoScroll, children: (0, import_jsx_runtime58.jsx)(CustomPuck, { children: children || (0, import_jsx_runtime58.jsx)(FrameProvider, { children: (0, import_jsx_runtime58.jsx)(
          "div",
          {
            className: getLayoutClassName({
              leftSideBarVisible,
              mounted,
              rightSideBarVisible: !hasDesktopFieldsPlugin && rightSideBarVisible,
              isExpanded: mobilePanelExpanded,
              mobilePanelHeightToggle: mobilePanelHeightMode === "toggle",
              mobilePanelHeightMinContent: mobilePanelHeightMode === "min-content"
            }),
            style: { height },
            children: (0, import_jsx_runtime58.jsxs)(
              "div",
              {
                className: getLayoutClassName("inner"),
                style: layoutOptions,
                children: [
                  (0, import_jsx_runtime58.jsx)("div", { className: getLayoutClassName("header"), children: (0, import_jsx_runtime58.jsx)(Header, { hidePlugins: hasLegacySideBarPlugin }) }),
                  (0, import_jsx_runtime58.jsx)("div", { className: getLayoutClassName("nav"), children: (0, import_jsx_runtime58.jsx)(
                    Nav,
                    {
                      items: pluginItems,
                      mobileActions: leftSideBarVisible && mobilePanelHeightMode === "toggle" && (0, import_jsx_runtime58.jsx)(
                        IconButton,
                        {
                          type: "button",
                          title: "maximize",
                          onClick: () => {
                            setUi({
                              mobilePanelExpanded: !mobilePanelExpanded
                            });
                          },
                          children: mobilePanelExpanded ? (0, import_jsx_runtime58.jsx)(Minimize2, { size: 21 }) : (0, import_jsx_runtime58.jsx)(Maximize2, { size: 21 })
                        }
                      )
                    }
                  ) }),
                  (0, import_jsx_runtime58.jsx)(
                    Sidebar,
                    {
                      position: "left",
                      sidebarRef: leftSidebarRef,
                      isVisible: leftSideBarVisible,
                      onResize: setLeftWidth,
                      onResizeEnd: handleLeftSidebarResizeEnd,
                      children: Object.entries(pluginItems).map(
                        ([id, { mobileOnly, render: Render2, label }]) => (0, import_jsx_runtime58.jsx)(
                          PluginTab,
                          {
                            visible: currentPlugin === id,
                            mobileOnly,
                            children: (0, import_jsx_runtime58.jsx)(Render2, {})
                          },
                          id
                        )
                      )
                    }
                  ),
                  (0, import_jsx_runtime58.jsx)(Canvas, {}),
                  !hasDesktopFieldsPlugin && (0, import_jsx_runtime58.jsx)(
                    Sidebar,
                    {
                      position: "right",
                      sidebarRef: rightSidebarRef,
                      isVisible: rightSideBarVisible,
                      onResize: setRightWidth,
                      onResizeEnd: handleRightSidebarResizeEnd,
                      children: (0, import_jsx_runtime58.jsx)(FieldSideBar, {})
                    }
                  )
                ]
              }
            )
          }
        ) }) }) }),
        (0, import_jsx_runtime58.jsx)("div", { id: "puck-portal-root", className: getClassName34("portal") })
      ]
    }
  );
};
var propsContext = (0, import_react46.createContext)({});
function PropsProvider(props) {
  return (0, import_jsx_runtime59.jsx)(propsContext.Provider, { value: props, children: props.children });
}
var usePropsContext = () => (0, import_react46.useContext)(propsContext);
function PuckProvider({ children }) {
  const {
    config,
    data: initialData,
    ui: initialUi,
    onChange,
    permissions = {},
    plugins,
    overrides,
    viewports = defaultViewports,
    iframe: _iframe,
    initialHistory: _initialHistory,
    metadata,
    onAction,
    fieldTransforms
  } = usePropsContext();
  const iframe = (0, import_react46.useMemo)(
    () => __spreadValues({
      enabled: true,
      waitForStyles: true
    }, _iframe),
    [_iframe]
  );
  const [generatedAppState] = (0, import_react46.useState)(() => {
    var _a5, _b3, _c4;
    const initial = __spreadValues(__spreadValues({}, defaultAppState.ui), initialUi);
    let clientUiState = {};
    if (Object.keys((initialData == null ? void 0 : initialData.root) || {}).length > 0 && !((_a5 = initialData == null ? void 0 : initialData.root) == null ? void 0 : _a5.props)) {
      console.warn(
        "Warning: Defining props on `root` is deprecated. Please use `root.props`, or republish this page to migrate automatically."
      );
    }
    const rootProps = ((_b3 = initialData == null ? void 0 : initialData.root) == null ? void 0 : _b3.props) || (initialData == null ? void 0 : initialData.root) || {};
    const defaultedRootProps = __spreadValues(__spreadValues({}, (_c4 = config.root) == null ? void 0 : _c4.defaultProps), rootProps);
    const root = populateIds(
      toComponent(__spreadProps(__spreadValues({}, initialData == null ? void 0 : initialData.root), { props: defaultedRootProps })),
      config
    );
    const newAppState = __spreadProps(__spreadValues({}, defaultAppState), {
      data: __spreadProps(__spreadValues({}, initialData), {
        root: __spreadProps(__spreadValues({}, initialData == null ? void 0 : initialData.root), { props: root.props }),
        content: initialData.content || []
      }),
      ui: __spreadProps(__spreadValues(__spreadValues({}, initial), clientUiState), {
        // Store categories under componentList on state to allow render functions and plugins to modify
        componentList: config.categories ? Object.entries(config.categories).reduce(
          (acc, [categoryName, category]) => {
            return __spreadProps(__spreadValues({}, acc), {
              [categoryName]: {
                title: category.title,
                components: category.components,
                expanded: category.defaultExpanded,
                visible: category.visible
              }
            });
          },
          {}
        ) : {}
      })
    });
    return walkAppState(newAppState, config);
  });
  const { appendData = true } = _initialHistory || {};
  const [blendedHistories] = (0, import_react46.useState)(
    [
      ...(_initialHistory == null ? void 0 : _initialHistory.histories) || [],
      ...appendData ? [{ state: generatedAppState }] : []
    ].map((history) => {
      let newState = __spreadValues(__spreadValues({}, generatedAppState), history.state);
      if (!history.state.indexes) {
        newState = walkAppState(newState, config);
      }
      return __spreadProps(__spreadValues({}, history), {
        state: newState
      });
    })
  );
  const initialHistoryIndex = (0, import_react46.useMemo)(() => {
    if ((_initialHistory == null ? void 0 : _initialHistory.index) !== void 0 && (_initialHistory == null ? void 0 : _initialHistory.index) >= 0 && (_initialHistory == null ? void 0 : _initialHistory.index) < blendedHistories.length) {
      return _initialHistory == null ? void 0 : _initialHistory.index;
    }
    return blendedHistories.length - 1;
  }, []);
  const initialAppState = blendedHistories[initialHistoryIndex].state;
  const loadedOverrides = useLoadedOverrides({
    overrides,
    plugins
  });
  const loadedFieldTransforms = (0, import_react46.useMemo)(() => {
    const _plugins = plugins || [];
    const pluginFieldTransforms = _plugins.reduce(
      (acc, plugin) => __spreadValues(__spreadValues({}, acc), plugin.fieldTransforms),
      {}
    );
    return __spreadValues(__spreadValues({}, pluginFieldTransforms), fieldTransforms);
  }, [fieldTransforms, plugins]);
  const instanceId = useSafeId();
  const generateAppStore = (0, import_react46.useCallback)(
    (state) => {
      return {
        instanceId,
        state,
        config,
        plugins: plugins || [],
        overrides: loadedOverrides,
        viewports,
        iframe,
        onAction,
        metadata,
        fieldTransforms: loadedFieldTransforms
      };
    },
    [
      instanceId,
      initialAppState,
      config,
      plugins,
      loadedOverrides,
      viewports,
      iframe,
      onAction,
      metadata,
      loadedFieldTransforms
    ]
  );
  const [appStore] = (0, import_react46.useState)(
    () => createAppStore(generateAppStore(initialAppState))
  );
  (0, import_react46.useEffect)(() => {
    if (true) {
      window.__PUCK_INTERNAL_DO_NOT_USE = { appStore };
    }
  }, [appStore]);
  (0, import_react46.useEffect)(() => {
    const state = appStore.getState().state;
    appStore.setState(__spreadValues({}, generateAppStore(state)));
  }, [config, plugins, loadedOverrides, viewports, iframe, onAction, metadata]);
  useRegisterHistorySlice(appStore, {
    histories: blendedHistories,
    index: initialHistoryIndex,
    initialAppState
  });
  const previousData = (0, import_react46.useRef)(null);
  (0, import_react46.useEffect)(() => {
    return appStore.subscribe(
      (s2) => s2.state.data,
      (data) => {
        if (onChange) {
          if (deepEqual(data, previousData.current)) return;
          onChange(data);
          previousData.current = data;
        }
      }
    );
  }, [onChange]);
  useRegisterPermissionsSlice(appStore, permissions);
  const uPuckStore = useRegisterUsePuckStore(appStore);
  (0, import_react46.useEffect)(() => {
    const { resolveAndCommitData } = appStore.getState();
    resolveAndCommitData();
  }, []);
  return (0, import_jsx_runtime59.jsx)(appStoreContext.Provider, { value: appStore, children: (0, import_jsx_runtime59.jsx)(UsePuckStoreContext.Provider, { value: uPuckStore, children }) });
}
function Puck(props) {
  return (0, import_jsx_runtime59.jsx)(PropsProvider, __spreadProps(__spreadValues({}, props), { children: (0, import_jsx_runtime59.jsx)(PuckProvider, __spreadProps(__spreadValues({}, props), { children: (0, import_jsx_runtime59.jsx)(Layout, { children: props.children }) })) }));
}
Puck.Components = Components;
Puck.Fields = Fields;
Puck.Layout = Layout;
Puck.Outline = Outline;
Puck.Preview = Preview2;
init_react_import();
var legacySideBarPlugin = () => ({
  name: "legacy-side-bar",
  render: () => (0, import_jsx_runtime60.jsxs)("div", { style: { overflowY: "auto" }, children: [
    (0, import_jsx_runtime60.jsx)(SidebarSection, { title: "Components", noBorderTop: true, children: (0, import_jsx_runtime60.jsx)(Components, {}) }),
    (0, import_jsx_runtime60.jsx)(SidebarSection, { title: "Outline", children: (0, import_jsx_runtime60.jsx)(Outline, {}) })
  ] })
});
export {
  Action,
  ActionBar,
  AutoField,
  Button,
  Drawer,
  DropZone,
  FieldLabel,
  Group,
  IconButton,
  Label,
  Puck,
  Render,
  RichTextMenu,
  Separator,
  blocksPlugin,
  createUsePuck,
  fieldsPlugin,
  legacySideBarPlugin,
  migrate,
  outlinePlugin,
  overrideKeys,
  registerOverlayPortal,
  renderContext,
  resolveAllData,
  setDeep,
  transformProps,
  useGetPuck,
  usePuck,
  walkTree
};
//# sourceMappingURL=@puckeditor_core.js.map
