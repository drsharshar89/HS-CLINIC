{"version":3,"sources":["/home/runner/work/tiptap/tiptap/packages/html/dist/server/index.cjs","../../src/server/generateHTML.ts","../../src/server/getHTMLFromFragment.ts","../../src/server/generateJSON.ts"],"names":["Window","getSchema"],"mappings":"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","file":"/home/runner/work/tiptap/tiptap/packages/html/dist/server/index.cjs","sourcesContent":[null,"import { type Extensions, type JSONContent, getSchema } from '@tiptap/core'\nimport { Node } from '@tiptap/pm/model'\n\nimport { getHTMLFromFragment } from './getHTMLFromFragment.js'\n\n/**\n * This function generates HTML from a ProseMirror JSON content object.\n *\n * @remarks **Important**: This function requires `happy-dom` to be installed in your project.\n * @param doc - The ProseMirror JSON content object.\n * @param extensions - The Tiptap extensions used to build the schema.\n * @returns The generated HTML string.\n * @example\n * ```js\n * const html = generateHTML(doc, extensions)\n * console.log(html)\n * ```\n */\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  // Use positive Node.js detection to allow for jsdom/happy-dom environments in tests\n  const isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null\n\n  if (!isNode) {\n    throw new Error(\n      'generateHTML can only be used in a Node environment\\nIf you want to use this in a browser environment, use the `@tiptap/html` import instead.',\n    )\n  }\n\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode, schema)\n}\n","import type { Node, Schema } from '@tiptap/pm/model'\nimport { DOMSerializer } from '@tiptap/pm/model'\nimport { Window } from 'happy-dom'\n\n/**\n * Returns the HTML string representation of a given document node.\n *\n * @remarks **Important**: This function requires `happy-dom` to be installed in your project.\n * @param doc - The document node to serialize.\n * @param schema - The Prosemirror schema to use for serialization.\n * @returns A promise containing the HTML string representation of the document fragment.\n *\n * @example\n * ```typescript\n * const html = getHTMLFromFragment(doc, schema)\n * ```\n */\nexport function getHTMLFromFragment(doc: Node, schema: Schema, options?: { document?: Document }): string {\n  if (options?.document) {\n    const wrap = options.document.createElement('div')\n\n    DOMSerializer.fromSchema(schema).serializeFragment(doc.content, { document: options.document }, wrap)\n    return wrap.innerHTML\n  }\n\n  const localWindow = new Window({\n    settings: {\n      disableJavaScriptEvaluation: true,\n      disableJavaScriptFileLoading: true,\n      disableCSSFileLoading: true,\n      disableIframePageLoading: true,\n      disableComputedStyleRendering: true,\n    },\n  })\n  let result: string\n\n  try {\n    const fragment = DOMSerializer.fromSchema(schema).serializeFragment(doc.content, {\n      document: localWindow.document as unknown as Document,\n    })\n\n    const serializer = new localWindow.XMLSerializer()\n    result = serializer.serializeToString(fragment as any)\n  } finally {\n    // clean up happy-dom to avoid memory leaks\n    localWindow.happyDOM.abort()\n    localWindow.happyDOM.close()\n  }\n\n  return result\n}\n","import type { Extensions } from '@tiptap/core'\nimport { getSchema } from '@tiptap/core'\nimport { type ParseOptions, DOMParser as PMDOMParser } from '@tiptap/pm/model'\nimport { Window } from 'happy-dom'\n\n/**\n * Generates a JSON object from the given HTML string and converts it into a Prosemirror node with content.\n * @remarks **Important**: This function requires `happy-dom` to be installed in your project.\n * @param {string} html - The HTML string to be converted into a Prosemirror node.\n * @param {Extensions} extensions - The extensions to be used for generating the schema.\n * @param {ParseOptions} options - The options to be supplied to the parser.\n * @returns {Promise<Record<string, any>>} - A promise with the generated JSON object.\n * @example\n * const html = '<p>Hello, world!</p>'\n * const extensions = [...]\n * const json = generateJSON(html, extensions)\n * console.log(json) // { type: 'doc', content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Hello, world!' }] }] }\n */\nexport function generateJSON(html: string, extensions: Extensions, options?: ParseOptions): Record<string, any> {\n  // Use positive Node.js detection to allow for jsdom/happy-dom environments in tests\n  const isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null\n\n  if (!isNode) {\n    throw new Error(\n      'generateJSON can only be used in a Node environment\\nIf you want to use this in a browser environment, use the `@tiptap/html` import instead.',\n    )\n  }\n\n  const localWindow = new Window({\n    settings: {\n      disableJavaScriptEvaluation: true,\n      disableJavaScriptFileLoading: true,\n      disableCSSFileLoading: true,\n      disableIframePageLoading: true,\n      disableComputedStyleRendering: true,\n    },\n  })\n  const localDOMParser = new localWindow.DOMParser()\n  let result: Record<string, any>\n\n  try {\n    const schema = getSchema(extensions)\n    let doc: ReturnType<typeof localDOMParser.parseFromString> | null = null\n\n    const htmlString = `<!DOCTYPE html><html><body>${html}</body></html>`\n    doc = localDOMParser.parseFromString(htmlString, 'text/html')\n\n    if (!doc) {\n      throw new Error('Failed to parse HTML string')\n    }\n\n    result = PMDOMParser.fromSchema(schema)\n      .parse(doc.body as unknown as Node, options)\n      .toJSON()\n  } finally {\n    // clean up happy-dom to avoid memory leaks\n    localWindow.happyDOM.abort()\n    localWindow.happyDOM.close()\n  }\n\n  return result\n}\n"]}