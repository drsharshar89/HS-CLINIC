{"version":3,"sources":["../../src/server/generateHTML.ts","../../src/server/getHTMLFromFragment.ts","../../src/server/generateJSON.ts"],"sourcesContent":["import { type Extensions, type JSONContent, getSchema } from '@tiptap/core'\nimport { Node } from '@tiptap/pm/model'\n\nimport { getHTMLFromFragment } from './getHTMLFromFragment.js'\n\n/**\n * This function generates HTML from a ProseMirror JSON content object.\n *\n * @remarks **Important**: This function requires `happy-dom` to be installed in your project.\n * @param doc - The ProseMirror JSON content object.\n * @param extensions - The Tiptap extensions used to build the schema.\n * @returns The generated HTML string.\n * @example\n * ```js\n * const html = generateHTML(doc, extensions)\n * console.log(html)\n * ```\n */\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  // Use positive Node.js detection to allow for jsdom/happy-dom environments in tests\n  const isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null\n\n  if (!isNode) {\n    throw new Error(\n      'generateHTML can only be used in a Node environment\\nIf you want to use this in a browser environment, use the `@tiptap/html` import instead.',\n    )\n  }\n\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode, schema)\n}\n","import type { Node, Schema } from '@tiptap/pm/model'\nimport { DOMSerializer } from '@tiptap/pm/model'\nimport { Window } from 'happy-dom'\n\n/**\n * Returns the HTML string representation of a given document node.\n *\n * @remarks **Important**: This function requires `happy-dom` to be installed in your project.\n * @param doc - The document node to serialize.\n * @param schema - The Prosemirror schema to use for serialization.\n * @returns A promise containing the HTML string representation of the document fragment.\n *\n * @example\n * ```typescript\n * const html = getHTMLFromFragment(doc, schema)\n * ```\n */\nexport function getHTMLFromFragment(doc: Node, schema: Schema, options?: { document?: Document }): string {\n  if (options?.document) {\n    const wrap = options.document.createElement('div')\n\n    DOMSerializer.fromSchema(schema).serializeFragment(doc.content, { document: options.document }, wrap)\n    return wrap.innerHTML\n  }\n\n  const localWindow = new Window({\n    settings: {\n      disableJavaScriptEvaluation: true,\n      disableJavaScriptFileLoading: true,\n      disableCSSFileLoading: true,\n      disableIframePageLoading: true,\n      disableComputedStyleRendering: true,\n    },\n  })\n  let result: string\n\n  try {\n    const fragment = DOMSerializer.fromSchema(schema).serializeFragment(doc.content, {\n      document: localWindow.document as unknown as Document,\n    })\n\n    const serializer = new localWindow.XMLSerializer()\n    result = serializer.serializeToString(fragment as any)\n  } finally {\n    // clean up happy-dom to avoid memory leaks\n    localWindow.happyDOM.abort()\n    localWindow.happyDOM.close()\n  }\n\n  return result\n}\n","import type { Extensions } from '@tiptap/core'\nimport { getSchema } from '@tiptap/core'\nimport { type ParseOptions, DOMParser as PMDOMParser } from '@tiptap/pm/model'\nimport { Window } from 'happy-dom'\n\n/**\n * Generates a JSON object from the given HTML string and converts it into a Prosemirror node with content.\n * @remarks **Important**: This function requires `happy-dom` to be installed in your project.\n * @param {string} html - The HTML string to be converted into a Prosemirror node.\n * @param {Extensions} extensions - The extensions to be used for generating the schema.\n * @param {ParseOptions} options - The options to be supplied to the parser.\n * @returns {Promise<Record<string, any>>} - A promise with the generated JSON object.\n * @example\n * const html = '<p>Hello, world!</p>'\n * const extensions = [...]\n * const json = generateJSON(html, extensions)\n * console.log(json) // { type: 'doc', content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Hello, world!' }] }] }\n */\nexport function generateJSON(html: string, extensions: Extensions, options?: ParseOptions): Record<string, any> {\n  // Use positive Node.js detection to allow for jsdom/happy-dom environments in tests\n  const isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null\n\n  if (!isNode) {\n    throw new Error(\n      'generateJSON can only be used in a Node environment\\nIf you want to use this in a browser environment, use the `@tiptap/html` import instead.',\n    )\n  }\n\n  const localWindow = new Window({\n    settings: {\n      disableJavaScriptEvaluation: true,\n      disableJavaScriptFileLoading: true,\n      disableCSSFileLoading: true,\n      disableIframePageLoading: true,\n      disableComputedStyleRendering: true,\n    },\n  })\n  const localDOMParser = new localWindow.DOMParser()\n  let result: Record<string, any>\n\n  try {\n    const schema = getSchema(extensions)\n    let doc: ReturnType<typeof localDOMParser.parseFromString> | null = null\n\n    const htmlString = `<!DOCTYPE html><html><body>${html}</body></html>`\n    doc = localDOMParser.parseFromString(htmlString, 'text/html')\n\n    if (!doc) {\n      throw new Error('Failed to parse HTML string')\n    }\n\n    result = PMDOMParser.fromSchema(schema)\n      .parse(doc.body as unknown as Node, options)\n      .toJSON()\n  } finally {\n    // clean up happy-dom to avoid memory leaks\n    localWindow.happyDOM.abort()\n    localWindow.happyDOM.close()\n  }\n\n  return result\n}\n"],"mappings":";AAAA,SAA4C,iBAAiB;AAC7D,SAAS,YAAY;;;ACArB,SAAS,qBAAqB;AAC9B,SAAS,cAAc;AAehB,SAAS,oBAAoB,KAAW,QAAgB,SAA2C;AACxG,MAAI,mCAAS,UAAU;AACrB,UAAM,OAAO,QAAQ,SAAS,cAAc,KAAK;AAEjD,kBAAc,WAAW,MAAM,EAAE,kBAAkB,IAAI,SAAS,EAAE,UAAU,QAAQ,SAAS,GAAG,IAAI;AACpG,WAAO,KAAK;AAAA,EACd;AAEA,QAAM,cAAc,IAAI,OAAO;AAAA,IAC7B,UAAU;AAAA,MACR,6BAA6B;AAAA,MAC7B,8BAA8B;AAAA,MAC9B,uBAAuB;AAAA,MACvB,0BAA0B;AAAA,MAC1B,+BAA+B;AAAA,IACjC;AAAA,EACF,CAAC;AACD,MAAI;AAEJ,MAAI;AACF,UAAM,WAAW,cAAc,WAAW,MAAM,EAAE,kBAAkB,IAAI,SAAS;AAAA,MAC/E,UAAU,YAAY;AAAA,IACxB,CAAC;AAED,UAAM,aAAa,IAAI,YAAY,cAAc;AACjD,aAAS,WAAW,kBAAkB,QAAe;AAAA,EACvD,UAAE;AAEA,gBAAY,SAAS,MAAM;AAC3B,gBAAY,SAAS,MAAM;AAAA,EAC7B;AAEA,SAAO;AACT;;;ADhCO,SAAS,aAAa,KAAkB,YAAgC;AAE7E,QAAM,SAAS,OAAO,YAAY,eAAe,QAAQ,YAAY,QAAQ,QAAQ,SAAS,QAAQ;AAEtG,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS,UAAU,UAAU;AACnC,QAAM,cAAc,KAAK,SAAS,QAAQ,GAAG;AAE7C,SAAO,oBAAoB,aAAa,MAAM;AAChD;;;AE/BA,SAAS,aAAAA,kBAAiB;AAC1B,SAA4B,aAAa,mBAAmB;AAC5D,SAAS,UAAAC,eAAc;AAehB,SAAS,aAAa,MAAc,YAAwB,SAA6C;AAE9G,QAAM,SAAS,OAAO,YAAY,eAAe,QAAQ,YAAY,QAAQ,QAAQ,SAAS,QAAQ;AAEtG,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,cAAc,IAAIA,QAAO;AAAA,IAC7B,UAAU;AAAA,MACR,6BAA6B;AAAA,MAC7B,8BAA8B;AAAA,MAC9B,uBAAuB;AAAA,MACvB,0BAA0B;AAAA,MAC1B,+BAA+B;AAAA,IACjC;AAAA,EACF,CAAC;AACD,QAAM,iBAAiB,IAAI,YAAY,UAAU;AACjD,MAAI;AAEJ,MAAI;AACF,UAAM,SAASD,WAAU,UAAU;AACnC,QAAI,MAAgE;AAEpE,UAAM,aAAa,8BAA8B,IAAI;AACrD,UAAM,eAAe,gBAAgB,YAAY,WAAW;AAE5D,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,MAAM,6BAA6B;AAAA,IAC/C;AAEA,aAAS,YAAY,WAAW,MAAM,EACnC,MAAM,IAAI,MAAyB,OAAO,EAC1C,OAAO;AAAA,EACZ,UAAE;AAEA,gBAAY,SAAS,MAAM;AAC3B,gBAAY,SAAS,MAAM;AAAA,EAC7B;AAEA,SAAO;AACT;","names":["getSchema","Window"]}